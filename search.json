[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggalign: Bridging the Grammar of Graphics and Complex layout",
    "section": "",
    "text": "Preface\nWelcome to ggalign documents. Examples in the book are generated under version 0.0.5.9000.\nIn the world of data visualization, aligning multiple plots in a coherent and organized layout is often a challenging task, especially when dealing with complex datasets that require precise alignment across rows, columns, and even within plot elements. While existing tools provide some solutions, they often fall short in offering the flexibility, control, and simplicity that users need to create intricate and beautiful plots. This is where ggalign comes in.\nThe ggalign package, built on top of the powerful ggplot2 framework, is designed to solve this very problem. It offers a suite of functions specifically crafted for aligning and organizing plots with minimal effort. Whether you need to align observations based on statistical measures, group plots by categorical factors, or fine-tune the layout to match the precise needs of your data, ggalign gives you the tools you need to create polished, publication-ready visualizations.\nThis book serves as both an introduction to the ggalign package and a comprehensive guide to mastering its features. Whether you’re a beginner or an experienced user of ggplot2, you’ll find detailed explanations, step-by-step tutorials, and real-world examples to help you leverage the full potential of ggalign in your work.\nThroughout this book, we will cover everything from basic concepts to advanced layout customizations, focusing on key functions like stack_layout(), align_* series (including align_group(), align_order(), and align_hclust()), and how to combine them with other ggplot2 layers to create aligned plots. Additionally, you’ll learn how to adapt ggalign for different data types and scenarios, allowing you to develop flexible, dynamic visualizations tailored to your specific needs.\nBy the end of this book, you will be equipped to use ggalign effectively in your own projects, whether for scientific research, data analysis, or any other field where data visualization is key. Our goal is to provide you with the knowledge and confidence to tackle complex visualization challenges and transform your datasets into clear, impactful, and visually appealing plots.\nThank you for choosing ggalign. We hope this book will inspire you to explore the endless possibilities that come with aligned data visualization.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Installation\nggalign extends ggplot2 by providing advanced tools for aligning and organizing multiple plots, particularly those that automatically reorder observations, such as dendrogram. It offers fine control over layout adjustment and plot annotations, enabling you to create complex visualizations while leveraging the familiar grammar of ggplot2.\nYou can install ggalign from CRAN using:\ninstall.packages(\"ggalign\")\nAlternatively, install the development version from r-universe with:\ninstall.packages(\"ggalign\",\n    repos = c(\"https://yunuuuu.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nor from GitHub with:\n# install.packages(\"remotes\")\nremotes::install_github(\"Yunuuuu/ggalign\")",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#general-design",
    "href": "introduction.html#general-design",
    "title": "1  Introduction",
    "section": "1.2 General design",
    "text": "1.2 General design\nThe core feature of ggalign lies in its integration of the grammar of graphics into advanced visualization through its object-oriented Layout system. The package provides three main Layout classes:\n\nthe StackLayout class: Put plots horizontally or vertically.\nthe QuadLayout class: Arranges plots in the four quadrants (top, left, bottom, right) around a main plot. This layout is ideal for designs that require supplementary plots or annotations surrounding a central figure.\nthe CircleLayout class: Positions plots in a circular arrangement.\n\nEach Layout class supports the alignment of both discrete (ordinal) and continuous variables. Depending on the desired alignment across multiple plots within a layout, the following variants are available:\nFor StackLayout:\n\nstack_discrete(): Align discrete variable along the stack.\nstack_continuous(): Align continuous variable along the stack.\n\nstack_layout() integrates the functionalities of stack_discrete() and stack_continuous() into a single interface. For simplicity, throughout this book, I will refer to both variants as stack_layout().\nFor QuadLayout:\n\nquad_continuous/ggside: Align continuous variables in both horizontal and vertical directions.\nquad_discrete: Align discrete variables in both horizontal and vertical directions.\nquad_layout: Aligns discrete or continuous variables either horizontally or vertically.\n\nThe functions quad_continuous() and quad_discrete() are specialized versions of quad_layout() (Section 7.5): quad_continuous() sets both xlim and ylim arguments, while quad_discrete() does not set xlim or ylim. For simplicity, throughout this book, I will refer to all of the variants as quad_layout().\nFor CircleLayout:\n\ncircle_discrete(): Align discrete variable in the circle.\ncircle_continuous(): Align continuous variable in the circle.\n\ncircle_layout() integrates the functionalities of circle_discrete() and circle_continuous() into a single interface. For simplicity, throughout this book, I will refer to both variants as circle_layout().\n\n\n\nGeneral design of ggalign",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#sec-align-axes",
    "href": "introduction.html#sec-align-axes",
    "title": "1  Introduction",
    "section": "1.3 Align axes in ggplot",
    "text": "1.3 Align axes in ggplot\nBefore introducing the package, let’s first discuss how to align axes in ggplot2. For continuous axes, alignment is straightforward because we just need to ensure that all plots have the same limits. This can be achieved in the *_continuous() function by setting the limits (or xlim/ylim) argument.\nAligning discrete axes is more challenging because we must first ensure that the number of unique discrete values is the same across all plots, and that the ordering is consistent. In ggplot2, it’s difficult to align discrete axes, since some plots may self-ordered. This issue is compounded when working with long-formatted data frames, which is required by ggplot2.\nTo address this, the ggalign package typically uses matrix input for layouts that require aligning discrete axes (*_discrete() functions). Each row of the matrix represents a unique discrete value (observation), and the number of rows corresponds to the total number of unique values (number of observations). To ensure consistent ordering across plots, the internal just need to reorder the rows. This approach is also well-suited for functions like quad_layout()/ggheatmap(), where axes need to be aligned in both directions simultaneously, as matrices can be transposed (i.e., switching rows to columns and columns to rows). When drawing the plot, the ggalign package will melt the matrix into a long-formatted data frame. You may worry about that the matrix format may not fully support all input requirements for plots, the ggalign package provides a function (scheme_data()) to transform the plot data as needed to fit your specific use case.\nWe often refer to “observations” when discussing discrete axes. Observations typically correspond to discrete variables, such as data points or samples. In the rest of the book, I will use “observations” and “discrete variables” interchangeably. You can assume that any reference to “observations” also applies to discrete variables.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#getting-started",
    "href": "introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.4 Getting Started",
    "text": "1.4 Getting Started\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n\nThe usage of ggalign is simple if you’re familiar with ggplot2 syntax, the typical workflow includes:\n\nInitialize the layout.\nCustomize the layout with:\n\nalign_group(): Group observations into panel with a group variable.\nalign_kmeans(): Group observations into panel by kmeans.\nalign_order(): Reorder layout observations based on statistical weights or by manually specifying the observation index.\nalign_reorder: Reorder observations using an arbitrary statistical function\nalign_hclust(): Reorder or group observations based on hierarchical clustering.\n\nAdding plots with:\n\nalign_dendro(): Add a dendrogram to the plot, and reorder or group observations based on hierarchical clustering.\nggalign(): Initialize a ggplot object and align the axes.\nggmark(): Add a plot to annotate selected observations.\nggcross(): Initialize a ggplot object to connect two different layout crosswise\nggfree(): Initialize a ggplot object without aligning the axes.\n\nLayer additional ggplot2 elements such as geoms, stats, or scales.\n\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(56), nrow = 7)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\n\nEvery *_layout() function accepts default data, which will be inherited by all plots within the layout.\nHere’s a simple example:\n\n1stack_discretev(small_mat) +\n2    align_dendro() +\n3    theme(axis.text.x = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nAdd x-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThis function produces a simple dendrogram. The stack_discretev() function initializes a vertical stack and aligns discrete variables. It is simply an alias for stack_discrete(\"v\"). By default, the axis text on the axis used for alignment is removed. This is because it’s often unclear which plot should display the axis text, as typically, we want it to appear in only one plot. However, you can easily use the theme() function to control where the axis text appears.\nInternally, align_dendro() will reorder the observations based on the dendrogram, and other plots in the layout will follow this ordering.\n\n1stack_discretev(small_mat) +\n2    align_dendro() +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.discrete_x, value), stat = \"identity\") +\n5    theme(axis.text.x = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd x-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThe data in the underlying ggplot object of ggalign() function contains following columns (more details will be introduced in the Section 5.1):\n\n.panel: the group panel for the aligned axis. It means x-axis for vertical stack layout, y-axis for horizontal stack layout.\n.x/.y and .discrete_x/.discrete_y: an integer index of x/y coordinates and a factor of the data labels (only applicable when names exists).\n.names and .index: A character names (only applicable when names exists) and an integer of index of the original data.\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\n\nIt is recommended to use .x/.y, or .discrete_x/.discrete_y as the x/y mapping.\n\nalign_dendro() can also split the observations into groups.\n\n1stack_alignv(small_mat) +\n2    align_dendro(k = 3) +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.discrete_x, value, fill = .panel), stat = \"identity\") +\n5    scale_fill_brewer(palette = \"Dark2\", name = \"Group\") +\n6    theme(axis.text.x = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nSet fill scale palette.\n\n6\n\nAdd x-axis text.\n\n\n\n\n\n\n\n\n\n\n\nOne common visualization associated with the dendrogram is the heatmap. You can use ggheatmap() to initialize a heatmap layout. When grouping the observations using align_dendro(k = 3), a special column named branch is added, which you can use to color the dendrogram tree.\n\n1ggheatmap(small_mat) +\n2    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n3    anno_left() +\n4    align_dendro(aes(color = branch), k = 3) +\n5    scale_fill_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\nWe initialize a heatmap layout.\n\n2\n\nadjust the x-axis label theme element.\n\n3\n\nwe initialize an annotation in the left side of the heatmap body, and set it as the active context, in this way, all following addition will be directed to the left annotation.\n\n4\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree, coloring the tree by branch.\n\n5\n\nSet fill scale palette.\n\n\n\n\n\n\n\n\n\n\n\nggheatmap() will automatically add axis text in the heatmap body, so you don’t need to manually adjust axis text visibility using theme(axis.text.x = element_text())/theme(axis.text.y = element_text()).\nWe can also arrange the dendrogram in a circular layout to visualize hierarchical relationships in a more compact and aesthetically pleasing way.\n\n1circle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n2    ggalign() +\n3    geom_tile(aes(y = .column_index, fill = value)) +\n4    scale_fill_viridis_c() +\n5    align_dendro(aes(color = branch), k = 3L) +\n6    scale_color_brewer(palette = \"Dark2\")\n\n\n1\n\nWe initialize a circle layout and set the inner radius.\n\n2\n\nCreate a new ggplot in the layout, and use data the same with the layout data.\n\n3\n\nAdd a tile layer, the matrix input will be converted into a long formated data frame with column .column_index indicates the column index of the original matrix.\n\n4\n\nSet fill scale palette.\n\n5\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree, coloring the tree by branch.\n\n6\n\nSet color scale palette.\n\n\n\n\n\n\n\n\n\n\n\nHaving explored the core principles of ggalign, you should now be familiar with its basic workflow. In the next chapter, we’ll introduce the StackLayout, a powerful tool for arranging multiple plots in a stacked fashion—either horizontally or vertically—while maintaining full control over their alignment. We’ll explore how StackLayout and its various functions can give you even greater flexibility in creating sophisticated layouts.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "stack-layout.html",
    "href": "stack-layout.html",
    "title": "2  stack layout",
    "section": "",
    "text": "2.1 Input data\nstack_layout() arranges plots either horizontally or vertically. Based on whether we want to align the discrete or continuous variables, there are two types of stack layouts:\nstack_layout() integrates the functionalities of stack_discrete() and stack_continuous() into a single interface. The first argument for these three functions is direction which should be a single string indicating the direction of the stack layout, either \"h\"(horizontal) or \"v\"(vertical).\nSeveral aliases are available for convenience:\nAs discussed in Section 1.3, when aligning discrete variables, we typically use a matrix. For continuous axes, we can still use the long-formatted data frame, which is the same as in ggplot2.\nBy default, fortify_data_frame() will invoke the ggplot2::fortify() function for conversion. Note, for matrix, it will be converted to a long-formatted data frame which is different from the ggplot2::fortify().\nstack_discrete()/stack_continuous() will set up the layout, but no plot will be drawn until you add a plot element:\n1stack_discretev(small_mat) +\n2    layout_annotation(\n        theme = theme(plot.background = element_rect(color = \"red\"))\n    )\n# the same for `stack_continuous()`\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nAdd a plot background in for the entire layout.\nIn this example, we use layout_annotation() to insert a plot background in the entire layout, it can also be used to control the theme of title, subtitle, caption (layout_title()), guides, margins, panel.border, panel.spacing.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-input-data",
    "href": "stack-layout.html#sec-stack-layout-input-data",
    "title": "2  stack layout",
    "section": "",
    "text": "For stack_continuous(), a data frame is required, and the input will be automatically converted using fortify_data_frame() if needed.\nFor stack_discrete(), a matrix is required, and the input will be automatically converted using fortify_matrix() if needed.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-layout-customize",
    "href": "stack-layout.html#sec-stack-layout-layout-customize",
    "title": "2  stack layout",
    "section": "2.2 Layout Customize",
    "text": "2.2 Layout Customize\nWhen aligning discrete variables, the package offers a suite of align_* functions designed to give you precise control over the ordering and groups. Instead of detailing each align_* function individually, we will focus on the general usage and how to combine them with stack_discrete().\nHere, we remain take align_dendro() as an example, it can reorder the observations, split them into groups, and can add a plot for visualization.\nWhen used for stack_discreteh(), the observations are aligned along the y-axis:\n\n1stack_discreteh(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen used for stack_discretev(), the observations are aligned along the x-axis:\n\n1stack_discretev(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen align_dendro() is added to the layout, it performs following actions:\n\nreorder the observations.\nset the active plot to the dendrogram.\n\nThe active plot refers to the plot that subsequent ggplot2 components will target. In this case, the active plot is the dendrogram, and any new layers added will be applied to it. For instance, we can add additional layers to visualize the dendrogram’s structure or data. The default data underlying the ggplot object of align_dendro() consists of the dendrogram node data. It is also possible to use the dendrogram’s edge data for customization, which I will introduce in Section 5.4.\n\n1stack_discreteh(small_mat) +\n2    align_dendro() +\n3    geom_point()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n3\n\nadd a point layer to the dendrogram\n\n\n\n\n\n\n\n\n\n\n\nThe active argument controls whether a plot should be set as the active plot. It accepts an active() object with the use argument to specify if the plot should be active when added.\n\n1stack_discreteh(small_mat) +\n2    align_dendro(active = active(use = FALSE)) +\n3    geom_point()\n#&gt; Error in `chain_layout_add()`:\n#&gt; ! Cannot add `geom_point()` to the horizontal `stack_discrete()`\n#&gt; ℹ No active plot component\n#&gt; ℹ Did you forget to initialize a &lt;ggplot&gt; object with `ggalign()` or\n#&gt;   `ggfree()`?\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, but don’t set the active plot to this plot.\n\n3\n\ntry to add a point layer to the dendrogram, should fail due to no active plot\n\n\n\n\nUsually, you don’t need to set this manually, as the active context is automatically applied only for functions that add plot areas. You can inspect whether a align_* function will add a plot by print it:\n\nalign_dendro()\n#&gt; &lt;Class: AlignDendro AlignHclust Align AlignProto&gt;\n#&gt;      plot: yes\n#&gt;   reorder: yes\n#&gt;     split: no\n\nYou might find it confusing that we mentioned align_dendro() will split observations into groups, while the print output shows split = \"no\". This happens because we haven’t specified the k/h argument in align_dendro().\n\nalign_dendro(k = 3L)\n#&gt; &lt;Class: AlignDendro AlignHclust Align AlignProto&gt;\n#&gt;      plot: yes\n#&gt;   reorder: yes\n#&gt;     split: yes\n\nYou don’t need to explicitly provide data to align_dendro(). By default, it inherits data from the layout. However, you can always provide another data source, but note that this package uses the concept of number of observations (NROW()). When aligning the observations, you must ensure the number of observations is consistent across all plots.\n\nset.seed(123)\n1stack_discreteh(small_mat) +\n2    align_dendro(data = matrix(rnorm(56), nrow = 8)) +\n3    theme(axis.text.y = element_text())\n#&gt; Error in interact_layout(..., self = self): object 'layout_name' not found\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on hierarchical clustering, add a dendrogram tree, and set the active plot to this one, using self-provided data. This should fail because the number of observations is inconsistent.\n\n3\n\ntry to add y-axis text to the dendrogram.\n\n\n\n\n\nset.seed(123)\n1stack_discreteh(small_mat) +\n2    align_dendro(data = matrix(rnorm(70), nrow = 7)) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot, using self-provided data\n\n3\n\nadd y-axis text to the dendrogram.\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can provide a function (or purrr-lambda) that will be applied to the layout’s matrix. For layouts that align observations, a matrix is always required, so the data input must be in matrix form.\n\nset.seed(123)\n1stack_discreteh(small_mat) +\n2    align_dendro(data = ~ .x[sample(nrow(.x)), ]) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot, using self-provided data function\n\n3\n\nadd y-axis text to the dendrogram.\n\n\n\n\n\n\n\n\n\n\n\nWithout adding another plot, it’s difficult to appreciate the benefits. Let’s now explore how to incorporate a plot.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-initialize",
    "href": "stack-layout.html#sec-stack-layout-plot-initialize",
    "title": "2  stack layout",
    "section": "2.3 Plot initialize",
    "text": "2.3 Plot initialize\nThere are two primary functions for adding plots:\n\nggalign(): Initialize a ggplot object and align the axes.\nggfree(): Initialize a ggplot object without aligning the axes.\n\nBoth functions initialize a ggplot object and, by default, set the active plot when added to the layout.\n\n1stack_discreteh(small_mat) +\n2    align_dendro() +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(value, .discrete_y), stat = \"identity\") +\n5    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n3\n\ninitialize a ggplot object, and set the active plot to this plot, using self-provided data function\n\n4\n\nadd a bar to the plot\n\n5\n\nadd y-axis text\n\n\n\n\n\n\n\n\n\n\n\nYou can build the plot separately and then add it to the layout:\n\n1my_bar &lt;- ggalign(data = rowSums) +\n    geom_bar(aes(value, .discrete_y), stat = \"identity\") +\n    theme(axis.text.y = element_text())\n2stack_discreteh(small_mat) +\n3    align_dendro() +\n4    my_bar\n\n\n1\n\nCreate the bar plot.\n\n2\n\ninitialize a horizontal stack layout.\n\n3\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n4\n\nAdd another bar plot to the layout.\n\n\n\n\n\n\n\n\n\n\n\nThe active argument can also control the place of the plot area to be added. It accepts an active() object with the order argument to specify the order of the plot area.\n\nstack_discreteh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums, active = active(order = 1)) +\n    geom_bar(aes(value, .discrete_y), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can also stack plots vertically using stack_discretev():\n\nstack_discretev(small_mat) + \n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(.discrete_x, value), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nggfree() focuses on layout integration without enforcing strict axis alignment.\n\nstack_discretev() +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nThe & operator applies the added element to all plots in the layout, similar to its functionality in the patchwork package.\nFor stack_continuous(), only free plots (ggfree()) can be added. This layout arranges plots in one row or column without enforcing axis alignment:\n\nstack_continuousv(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nBy default, ggfree() will also inherit data from the layout and call fortify_data_frame() to convert the data to a data frame. So, note that if the layout data is a matrix, it will be converted into a long-formatted data frame.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-size",
    "href": "stack-layout.html#sec-stack-layout-plot-size",
    "title": "2  stack layout",
    "section": "2.4 Plot Size",
    "text": "2.4 Plot Size\nBoth ggalign() and ggfree() functions have a size argument to control the relative width (for horizontal stack layout) or height (for vertical stack layout) of the plot’s panel area.\n\nstack_continuousv(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 2) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 1) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nAlternatively, you can define an absolute size by using a unit() object:\n\nstack_continuousv(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = unit(1, \"cm\")) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-active-plot",
    "href": "stack-layout.html#sec-stack-layout-active-plot",
    "title": "2  stack layout",
    "section": "2.5 active plot",
    "text": "2.5 active plot\nAs mentioned earlier, the active plot refers to the plot that subsequent ggplot2 components will target. The package provide two functions to work with active plot for stack_layout.\n\nstack_switch(): switch the active context\nstack_active(): An alias for stack_switch(), which sets what = NULL\n\nThe stack_switch() function accepts the what argument, which can either be the index of the plot added (based on its adding order) or the plot name specified via the active() object using the name argument.\nNote that the what argument must be explicitly named, as it is placed second in the function signature. This is because, in most cases, we don’t need to switch the active plot, manually—adjusting the order of plot additions typically suffices.\n\n\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .discrete_y), stat = \"identity\") +\n    stack_switch(what = 1) +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by integer\")\n\n\n\n\n\n\n\n\n\n\n\nstack_alignh(small_mat) +\n    align_dendro(active = active(name = \"tree\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .discrete_y), stat = \"identity\") +\n    stack_switch(what = \"tree\") +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by string\")\n\n\n\n\n\n\n\n\n\n\nIn the example, we use layout_title() to insert a title for the entire layout. Alternatively, you can add a title to a single plot with ggtitle().\nBy setting what = NULL (or alias stack_active()), we remove the active plot. This is particularly useful when the active plot is a nested Layout object, as any additions would otherwise be directed to that nested Layout. By removing the active plot, you can continue adding components to the StackLayout. We’ll introduce the nested layout of StackLayout in Chapter 8.\nIn the next chapter, we will dive into the HeatmapLayout, which can take the StackLayout as input. Heatmap layouts offer additional features for aligning observations in both directions. Let’s move ahead and explore how heatmaps can be seamlessly integrated into your layout workflows.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html",
    "href": "heatmap-layout.html",
    "title": "3  heatmap layout",
    "section": "",
    "text": "3.1 input data\nThe heatmap_layout() function provides a powerful way to create customizable heatmaps in R using ggplot2. This chapter will guide you through its usage.\nheatmap_layout() is a specialized version of quad_discrete(), which itself is a specific variant of QuadLayout (quad_layout()) designed to align discrete variables both horizontally and vertically. We introduce heatmap_layout() directly, as it is more familiar to many users, especially those experienced with popular heatmap packages like pheatmap and ComplexHeatmap.\nheatmap_layout() simplifies the creation of heatmap plots by integrating essential elements for a standard heatmap layout, ensuring that the appropriate data mapping and visualization layers are automatically applied. ggheatmap() is an alias for heatmap_layout().\nAs mentioned in Section 1.3, we typically require a matrix for the Layout which need align discrete variables. Internally, fortify_matrix() will be used to process the data. You can provide a numeric or character vector, a data frame, or any other data type that can be converted into a matrix using as.matrix().\nggheatmap(small_mat)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-main-plot",
    "href": "heatmap-layout.html#sec-heatmap-layout-main-plot",
    "title": "3  heatmap layout",
    "section": "3.2 Main plot (heatmap body)",
    "text": "3.2 Main plot (heatmap body)\nThe ggheatmap()/quad_layout() functions arrange plots in the Quad-Side layout of the main plot. When the layout is initialized, a ggplot object is automatically created for the main plot.\nFor ggheatmap(), the matrix input will be converted into a long-format data frame when drawing. The data in the underlying ggplot object includes the following columns:\n\n.xpanel and .ypanel: the column and row panel\n.x and .y: the x and y coordinates\n.row_names and .column_names: A factor of the row and column names of the original matrix (only applicable when names exist).\n.row_index and .column_index: the row and column index of the original matrix.\nvalue: the actual matrix value.\n\nThe default mapping will use aes(.data$.x, .data$.y), but can be customized using mapping argument.\nBy default, the main plot is regarded as the active plot, meaning you can add ggplot2 elements directly to the main plot.\n\nggheatmap(small_mat) + \n    geom_point() + \n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, ggheatmap() adds a heatmap layer. If the matrix has more than 20,000 cells (nrow * ncol &gt; 20000), it uses geom_raster() for performance efficiency; for smaller matrices, geom_tile() is used. You can explicitly choose the layer by providing a single string (\"raster\" or \"tile\") in the filling argument.\n\nggheatmap(small_mat, filling = \"raster\")\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = \"tile\")\n\n\n\n\n\n\n\n\nNote, the filling layer will always use mapping of aes(.data$.x, .data$.y), if you want to customize filling, you can set filling = NULL, which will remove the filling layer and allow you to add custom filling geoms.\n\nggheatmap(small_mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"black\", width = 0.9, height = 0.9)\n\n\n\n\n\n\n\n\nA heatmap pie charts can be easily drawn:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#rasterization",
    "href": "heatmap-layout.html#rasterization",
    "title": "3  heatmap layout",
    "section": "3.3 rasterization",
    "text": "3.3 rasterization\nWhen working with large heatmaps, it’s often beneficial to rasterize the heatmap body layer. You can achieve this by using the raster_magick() function. The res argument controls the resolution of the raster image. By default, the res argument matches the resolution of the current device, but specifying a different value can help reduce the resolution of the rasterized heatmap body.\n\nggheatmap(small_mat, aes(.x, .y), filling = NULL) +\n    raster_magick(geom_tile(aes(fill = value)), res = 50)\n\n\n\n\n\n\n\n\nBy leveraging raster_magick(), you can also perform image post-processing using the magick package. This allows for custom image resizing with filters.\n\nggheatmap(small_mat, filling = NULL) +\n    # Use `magick::filter_types()` to check available `filter` arguments\n    raster_magick(geom_raster(aes(fill = value)),\n        magick = function(image) {\n            magick::image_resize(image,\n                # we resize to the 50% of width\n                geometry = \"50%x\", filter = \"Lanczos\"\n            )\n        }\n    )\n\n\n\n\n\n\n\n\nNote: When using magick::image_resize(), you should specify the geometry argument to resize the image. If only the filter is specified, it will only distort the image data (though subtle). For more information on image resizing, refer to ImageMagick’s resize documentation.\nYou can also rasterize all plots in the layout directly with raster_magick(). This method is defined for both ggheatmap()/quad_layout() and stack_layout() objects.\nAdditionally, You can use external packages like ggrastr or ggfx to rasterize the heatmap body.\n\nggheatmap(small_mat, filling = FALSE) +\n    ggrastr::rasterise(geom_tile(aes(fill = value)), dev = \"ragg\")\n\n\n\n\n\n\n\n\nLikewise, you can also rasterize all plots in the layout directly with ggrastr::rasterise() for both ggheatmap()/quad_layout() and stack_layout().\n\nggrastr::rasterise(ggheatmap(small_mat), dev = \"ragg\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFurthermore, ggfx offers many image filters that can be applied to ggplot2 layers. See the package for the details.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "href": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "title": "3  heatmap layout",
    "section": "3.4 annotations",
    "text": "3.4 annotations\nIn ggheatmap()/quad_layout(), annotations are handled by a stack_layout() object and can be positioned at the top, left, bottom, or right of the main plot (heatmap body). quad_layout() can align discrete or continuous variables either horizontally or vertically. Since the annotation handling is the same for both ggheatmap() and quad_layout(), we introduce the annotation functionality for both together.\nThe annotations will always follow the alignment of the ggheatmap()/quad_layout() in the current direction. For horizontal alignment of discrete variables, stack_discreteh() will be used for left and right annotations, while stack_continuoush() will be used for continuous variables. The same logic applies to vertical alignment—stack_discretev() or stack_continuousv() will be used for top and bottom annotations, depending on whether the variables being aligned are discrete or continuous.\nBy default, ggheatmap()/quad_layout() do not activate an annotation, You can use quad_anno() to activate an annotation, directing all subsequent additions to the specified annotation position. The quad_anno() function has the following aliases:\n\nanno_top: A special case of quad_anno() with position = \"top\".\nanno_left: A special case of quad_anno() with position = \"left\".\nanno_bottom: A special case of quad_anno() with position = \"bottom\".\nanno_right: A special case of quad_anno() with position = \"right\".\n\nWhen quad_anno() is added to a ggheatmap()/quad_layout(), it will try to create a new stack_layout(). For top and bottom annotations, stack_discretev() or stack_continuousv() will be used; for left and right annotations, stack_discreteh() or stack_continuoush() will be applied.\nAdditionally, quad_anno() will set the active context to the annotation. This means that subsequent additions will be directed to the annotation rather than the main plot. We use the term active context in contrast to active plot (as discussed in Section 2.2), since the annotation is a Layout object but not a single plot.\n\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, the annotation stack_layout() will try to inherit data from ggheatmap()/quad_layout(). If we need align discrete variables vertically, this means the data from ggheatmap()/quad_layout() should be a matrix, the column annotations will also require a matrix and the matrix from ggheatmap()/quad_layout() will be transposed for use in the column annotations.\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can further customize the layout design or add new plots in the annotation stack, as described in Chapter 2.\n\nggheatmap(small_mat) +\n    # in the heatmap body, we set the axis text theme\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the right annotation\n    anno_right() +\n    # in the right annotation, we add a dendrogram\n    align_dendro(k = 3L) +\n    # in the dendrogram, we add a point layer\n    geom_point(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this example:\n\nanno_right() initialize the right annotation stack, and change the active context to the right annotation of the heatmap.\nalign_dendro(k = 3L) adds a dendrogram to the annotation and sets itself as the active plot in the annotation stack.\ngeom_point(aes(color = branch)) is then added to this active plot within the annotation stack, here, it means the align_dendro() plot.\n\nggheatmap() aligns discrete variable both horizontally and vertically, so it’s safe to always use quad_anno() directly, as all annotations require a matrix, and the layout data is also a matrix. However, for quad_layout(xlim = NULL) and quad_layout(ylim = NULL) (which I’ll discuss in more detail in a Chapter 7), which only align discrete variable in one direction, the data in the layout may not fit the data for the annotation.\n- `quad_layout(xlim = NULL)`: aligning discrete variable in horizontal\ndirection, for column annotations, we ll need a data frame for\n`stack_continuous()`.\n- `quad_layout(ylim = NULL)`: aligning discrete variable in vertical\ndirection, for row annotations, we ll need a data frame for\n`stack_continuous()`.\nIn both cases, quad_anno() won’t initialize the annotation by default, instead, you must provide the annotation manually.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "href": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "title": "3  heatmap layout",
    "section": "3.5 Adding stack layout",
    "text": "3.5 Adding stack layout\nTo add a stack_layout() to the ggheatmap(), we must prevent the automatic creation of annotations by quad_anno() by setting initialize = FALSE.\n\nmy_stack &lt;- stack_discreteh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote when aligning the discrete variable, you must ensure the number of observations is consistent in the direction. So for column annotations, you need transpose the data manually.\n\nmy_stack &lt;- stack_discretev(t(small_mat)) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    anno_top(initialize = FALSE) +\n    my_stack\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_active",
    "href": "heatmap-layout.html#quad_active",
    "title": "3  heatmap layout",
    "section": "3.6 quad_active()",
    "text": "3.6 quad_active()\nTo remove the active context and redirect additions back to the heatmap body, you can use quad_active().\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_active() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_switchhmanno",
    "href": "heatmap-layout.html#quad_switchhmanno",
    "title": "3  heatmap layout",
    "section": "3.7 quad_switch()/hmanno()",
    "text": "3.7 quad_switch()/hmanno()\nWe also provide quad_switch()/hmanno() (heatmap annotation) which integrates quad_active() and quad_anno() into one function for ease of use. Feel free to use any of these functions to streamline your annotation process.\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    quad_switch(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_switch() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c() +\n    layout_title(\"quad_switch()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    hmanno(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    hmanno() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()+\n    layout_title(\"hmanno()\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#plot-size",
    "href": "heatmap-layout.html#plot-size",
    "title": "3  heatmap layout",
    "section": "3.8 Plot Size",
    "text": "3.8 Plot Size\n\n3.8.1 Heatmap Body Size\nYou can specify the relative sizes of the heatmap body using the width and height arguments in the ggheatmap() function.\n\nggheatmap(small_mat, height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAlternatively, the quad_active() function allows you to control the heatmap body sizes.\n\nggheatmap(small_mat) +\n    quad_active(height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n3.8.2 Annotation Stack Size\nThe quad_anno() function allows you to control the total annotation stack size. The size argument controls the relative width (for left and right annotations) or height (for top and bottom annotations) of the whole annotation stack.\n\nggheatmap(small_mat) +\n    anno_top(size = 1) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also specify it as an absolute size using unit():\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that the size of an individual plot (Section 2.4) does not affect the total annotation stack size. You must adjust the annotation size using the method described above.\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(size = unit(30, \"mm\")) +\n    layout_title(\"plot size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    layout_title(\"annotation size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nIn this chapter, we explored the usage of heatmap layout. These features provide a strong foundation for visualizing matrix-based data in a structured way. However, as your visualization needs grow more complex, the ability to further customize and fine-tune the layout becomes essential.\nIn the next chapter, we will dive into the Layout Customize functionalities, where you can gain full control over your plot’s layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "layout-customize.html",
    "href": "layout-customize.html",
    "title": "4  Layout customize",
    "section": "",
    "text": "4.1 align_group()\nFor layouts that can align observations, the package provides a suite of align_* functions designed to give you precise control over the observations. These functions allow you to reorder observations or partition them into multiple groups.\nCurrently, there are four key align_* functions available for layout customization:\nNote that these functions do not add plot areas and set the active context, meaning you cannot incorporate ggplot2 elements directly into these objects. You can inspect the behavior of any align_* function by printing it.\nThe align_group() function allows you to split the observations into groups.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\nNote that all align_* functions which split observations into groups must not break the previous established groups. This means the new groups must nest in the old groups, usually they cannot be used if groups already exist.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE)) +\n    align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n#&gt; Error in `setup_design()`:\n#&gt; ! `align_group()` disrupt the previously established panel groups of the\n#&gt;   top annotation `stack_discrete()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_kmeans",
    "href": "layout-customize.html#align_kmeans",
    "title": "4  Layout customize",
    "section": "4.2 align_kmeans()",
    "text": "4.2 align_kmeans()\nThe align_kmeans() function split the observations into groups based on k-means clustering.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_order",
    "href": "layout-customize.html#align_order",
    "title": "4  Layout customize",
    "section": "4.3 align_order()",
    "text": "4.3 align_order()\nThe align_order() function reorder the observations based on the summary weights.\nIn this example, we order the rows based on their means. By default, the ordering is in ascending order according to the summary weights. You can reverse the order by setting reverse = TRUE.\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans) +\n    layout_title(title = \"reverse = FALSE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans, reverse = TRUE) +\n    layout_title(title = \"reverse = TRUE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nAdditionally, you can provide the ordering integer index or character index directly:\n\nset.seed(1234)\nmy_order &lt;- sample(nrow(small_mat))\nprint(rownames(small_mat)[my_order])\n#&gt; [1] \"row4\" \"row2\" \"row5\" \"row7\" \"row3\" \"row1\" \"row6\"\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(my_order)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rownames(small_mat)[my_order])\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nSome align_* functions also accept a data argument. It’s important to note that all align_* functions treat rows as the observations. This means NROW(data) must match the number of observations along the axis used for alignment. The data argument can also accept a function (supporting purrr-like lambda syntax), which will be applied to the layout matrix.\nAs mentioned in Section 3.4, for top and bottom annotations, the data matrix of quad_layout()/ggheatmap() is transposed to create the annotation stack_layout(). Therefore, you can use rowMeans() to calculate the mean value across all columns.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSome align_* functions that reorder observations include an argument called strict. This argument is especially useful when previous groups have already been established. If previous groups have been created and strict = FALSE, the function will reorder the observations within each group.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))+\n    align_order(rowMeans, strict = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that we always prevent reordering the observations into two different orderings. If you want to apply two different orderings, you should use cross_layout() instead, which I’ll introduce in a later chapter:\n\nset.seed(1234)\nanother_order &lt;- sample(ncol(small_mat))\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans) +\n    align_order(another_order)\n#&gt; Error in `setup_design()`:\n#&gt; ! `align_order()` disrupt the previously established ordering index of\n#&gt;   the top annotation `stack_discrete()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#sec-align_hclust",
    "href": "layout-customize.html#sec-align_hclust",
    "title": "4  Layout customize",
    "section": "4.4 align_hclust()",
    "text": "4.4 align_hclust()\nThe align_hclust() function is designed to reorder observations and group them based on hierarchical clustering. Unlike align_dendro(), align_hclust() does not add a dendrogram tree to the plot. All the arguments intruduced here can also be used by align_dendro().\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nHierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. You can use the distance and method argument to control the builind process.\nThere are two ways to specify distance metric for clustering:\n\nspecify distance as a pre-defined option. The valid values are the supported methods in dist() function and coorelation coefficient \"pearson\", \"spearman\" and \"kendall\". The correlation distance is defined as 1 - cor(x, y, method = distance).\na self-defined function which calculates distance from a matrix.\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = \"pearson\") +\n    layout_title(\"pre-defined distance method (1 - pearson)\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = function(m) dist(m)) +\n    layout_title(\"a function that calculates distance matrix\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method. Possible methods are those supported in hclust() function. And you can also provide a self-defined function, which accepts the distance object and return a hclust object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(method = \"ward.D2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can specify k or h to split observations into groups, which work similarly to cutree():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can reorder the dendrogram based on the mean values of the observations by setting reorder_dendrogram = TRUE.\n\nh1 &lt;- ggheatmap(small_mat) +\n    ggtitle(\"reorder_dendrogram = TRUE\") +\n    anno_top() +\n    align_hclust(k = 3, reorder_dendrogram = TRUE)\nh2 &lt;- ggheatmap(small_mat) +\n    ggtitle(\"reorder_dendrogram = FALSE\") +\n    anno_top() +\n    align_hclust(k = 3)\nalign_plots(h1, h2)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this example, we use align_plots() to arrange the layouts, which functions similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, unlike those, align_plots() can be directly used with quad_layout() and stack_layout(), ensuring proper alignment by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, though they won’t align by panel area in the same way as ggplot2 plots.\nalign_hclust() can also perform clustering between groups, meaning it can be used even if there are existing groups present in the layout, in this way, you cannot specify k or h:\n\nset.seed(3L)\ncolumn_groups &lt;- sample(letters[1:3], ncol(small_mat), replace = TRUE)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can reorder the groups by setting reorder_group = TRUE, which reorders the hierarchical clusters based on the group tree:\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(reorder_group = TRUE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIf you specify k or h, this will always turn off sub-clustering. The same principle applies to align_hclust(), where new groups must be nested within the previously established groups.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(k = 2L)\n#&gt; Error in `setup_design()`:\n#&gt; ! `align_hclust()` disrupt the previously established panel groups of\n#&gt;   the top annotation `stack_discrete()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_reorder",
    "href": "layout-customize.html#align_reorder",
    "title": "4  Layout customize",
    "section": "4.5 align_reorder()",
    "text": "4.5 align_reorder()\nThe align_reorder() function enables the reordering of observations based on a specified statistical function. This function accepts a data argument and computes a statistic that determines the new ordering of the observations. The resulting order is extracted using the order2() function.\nFoe example, you can also use hierarchical clustering to reorder the observations like this:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_reorder(hclust2)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nHere, hclust2() is a special function used by align_hclust() to calculate the distance matrix and perform hierarchical clustering.\nIn addition to hierarchical clustering, the align_reorder() function can also handle objects from the seriation package. For example, you can use the seriate() function with a method like \"BEA_TSP\" to reorder the observations based on a specific seriation algorithm:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\", data = abs)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThis approach gives you the flexibility to apply different statistical or algorithmic methods for reordering observations, which can be especially useful for exploring complex patterns in data.\nWith the align_* functions in place, we’ve covered how to reorder and group observations within a layout. Now, having set the stage for proper observation alignment, we can move on to the next essential step: plot initialize. In the following chapter, we’ll dive deeper into how to set up your plots within the layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html",
    "href": "plot-initialize.html",
    "title": "5  Plot initialize",
    "section": "",
    "text": "5.1 ggalign()\nThere are following primary functions for adding plots:\nAll these functions will set the active plot when added to the layout.\nBoth ggmark() and align_dendro() can only for discrete variables.\nggalign is the package name but it’s also a function in the package. ggalign() is similar to ggplot in that it initializes a ggplot data and mapping. ggalign() allowing you to provide data in various formats, including matrices, data frames, or simple vectors. By default, it will inherit from the layout. If a function, it will apply with the layout data.\nThe underlying plot data will be created using fortify_data_frame(), which, By default, calls ggplot2::fortify() to build the data frame. Additional methods have been added for atomic vector and matrix. For atomic vector, it will convert it to a data frame with following columns:\nWhen data is a matrix, it will automatically be transformed into a long-form data frame, where each row represents a unique combination of matrix indices and their corresponding values. The resulting data frame will contain the following columns:\nWhen alignning continuous variables, ggalign() will apply the limits set by the layout when drawing.\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = rowSums) +\n    geom_point(aes(y = value))\n#&gt; → heatmap built with `geom_tile()`\nWhen aligning discrete variables, ggalign() always applies a default mapping for the axis of the data index in the layout. Specifically, This mapping is aes(y = .data$.y) for horizontal stack (including left and right annotation) and aes(x = .data$.x) for vertical stack (including top and bottom annotation).\nThe following columns will be added to the data frame to align discrete variables:\nWhen aligning discrete variables, almost all functions that add plots will generate data containing two key columns:\nAdditionally, if names exist, the .names column will also be created.\nstack_continuous(\"v\", mtcars, limits = continuous_limits(c(2, 4))) +\n    ggalign(mapping = aes(wt, mpg)) +\n    geom_point() +\n    ggalign(mapping = aes(wt, mpg)) +\n    geom_point() +\n    theme(axis.text.x = element_text())\nWhen aligning discrete variables, ensure that the number of rows in the data matches the number of observations along the axis used for alignment:\nmy_df &lt;- mtcars[seq_len(ncol(small_mat)), ]\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = my_df) +\n    geom_point(aes(y = cyl))\n#&gt; → heatmap built with `geom_tile()`\nIf data = NULL, the data in the underlying ggplot object only contains following columns: .panel, .index, .names, .x/.y, .discrete_x/.discrete_y. You can use it to integrate additional elements, such as block annotation or customized panel title, into your layout.\nggheatmap(small_mat) +\n    anno_top(size = unit(1, \"cm\")) +\n    align_kmeans(centers = 3L) +\n    ggalign(data = NULL) +\n    geom_tile(aes(y = 1L, fill = .panel, color = .panel)) +\n    theme_no_axes(\"y\")\n#&gt; → heatmap built with `geom_tile()`\nThe function theme_no_axes() can be used to quickly remove axis text and titles from the plot.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#sec-ggalign",
    "href": "plot-initialize.html#sec-ggalign",
    "title": "5  Plot initialize",
    "section": "",
    "text": ".names: the names for the vector (only applicable if names exist).\nvalue: the actual value of the vector.\n\n\n\n.row_names and .row_index: the row names (only applicable when names exist) and an integer representing the row index of the original matrix.\n.column_names and .column_index: the column names (only applicable when names exist) and column index of the original matrix.\nvalue: the actual value.\n\n\n\n\n\n\n.panel: The panel for the aligned axis. Refers to the x-axis for vertical stack_layout() (including top and bottom annotations), and the y-axis for horizontal stack_layout() (including left and right annotations).\n.names ([vec_names()][vctrs::vec_names]) and .index ([vec_size()][vctrs::vec_size()]/[NROW()]): Character names (if available) and the integer index of the original data.\n.x/.y and .discrete_x/.discrete_y: Integer indices for x/y coordinates, and a factor of the data labels (only applicable when names exist).\n\n\nIt is recommended to use .x/.y, or .discrete_x/.discrete_y as the x/y mapping.\n\n\n\n.panel: used to create ggplot2 facets.\n.index: serves to match the data. It is useful for aligning observations or linking different data sources. You can use .index to merge data and create a new data frame, using method provided in Section 11.2.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#ggfree",
    "href": "plot-initialize.html#ggfree",
    "title": "5  Plot initialize",
    "section": "5.2 ggfree()",
    "text": "5.2 ggfree()\nThe ggfree() function allows you to incorporate a ggplot object into your layout. Unlike ggalign(), which aligns every axis value precisely, ggfree() focuses on layout integration without enforcing strict axis alignment.\nInternally, the function also uses fortify_data_frame() to transform the input into a data frame.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSince ggfree() may use axes that are not aligned with the primary plot’s axes, the axis titles will not be removed automatically. If you want to remove the axis titles, you must do so manually.\nAlternatively, you can directly input the ggplot object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(ggplot(mtcars, aes(wt, mpg))) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also add the ggplot object directly without using ggfree(). However, doing so will limit control over the plot (like plot area size, and active components):\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggplot(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n5.2.1 Cross panel sumamry\nWhen used in quad_layout()/ggheatmap(), if the data is inherited from the quad_layout() and the other direction aligns discrete variables, following columns will be added:\n\n.extra_panel: Provides the panel information for the column (left or right annotation) or row (top or bottom annotation).\n.extra_index: The index information for the column (left or right annotation) or row (top or bottom annotation).\n\nThis is useful if you want to create summary plot using another axis panel groups.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n\n    # in the right annotation\n    anno_right() +\n    align_kmeans(2) +\n\n    # in the top annotation\n    anno_top(size = 0.5) +\n    ggfree() +\n    geom_boxplot(aes(.extra_panel, value, fill = .extra_panel)) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"row groups\") +\n    theme_no_axes(\"x\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThis approach replicates the functionality of ComplexHeatmap::anno_summary(), but is versatile enough to be used with any heatmap, not just single-column or single-row heatmaps.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#ggwrap-and-inset",
    "href": "plot-initialize.html#ggwrap-and-inset",
    "title": "5  Plot initialize",
    "section": "5.3 ggwrap() and inset()",
    "text": "5.3 ggwrap() and inset()\nThe ggwrap() function allows you to wrap objects that can be converted into a grob, turning them into a ggplot for plotting. Further you can still add ggplot elements like title, subtitle, tag, caption, and geoms using the same approach as with normal ggplots (using ggtitle(), labs(), geom_*()) as well as styling using theme(). This enables you to pass these wrapped objects into ggfree().\n\nlibrary(grid)\nggheatmap(small_mat) +\n    anno_top() +\n    # `ggwrap()` will create a `ggplot` object, we use `ggfree` to add it into the layout\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also integrate base plots, pheatmap, ComplexHeatmap, e.g.\nAdditionally, you can add any graphics as a inset to a ggplot using the inset() function. Like ggwrap(), inset() can accept any object that can be converted to a grob.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\")) +\n    # we can then add any inset grobs (the same as ggwrap, it can take any objects\n    # which can be converted to a `grob`)\n    inset(rectGrob(gp = gpar(fill = \"steelblue\")), align = \"panel\") +\n    inset(textGrob(\"Here are some text\", gp = gpar(color = \"black\")),\n        align = \"panel\"\n    )\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#sec-align-dendro",
    "href": "plot-initialize.html#sec-align-dendro",
    "title": "5  Plot initialize",
    "section": "5.4 align_dendro()",
    "text": "5.4 align_dendro()\nalign_dendro() is an extension of align_hclust() that adds a dendrogram to the layout. All functions of align_hclust() introduced in Section 4.4 can be used with align_dendro(). Here, we focus on the plot-related function.\nalign_dendro() will initialize a ggplot object, the data underlying the ggplot object contains the dendrogram node data with dendrogram edge data attached in a special attribute.\ndendrogram node and edge contains following columns:\n\n.panel: Tree branch groups, used to create ggplot2 facet.\n.names and .index: a character names (only applicable when names exists) and an integer index of the original data.\nlabel: node label text\nx and y: x-axis and y-axis coordinates for current node or the start node of the current edge.\nxend and yend: the x-axis and y-axis coordinates of the terminal node for current edge.\nbranch: which branch current node or edge is. You can use this column to color different groups.\nleaf: A logical value indicates whether current node is a leaf.\n\nBy default, plot_dendrogram is set to TRUE, meaning a geom_segment() layer will be added using the dendrogram edge data when drawing. Note that this layer is always added to the first.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can choose between two dendrogram types: \"rectangle\" (default) and \"triangle\". However, if there are any groups in the stack, \"rectangle\" will be used.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(type = \"triangle\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also manually add the dendrogram tree using the edge data by setting plot_dendrogram = FALSE. In this case, you can access the dendrogram edge data with ggalign_attr(). The edge data is stored in the edge field of ggalign_attr():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(plot_dendrogram = FALSE) +\n    geom_segment(\n        aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend),\n        data = function(x) ggalign_attr(x, \"edge\")\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen there are multiple groups, a branch column will be available. This can be used to color the nodes or edges based on the group source.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nalign_dendro() will draw dendrogram tree in each group when previous group exists.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can merge the sub-tree by settting merge_dendrogram = TRUE.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch), merge_dendrogram = TRUE)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#plot-titles",
    "href": "plot-initialize.html#plot-titles",
    "title": "5  Plot initialize",
    "section": "5.5 Plot titles",
    "text": "5.5 Plot titles\nggplot2 only allow add titles in the top or add caption in the bottom. we extends this capability, allowing you to place titles around any border of the plot using the patch_titles() function.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe appearance and alignment of these patch titles can be customized using ggplot2::theme():\n\nplot.patch_title/plot.patch_title.*: Controls the text appearance of patch titles. By default, plot.patch_title inherit from plot.title, and settings for each border will inherit from plot.patch_title, with the exception of the angle property, which is not inherited.\nplot.patch_title.position/plot.patch_title.position.*: Determines the alignment of the patch titles. By default, plot.patch_title.position inherit from plot.title.position, and settings for each border will inherit from plot.patch_title. The value \"panel\" aligns the patch titles with the plot panels. Setting this to \"plot\" aligns the patch title with the entire plot (excluding margins and plot tags).\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    ) +\n    theme(\n        plot.patch_title.position = \"plot\",\n        plot.patch_title = element_text(hjust = 0)\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNow that you know the general approach to adding a plot, it would be useful to explore how to add annotation plots for specific observations. Let’s move on to the next chapter.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "annotate-observations.html",
    "href": "annotate-observations.html",
    "title": "6  Annotate observations",
    "section": "",
    "text": "6.1 Links\nTo add an annotation plot for specific observations, we must first know how to select the observations to be linked.\nThe pair_links() function is used to define pairs of connected observations. In the formula, the left side (before the ~) represents hand1—the observations on the left (for a horizontal stack layout) or top (for a vertical stack layout). The right side (after the ~) represents hand2—the observations on the right (for horizontal stack) or bottom (for vertical stack).\nThese defined pairs will either be linked together, or each group in the pair will be linked separately within the same plot area.\nBoth sides of the formula can be specified using integer or character indices of the original data (before reordering).\npair_links(1:2 ~ c(\"c\", \"d\"), c(\"a\", \"b\") ~ 3:4)\n#&gt; &lt;ggalign_pair_links[2]&gt;\n#&gt; \n#&gt;             hand1 ~ hand2      \n#&gt;   1:          1:2 ~ c(\"c\", \"d\")\n#&gt;   2:  c(\"a\", \"b\") ~ 3:4        \n#&gt; \n#&gt; A total of 4 groups\nThe print method showed various informations:\nIf only the left-hand side of the formula exists, you can input it directly.\npair_links(1:2, c(\"a\", \"b\"))\n#&gt; &lt;ggalign_pair_links[2]&gt;\n#&gt; \n#&gt;             hand1 ~ hand2\n#&gt;   1:          1:2 ~      \n#&gt;   2:  c(\"a\", \"b\") ~      \n#&gt; \n#&gt; A total of 2 groups\nTo specify links in the right only, you must use formula:\npair_links(~ 1:2, ~ c(\"a\", \"b\"))\n#&gt; &lt;ggalign_pair_links[2]&gt;\n#&gt; \n#&gt;       hand1 ~ hand2      \n#&gt;   1:        ~ 1:2        \n#&gt;   2:        ~ c(\"a\", \"b\")\n#&gt; \n#&gt; A total of 2 groups\nFor integer indices, wrap them with I() to follow ordering from the layout.\npair_links(I(1:2))\n#&gt; &lt;ggalign_pair_links[1]&gt;\n#&gt; \n#&gt;        hand1 ~ hand2\n#&gt;   1:  I(1:2) ~      \n#&gt; \n#&gt; A total of 1 group\nYou can wrap the whole formula.\npair_links(I(1:2 ~ 3:4))\n#&gt; &lt;ggalign_pair_links[1]&gt;\n#&gt; \n#&gt;        hand1 ~ hand2 \n#&gt;   1:  I(1:2) ~ I(3:4)\n#&gt; \n#&gt; A total of 2 groups\nrange_link() function can be used to define a range of observations, which accepts two argument that specify the lower and upper bounds of the range. These bounds should be defined as a single integer or character.\npair_links(range_link(1, \"a\"))\n#&gt; &lt;ggalign_pair_links[1]&gt;\n#&gt; \n#&gt;                    hand1 ~ hand2\n#&gt;   1:  range_link(1, \"a\") ~      \n#&gt; \n#&gt; A total of 1 group\nIn this case, the left-hand is defined as the range between the 1st observation and the observation named \"a\".\nYou can also use waiver() to inherit values from the opposite group.\n1pair_links(range_link(1, \"a\") ~ waiver())\n#&gt; &lt;ggalign_pair_links[1]&gt;\n#&gt; \n#&gt;                    hand1 ~ hand2   \n#&gt;   1:  range_link(1, \"a\") ~ waiver()\n#&gt; \n#&gt; A total of 2 groups\n\n\n1\n\ninherit values from the left hand\n1pair_links(waiver() ~ range_link(1, \"a\"))\n#&gt; &lt;ggalign_pair_links[1]&gt;\n#&gt; \n#&gt;          hand1 ~ hand2             \n#&gt;   1:  waiver() ~ range_link(1, \"a\")\n#&gt; \n#&gt; A total of 2 groups\n\n\n1\n\ninherit values from the right hand\nYou can combine any of these into a list.\npair_links(list(range_link(1, \"a\"), waiver()) ~ list(4:5, c(\"b\", \"c\")))\n#&gt; &lt;ggalign_pair_links[1]&gt;\n#&gt; \n#&gt;                                    hand1 ~ hand2                 \n#&gt;   1:  list(range_link(1, \"a\"), waiver()) ~ list(4:5, c(\"b\", \"c\"))\n#&gt; \n#&gt; A total of 2 groups\nIn this example, the left side combines the range between the 1st observation and “a” with the observations 4 and 5, and the observations “b” and “c”.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Annotate observations</span>"
    ]
  },
  {
    "objectID": "annotate-observations.html#links",
    "href": "annotate-observations.html#links",
    "title": "6  Annotate observations",
    "section": "",
    "text": "The object class and the number of paired groups.\nThe specific groups in each pair.\nThe total number of groups (rather than the number of paired groups). For example, in this case, there are 4 groups in total since each pair consists of 2 groups.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Annotate observations</span>"
    ]
  },
  {
    "objectID": "annotate-observations.html#ggmark",
    "href": "annotate-observations.html#ggmark",
    "title": "6  Annotate observations",
    "section": "6.2 ggmark()",
    "text": "6.2 ggmark()\nggmark() can be used to add annotation plot for the selected observations. ggmark accepts mark argument, which should be a mark_draw() object to define how to draw the links. Currently, two internal functions mark_line(), mark_tetragon() can be used to quickly draw line and quadrilateral links used to connect the selected observations and the plot panel.\nBy default, when no manual observations were selected, ggmark() will select all observations and split them based on the groups defined in the layout.\nThe data underlying the ggplot object generated by ggmark() is similar to that of ggalign() (Section 5.1), but it differs in that it does not include the .x, .y, and .discrete_x/.discrete_y columns. Instead, a special column named .hand is added, which is a factor with levels c(\"left\", \"right\") for horizontal stack layouts or c(\"top\", \"bottom\") for vertical stack layouts. This column indicates the position of the linked observations.\n\nNote: Only data for selected observations are retained.\n\nYou can adjust the link size by using the plot.margin argument.\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_line()) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_tetragon()) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nIf you manually provide the linked observations, you can use the group1 and group2 arguments to control whether the layout panel groups and their ordering should be used to create the annotations.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_tetragon(1:3), group1 = TRUE) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, ggmark() uses facet_wrap to define the facet, and you can use it to control the facet apearance (just ignore the facets argument). We prefer facet_wrap() here because it offers flexibility in positioning the strip on any side of the panel, and typically, we only want to a single dimension to create the annotate the selected observations. However, you can still use facet_grid() to create a two-dimensional plot. Note that for horizontal stack layouts, the row facets, or for vertical stack layouts, the column facets will always be overwritten.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_line()) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can further customize the appearance of link lines and quadrilaterals using the element argument in mark_line()/mark_tetragon() function:\n\nLink lines can be customized using the element_line().\nLink ranges can be customized using the element_polygon().\n\nBy default, vectorized fields in element_line() and element_polygon() will be recycled to match the total number of groups.\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_line(4:6, 1:2, \n            .element =  element_line(color = c(\"red\", \"blue\"))\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_tetragon(4:6, 1:2, \n            .element =  element_polygon(fill = c(\"red\", \"blue\"), alpha = 0.5)\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nYou can wrap the element with I() to recycle it to match the drawing groups. The drawing groups typically correspond to the number of observations for element_line(), as each observation will be linked with the plot panel.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_line(4:6, 1:2, \n            .element =  I(element_line(color = c(\"red\", \"blue\")))\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFor element_polygon(), the drawing groups usually align with the defined groups. However, if the defined group of observations is separated and cannot be linked with a single quadrilateral, the number of drawing groups will be larger than the number of defined groups.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_tetragon(4:6, 1:2, \n            .element =  I(element_polygon(fill = c(\"red\", \"blue\"), alpha = 0.5))\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFor stack_layout(), we usually don’t need to specify the observations for hand2, since it should match hand1. This is because all plots in stack_discrete() should maintain the same ordering index. However, specifying hand2 becomes useful in stack_cross(), where different orderings are involved.\n\nstack_discreteh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_x_reverse(expand = expansion()) +\n    theme(plot.margin = margin()) +\n    ggmark(mark_line(4:6 ~ waiver(), 1:2 ~ waiver())) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, r = 0.1, b = 0.1, unit = \"npc\")) +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_x_continuous(expand = expansion()) +\n    theme(plot.margin = margin())\n\n\n\n\n\n\n\n\nNow, let’s move on to the next chapter, where we will introduce quad_layout() in full. While we’ve already introduced ggheatmap()—a specialized version of quad_layout()—most of the operations discussed in Chapter 3 can also be applied to quad_layout(). In the next section, we’ll delve into quad_layout() and explore its full functionality.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Annotate observations</span>"
    ]
  },
  {
    "objectID": "quad-layout.html",
    "href": "quad-layout.html",
    "title": "7  quad-layout",
    "section": "",
    "text": "7.1 Introduction\nquad_layout() arranges plots around the quad-sides of a main plot, aligning both horizontal and vertical axes, and can handle either discrete or continuous variables.\nDepending on whether you want to align discrete or continuous variables in the horizontal and vertical direction, there are four main types of quad_layout():",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#introduction",
    "href": "quad-layout.html#introduction",
    "title": "7  quad-layout",
    "section": "",
    "text": "Alignment of Observations\nhorizontal\nvertical\nData Format\n\n\n\n\nquad_continuous()/ggside()\ncontinuous\ncontinuous\ndata frame\n\n\nquad_layout(xlim = ...)\ndiscrete\ncontinuous\nmatrix\n\n\nquad_layout(ylim = ...)\ncontinuous\ndiscrete\nmatrix\n\n\nquad_discrete()/ggheatmap()\ndiscrete\ndiscrete\nmatrix",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#annotations",
    "href": "quad-layout.html#annotations",
    "title": "7  quad-layout",
    "section": "7.2 Annotations",
    "text": "7.2 Annotations\nAnnotation is typically handled using a stack_layout(). Depending on whether you want to align observations in the specified direction, different stack_layout() are compatible (Section 3.5). Below is a table outlining the compatibility of various layout types for annotations:\n\n\n\n\n\n\n\n\nAnnotations\nleft and right\ntop and bottom\n\n\n\n\nquad_continuous()/ggside()\nstack_continuous()\nstack_continuous()\n\n\nquad_layout(xlim = ...)\nstack_discrete()\nstack_continuous()\n\n\nquad_layout(ylim = ...)\nstack_continuous()\nstack_discrete()\n\n\nquad_discrete()/ggheatmap()\nstack_discrete()\nstack_discrete()",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_discrete",
    "href": "quad-layout.html#quad_discrete",
    "title": "7  quad-layout",
    "section": "7.3 quad_discrete()",
    "text": "7.3 quad_discrete()\nquad_discrete() aligns discrete variables in both horizontal and vertical directions. It serves as the base version of ggheatmap()/heatmap_layout() and does not automatically add default layers or mappings.\nThe underlying ggplot data of the main plot is the same with ggheatmap()/heatmap_layout() (Section 3.2), it is recommended to use .y, or .discrete_y as the y mapping and use .x or .discrete_x as the x mapping in the main plot.\n\nquad_discrete(small_mat, aes(.x, .y)) +\n    geom_tile(aes(fill = value)) +\n    scale_fill_viridis_c()",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_continuous",
    "href": "quad-layout.html#quad_continuous",
    "title": "7  quad-layout",
    "section": "7.4 quad_continuous()",
    "text": "7.4 quad_continuous()\nquad_continuous() align continuous variables and is functionally equivalent to the ggside package. For convenience, ggside() is provided as an alias for quad_continuous(). This layout is particularly useful for adding metadata or summary graphics along a continuous axis.\n\nggside(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    # initialize top annotation\n    anno_top(size = 0.3) +\n    # add a plot in the top annotation\n    ggalign() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    # initialize right annotation\n    anno_right(size = 0.3) +\n    # add a plot in the right annotation\n    ggalign() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    ) &\n    theme_bw()\n\n\n\n\n\n\n\n\nggside() allows facetting for the main plot, which should also be applied to the annotations for proper alignment.\n\ni2 &lt;- iris\ni2$Species2 &lt;- rep(c(\"A\", \"B\"), 75)\nggside(i2, aes(Sepal.Width, Sepal.Length, color = Species)) +\n    geom_point(size = 2) +\n    facet_grid(Species ~ Species2) +\n    anno_top(size = 0.3) +\n    ggalign() +\n    geom_density(aes(Sepal.Width, y = after_stat(density), colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(cols = vars(Species2)) +\n    anno_right(size = 0.3) +\n    ggalign() +\n    geom_density(aes(x = after_stat(density), Sepal.Length, colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(rows = vars(Species)) &\n    theme_bw()\n\n\n\n\n\n\n\n\nIf an annotation contains multiple plots, it can be tedious to add the same element to each one individually. One way to simplify this is by creating an external stack_layout() and adding the desired elements using the & operator. Then, you can add this stack_layout() to the quad_layout(). In Chapter 10, I will introduce another more powerful operator that seamlessly combines with the + operator, allowing you to add elements to multiple plots at once.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#sec-quad-layout-quad-layout",
    "href": "quad-layout.html#sec-quad-layout-quad-layout",
    "title": "7  quad-layout",
    "section": "7.5 quad_layout()",
    "text": "7.5 quad_layout()\nThis function arranges plots around the quad-sides of a main plot, aligning both horizontal and vertical axes, and can handle either discrete or continuous variables.\n\nIf xlim is provided, a continuous variable will be required and aligned in the vertical direction. Otherwise, a discrete variable will be required and aligned.\nIf ylim is provided, a continuous variable will be required and aligned in the horizontal direction. Otherwise, a discrete variable will be required and aligned.\n\n\n\n\nquad_layout(small_mat, xlim = NULL) +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_layout(xlim = ...)\")\n\n\n\n\n\n\n\n\n\n\n\nquad_layout(small_mat, ylim = NULL) +\n    geom_boxplot(aes(.discrete_x, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_layout(ylim = ...)\")\n\n\n\n\n\n\n\n\n\n\nAs discussed in Section 3.4, quad_anno() will always attempt to initialize a stack_layout() with the same alignment as the current direction. For top and bottom annotations in quad_layout(xlim = ...), and left and right annotations in quad_layout(ylim = NULL), quad_anno() will not initialize the annotation due to inconsistent data types.\n\nquadh &lt;- quad_layout(small_mat, xlim = NULL) +\n    anno_top()\n#&gt; Warning: `data` in `quad_layout()` is a double matrix, but the top annotation stack need\n#&gt; a &lt;data.frame&gt;, won't initialize the top annotation stack\nquadv &lt;- quad_layout(small_mat, ylim = NULL) +\n    anno_left()\n#&gt; Warning: `data` in `quad_layout()` is a double matrix, but the left annotation stack\n#&gt; need a &lt;data.frame&gt;, won't initialize the left annotation stack\n\nManual adding of a stack_layout() is required in such cases, you can set initialize = FALSE to prevent the warning message.\n\nquadh &lt;- quad_layout(small_mat, xlim = NULL) +\n    anno_top(initialize = FALSE)\nquadv &lt;- quad_layout(small_mat, ylim = NULL) +\n    anno_left(initialize = FALSE)\n\n\n\n\nquadh +\n    stack_continuous(\"v\", mpg) +\n    # add a plot in the top annotation\n    ggalign(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquadv +\n    stack_continuous(\"h\", mpg) +\n    # add a plot in the left annotation\n    ggalign(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(.discrete_x, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can set initialize = TRUE, which will initialize the annotation stack layout with no data. In this case, you must provide data in each plot within the annotation.\n\n\n\nquad_layout(small_mat, xlim = NULL) +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_top(initialize = TRUE) +\n    ggalign(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquad_layout(small_mat, ylim = NULL) +\n    geom_boxplot(aes(.discrete_x, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_left(initialize = TRUE) +\n    ggalign(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\n\nIn the next chapter, we will explore even more advanced techniques for combining multiple quad_layout()s. These methods will provide you with the tools to manage more complex plot arrangements and make your visualizations even more flexible and powerful.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html",
    "href": "multiple-quad-layouts.html",
    "title": "8  A list of quad_layout()",
    "section": "",
    "text": "8.1 Add quad_layout() to stack_layout()\nSimilarly, stack_layout() can be added to a quad_layout(), and a quad_layout() can also be added to a stack_layout().\nHere is a summarized table showing which quad_layout() can be used with each stack_layout():\nAs long as the alignment is consistent across both stack_layout() and quad_layout(), you can directly add quad_layout().\nstack_discreteh(small_mat) +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\nWhen ggheatmap()/quad_layout() is added to a stack_layout(), it will also set the active context to itself, which means subsequent addition will be directed to ggheatmap()/quad_layout(). One exception is the ggheatmap()/quad_layout() itself, which cannot be added to another quad_layout(). In this case, they will be added directly to the stack_layout().\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nThe data of ggheatmap()/quad_layout() can inherit from the stack_layout(), but the data format must match. Otherwise, you will need to manually provide the data.\nquad_continuousv_plot &lt;- quad_layout(small_mat, xlim = NULL) +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")\n# `stack_continuous()` need a data frame\nstack_continuousv() +\n    quad_continuousv_plot +\n    quad_continuousv_plot\nWhen ggheatmap()/quad_layout() is added to a vertical stack_layout(), the inherited matrix is transposed before use. This is because the columns of ggheatmap()/quad_layout() must match the number of observations in stack_layout().\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nstack_discrete() ensures that all plots aligned along the stack have the same ordering index or groups.\nWe can customize the layout in the stack_discrete() directly, or in quad_layout(). As introduced in Section 2.5, you can easily switch from the ggheatmap()/quad_layout() to the stack_layout() using stack_active().\nWhen applied to a stack_layout(), the orientation of the dendrogram may need to be manually adjusted.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#add-quad_layout-to-stack_layout",
    "href": "multiple-quad-layouts.html#add-quad_layout-to-stack_layout",
    "title": "8  A list of quad_layout()",
    "section": "",
    "text": "stack_discreteh()\nstack_discretev()\nstack_continuoush()\nstack_continuousv()\n\n\n\n\nquad_continuous()/ggside()\n❌\n❌\n✅\n✅\n\n\nquad_layout(xlim = ...)\n✅\n❌\n❌\n✅\n\n\nquad_layout(ylim = ...)\n❌\n✅\n✅\n❌\n\n\nquad_discrete()/ggheatmap()\n✅\n✅\n❌\n❌\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3)+\n    layout_title(\"dendrogram in ggheatmap()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    stack_active() +\n    align_dendro(aes(color = branch), k = 3, size = 0.2) +\n    scale_y_reverse() +\n    layout_title(\"dendrogram in stack_layout()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#control-sizes",
    "href": "multiple-quad-layouts.html#control-sizes",
    "title": "8  A list of quad_layout()",
    "section": "8.2 Control sizes",
    "text": "8.2 Control sizes\nA numeric or a unit object of length 3 should be provided in stack_discrete()/stack_continuous() when placing a quad_layout(). For vertical stack_layout(), this means quad_layout() with left or right annotations; for horizontal stack_layout(), this means quad_layout() with top or bottom annotations. The first size controls the relative width/height of the left or top annotation, the second controls the relative width/height of the main plot, and the third controls the relative width/height of the right or bottom annotation.\nBy default the three rows/columns will have equal sizes.\n\nstack_discretev(small_mat) +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nheat1 &lt;- ggheatmap(t(small_mat)) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\")\n\nstack_discretev(small_mat, sizes = c(1, 2, 1)) +\n    heat1 +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this way, the width/height of main plot specified in quad_active() or quad_layout()/ggheatmap() won’t work.\n\nstack_discretev(small_mat) +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNow that you’ve learned how to combine quad_layout() and stack_layout() in various configurations, you’re ready to explore a new, exciting way to organize and visualize your data: the circle layout. This layout offers a unique, radial perspective that can be particularly useful for visualizing hierarchical data or creating visually engaging plots.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "circle-layout.html",
    "href": "circle-layout.html",
    "title": "9  circle layout",
    "section": "",
    "text": "9.1 radial\ncircle_layout() arranges plots in a circular, each plot will occupy one circle track. Based on whether we want to align the discrete or continuous variables, there are two types of circle layouts:\nthe core argument of circle_layout() is radial, which should be a coord_radial() object that defines the global parameters for coord_radial() across all plots in the layout. The parameters start, end, direction, and expand will be inherited and applied uniformly to all plots within the layout. The parameters theta and r.axis.inside will always be ignored and will be set to “x” and TRUE, respectively, for all plots.\ncircle_discrete(small_mat, radial = coord_radial(end = pi / 2, expand = FALSE)) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c()\nIn essence, you can think of circle_layout() as a radial version of stack_vertical(). When rendered, circle_layout() uses coord_radial() to arrange each plot along a circular track. The radial argument in circle_layout() controls the overall inner radius. Plots are added from the outermost to the innermost position.\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n    align_dendro()\nThe size of each plot within the circle can be adjusted using the size argument (Section 2.4). However, it’s important to note that circle_layout() only supports relative size adjustments, meaning all size values are interpreted relative to one another, even for unit objects. By default, all plots have a relative size of 1.\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n    align_dendro(size = 0.5)\nAlthough circle_layout() does not currently support splitting observations into different facets, you can still indicate different groups visually. For instance, you can add a tile to represent each group. If you’re using a dendrogram, you can color the branches to indicate different groups.\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n    # add a single tile for each group\n    ggalign(NULL, size = 0.1) +\n    geom_tile(aes(y = 1L, fill = .panel)) +\n    theme_no_axes(\"y\") +\n    scale_fill_brewer(palette = \"Dark2\", guide = \"none\") +\n\n    # add a heatmap\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n\n    # add a dendrogram\n    align_dendro(aes(color = branch), k = 3L, size = 0.5) +\n    scale_color_brewer(palette = \"Dark2\")",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>circle layout</span>"
    ]
  },
  {
    "objectID": "circle-layout.html#spacing",
    "href": "circle-layout.html#spacing",
    "title": "9  circle layout",
    "section": "9.2 spacing",
    "text": "9.2 spacing\nThe spacing between plot tracks in circle_layout() is controlled by the scale expansion and the panel.spacing.r parameter. The panel.spacing.r parameter sets the spacing between the individual plot panels (tracks) within the circle layout. Increasing this value will add more space between the tracks. Specifically, the panel.spacing.r of the outer plot determines the spacing between it and the inner plot. By modifying this value, you can control the overall visual separation between tracks.\n\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n    # add a single tile for each group\n    ggalign(NULL, size = 0.1) +\n    geom_tile(aes(y = 1L, fill = .panel)) +\n    scale_fill_brewer(palette = \"Dark2\", guide = \"none\") +\n    no_expansion(\"y\") +\n    theme(panel.spacing.r = unit(0, \"mm\")) +\n\n    # add a heatmap\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n    no_expansion(\"y\") +\n    theme(panel.spacing.r = unit(0, \"mm\")) +\n\n    # add a dendrogram\n    align_dendro(aes(color = branch), k = 3L, size = 0.5) +\n    no_expansion(\"y\") +\n    scale_color_brewer(palette = \"Dark2\")\n\n\n\n\n\n\n\n\nThe no_expansion() function is used to remove expansion around specific borders. It accepts a string with one or more of the following values: \"t\" (top), \"l\" (left), \"b\" (bottom), \"r\" (right), \"x\" (both left and right), and \"y\" (both bottom and top).\nNow we have explored all the Layout defined in the package, next, we will build on these concepts and explore even more advanced strategies for integrating elements across multiple plots or annotations in a layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>circle layout</span>"
    ]
  },
  {
    "objectID": "operator.html",
    "href": "operator.html",
    "title": "10  Operators",
    "section": "",
    "text": "10.1 Addition operator\nIn ggalign, operators are used to manage and manipulate the plot elements in various layouts. These operators help you build complex visualizations by adding, or modifying elements across multiple plots in a layout. You may be familiar with the + and & operators, this section will expand on their usage, as well as introduce the subtraction operator (-) and how to apply it in different contexts.\nThe + operator is straightforward and should be used as needed.\nIn stack_layout(), a nested layout will only occur if you pass a quad_layout() into stack_layout() (Chapter 8). If the active context in the stack_layout() is quad_layout(), this quad_layout() is treated as the active layout, and the + operator will add elements to it, following the same principles as in quad_layout(). Otherwise, the stack_layout() itself is treated as the active layout, and the + operator will add elements directly to this plot.\ncircle_layout() works similarly to stack_layout(), but it does not support nested layouts. Therefore, the active layout in circle_layout() will always be the circle_layout() itself.\nstack_alignh(small_mat) +\n    align_dendro() +\n    geom_point() +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\nIn quad_layout(), four nested layouts are available for annotations: top, left, bottom, and right. If no active annotation is set, quad_layout() treat itself as the active layout. Since there is only one main plot in the quad_layout(), the main plot is always treated as the active plot in this context. Otherwise, the active annotation is treated as the active layout, and the + operator will add elements to it, following the same principles as in stack_layout().\nggheatmap(small_mat) +\n    scale_fill_viridis_c() +\n    anno_left(size = 0.2) +\n    align_dendro() +\n    anno_right(size = 0.2) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#addition-operator",
    "href": "operator.html#addition-operator",
    "title": "10  Operators",
    "section": "",
    "text": "+: adds elements to the active plot in the active layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#logical-and-operator",
    "href": "operator.html#logical-and-operator",
    "title": "10  Operators",
    "section": "10.2 logical AND operator",
    "text": "10.2 logical AND operator\n\n&: applies elements to all plots in the layout including plots in the nested layout.\n\nThe & operator works similarly to patchwork, applying an element across all plots in a layout. Since & has lower precedence than +, it’s generally best to use it at the end of an expression or you should wrap it in parentheses when needed.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    # Add a dendrogram in the left annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    # Add a dendrogram in the right annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) &\n    # Set color scale for all plots\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#subtraction-operator",
    "href": "operator.html#subtraction-operator",
    "title": "10  Operators",
    "section": "10.3 Subtraction operator",
    "text": "10.3 Subtraction operator\nThe - operator is more powerful than the & operator, enabling flexible addition of elements to multiple plots. While its use might initially seem unintuitive, the reason behind this is that - shares the same precedence group as +, which allows it to seamlessly combine with +.\n\n10.3.1 quad_layout()\nFor ggheatmap()/quad_layout(), if the active context is the ggheatmap()/quad_layout() itself (no active annotation), the - operator behaves similarly to &. It applies the specified elements to all plots within the layout.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Remove any active annotation\n    quad_active() -\n    # Set color scale for all plots, since the active layout is the `ggheatmap()`/`quad_layout()`\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIf the active layout is an annotation stack, the - operator will only add the elements to all plots in the active annotation stack:\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the the color scales of all plots in the left annotation\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n10.3.2 stack_layout()\nFor stack_layout(), if the active layout is the stack_layout() itself, - applies the elements to all plots in the layout except the nested ggheatmap()/quad_layout().\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout except the heatmap layout\n    theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen the active layout is the nested ggheatmap()/quad_layout(), the - operator applies the elements to this nested layout, following the same principles as in the Section 10.3.1.\nWant apply elements for plots in both stack_layout() and the nested ggheatmap()/quad_layout() at the same time? refer to the following section.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#with_quad",
    "href": "operator.html#with_quad",
    "title": "10  Operators",
    "section": "10.4 with_quad()",
    "text": "10.4 with_quad()\nThe with_quad() function adjusts the context in which elements are applied in ggheatmap()/quad_layout(). It allows you to control how objects such as themes, scales, and other plot elements are applied to specific annotation stacks or the main plot, without changing the currently active context.\nThis function accepts three arguments:\n\nx: An object which can be added to the plot.\nposition: A string containing one or more of \"t\", \"l\", \"b\", and \"r\" specifies the context for applying x.\nmain: A single boolean value indicates whether x should also apply to the main plot within ggheatmap()/quad_layout(). Only used when position is not NULL.\n\n\n10.4.1 quad_layout()\nDefault Behavior by wrapping object with with_quad():\n\nWhen ggheatmap()/quad_layout() has no active annotation stack, objects added via + or - operate normally without with_quad().\nWhen the active annotation stack is set, with_quad() ensures the applied object also modifies:\n\nThe main plot (by default).\nOpposite annotation stacks when using -.\n\n\nBy wrapping object with with_quad(), the + operator will apply the object not only to the active plot in the annotation stack, but also to the main plot unless specified by main argument otherwise.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # apply the object not only to the active plot in the annotation stack, but\n    # also to the main plot\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy wrapping object with with_quad(), the - operator will apply the object not only to that annotation stack but also to the opposite one (i.e., bottom if top is active, and vice versa). In these cases, the object will also be applied to the main plot by default unless specified by main argument otherwise.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Change the active layout to the left annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the theme of all plots in the bottom and the opposite annotation\n    # in this way, the `main` argument by default would be `TRUE`\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe position argument can be a string containing one or more of \"t\", \"l\", \"b\", and \"r\", indicating which annotation stack should be used as the context. When the position argument is manually set, the default value of the main argument will be FALSE.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots in the left and top annotation\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), \"tl\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSetting position to NULL change the context to the ggheatmap()/quad_layout() itself.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # we apply the theme to the main plot only\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n10.4.2 stack_layout()\nWhen the active layout is the stack_layout() itself, by default, by wrapping object with with_quad(), - operator will apply changes to all plots along the stack_layout(), which means if the stack layout is in horizontal, - operator will also add the element to the left and right annotation, if the stack layout is in vertical, - operator will also add element to the top and bottom annotation. In these cases, the object will also be applied to the main plot by default unless specified by main argument otherwise.\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    anno_top() +\n    align_dendro() +\n    ggtitle(\"I'm from the nested heatmap\") +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout (including plots in the heatmap layout)\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n+ operator won’t do anything special when the active layout is the stack_layout() itself.\nWhen the active layout is the nested ggheatmap()/quad_layout(), the +/- operator applies the elements to this nested layout, following the same principles as for ggheatmap()/quad_layout().",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "schemes.html",
    "href": "schemes.html",
    "title": "11  Schemes",
    "section": "",
    "text": "11.1 scheme_theme()\nSchemes control the actions of plots within the layout and can be applied either globally to the layout or individually to specific plots.\nThe package currently provides three schemes, each prefixed with scheme_:\nThe scheme_theme() function extends theme() to set a default theme for plots, allowing you to input theme() elements directly or add the theme elements.\nTo set a scheme for a single plot, simply use the + operator:\n1ggheatmap(small_mat) +\n2    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\ninitialize a heatmap layout\n\n2\n\nset the default theme, change the plot background for the main plot\nYou can use a theme() object directly in scheme_theme().\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(fill = value), width = 0.9, height = 0.9) +\n    scheme_theme(theme_bw(), plot.background = element_rect(fill = \"red\"))\nNote that scheme_theme() serves as the default theme and will always be overridden by any theme() settings applied directly to the plot. The default theme (scheme_theme()) is applied first, followed by any specific theme() settings, even if theme() is added before scheme_theme().\nggheatmap(small_mat) +\n    # change the plot theme of the heatmap body\n    theme(plot.background = element_rect(fill = \"blue\")) +\n    # change the default theme of the heatmap body\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\nBy using the - operator with schemes, we apply the scheme directly to the active layout.\nggheatmap(small_mat) +\n    # Change the active layout to the top annotation\n    anno_top() +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # add a bar plot to the top annotation\n    ggalign(aes(.discrete_x, value, fill = factor(.names)), data = rowSums) +\n    geom_bar(stat = \"identity\") -\n    # Change the default theme of the top annotation\n    # All plots in the top annotation will inherit this default theme\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\nUnlike individual ggplot2 elements, which will be added directly to each plot by - operator, layout-level schemes set by - operator are inherited by all plots in the layout when rendered. Any plot-specific schemes will override these layout-level schemes, regardless of the order in which they are added.\nggheatmap(small_mat) +\n    # Change the active layout to the top annotation\n    anno_top() +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # change the scheme_theme for the dendrogram plot\n    scheme_theme(plot.background = element_rect(fill = \"blue\")) +\n    # add a bar plot to the top annotation\n    ggalign(aes(.discrete_x, value, fill = factor(.names)), data = rowSums) +\n    geom_bar(stat = \"identity\") -\n    # Change the default theme of the top annotation\n    # All plots in the top annotation will inherit this default theme\n    # But the plot-specific options will override these\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Schemes</span>"
    ]
  },
  {
    "objectID": "schemes.html#sec-scheme-data",
    "href": "schemes.html#sec-scheme-data",
    "title": "11  Schemes",
    "section": "11.2 scheme_data()",
    "text": "11.2 scheme_data()\nggalign() requires the specific data format for its operations. If you need to transform or filter data for individual geoms, you can use the data argument within each geom. However, if you have multiple geoms and want a consistent transformation applied across all, you can utilize the scheme_data() function. This allows you to transform the default data for the entire plot.\nThe scheme_data() accepts a function that takes a data frame as input and returns a modified data frame. By default, scheme_data() will attempt to inherit from the parent layout if the data is inherited from it. However, there is one exception: align_dendro() will not inherit scheme_data() transformations by default.\n\nset.seed(1234L)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L) +\n    # we add a bar plot\n    ggalign() +\n    # we subest the plot data\n    scheme_data(~ subset(.x, .panel == 1L)) +\n    geom_bar(aes(y = value, fill = .row_names), stat = \"identity\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Schemes</span>"
    ]
  },
  {
    "objectID": "schemes.html#sec-scheme-align",
    "href": "schemes.html#sec-scheme-align",
    "title": "11  Schemes",
    "section": "11.3 scheme_align()",
    "text": "11.3 scheme_align()\nThe scheme_align() function controls the align specifications for plots.\n\n11.3.1 guides\nBy default, ggheatmap() will collect all guide legends on the side from which they originate.\n\nheatmap_collect_all_guides &lt;- ggheatmap(small_mat, width = 2, height = 2L) +\n    # we set the legend to the left side\n    scale_fill_gradient2(\n        low = \"blue\", high = \"red\",\n        name = \"I'm from heatmap body\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we add a top annotation\n    anno_top() +\n    # in the top annotation, we add a dendrogram\n    align_dendro(aes(color = branch), k = 3L) +\n    # we set the legends of the dendrogram to the left side\n    scale_color_brewer(\n        name = \"I'm from top annotation\", palette = \"Dark2\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    # we add a left annotation\n    anno_left() +\n    align_dendro(aes(color = branch), k = 3L) +\n    # we set the legends of the dendrogram to the top side\n    scale_color_brewer(\n        name = \"I'm from left annotation\", palette = \"Dark2\",\n        guide = guide_legend(position = \"top\", direction = \"vertical\")\n    ) &\n    # we remove all margins for all plots\n    theme(plot.margin = margin())\nheatmap_collect_all_guides\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe guides argument schemes which side of guide legends should be gathered. In the following example, we’ll collect the guide legends only on the top (t) sides:\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side\n    with_quad(scheme_align(guides = \"t\"), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also apply the scheme_align() function directly to specific plots:\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for the heatmap layout\n    # we only collect guides in the top side\n    with_quad(scheme_align(guides = \"t\"), NULL) +\n    # `+` apply it to the active plot\n    # for the heatmap body, we collect guide in the left side\n    with_quad(scheme_align(guides = \"l\"), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote: The legend on the left side of the heatmap body is collected and positioned on the left side at the layout level.\nIf you’re annoyed by the large space between the left annotation and the heatmap body, don’t worry! This issue will be addressed in Section 11.3.2.\nNow, Let’s dive deeper into the guide collection process.\nIn the last example, we set the guides argument for the heatmap body. But what happens when we set the guides for the dendrogram in the top annotation?\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side in the heatmap layout\n    with_quad(scheme_align(guides = \"t\"), NULL) +\n    # `+` apply it to the active plot\n    # for the dendrogram in the top annotation, we collect guide in the left side\n    with_quad(scheme_align(guides = \"l\"), \"t\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNothing seems to have changed, right? This is because guide legends within annotation stacks are first collected by the annotation stack_layout() and only then passed to the top-level layout for further integration.\nBy default, the annotation stack inherits the guides arguments from the heatmap layout, followed by the inherited of individual plot in the annotation. So guides argument set at top-level (heatmap layout) will affect all guide collection behaviour.\nIn this example:\n\nThe legend on the left side of the dendrogram in the top annotation is collected first at the annotation level.\nSince the heatmap layout is not set to collect legends from the left side, it remains at the left side within the annotation stack.\nFor this specific case, the top annotation contains only one plot, so its annotation-level placement is identical to plot-level placement.\n\nTo override this, you can use the free_guides argument of the quad_anno()/anno_*() function. This differs from the guides argument in scheme_align(), which schemes the behavior for the plots in the layout. The free_guides argument specifies which guide legends from at the annotation stack layout level should be collected by the heatmap layout.\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side in the heatmap layout\n    with_quad(scheme_align(guides = \"t\"), NULL) +\n    # we also collect guides in the left side for the top annotation stack\n    # in the heatmap layout\n    anno_top(free_guides = \"l\") +\n    # `+` apply it to the active plot\n    # for the dendrogram in the top annotation, we collect guide in the left side\n    scheme_align(guides = \"l\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nNote: The heatmap layout will only collect guide legends from the annotation stack if the stack layout collects its own guides first.\n\n\n\n11.3.2 free_spaces\nBy default, ggheatmap() will align all elements of the plot, which can sometimes lead to unwanted spacing. Consider the following example:\n\nggheatmap(small_mat) +\n    # add top annotation\n    anno_top(size = unit(30, \"mm\")) +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # here, we use long labels for visual example\n    scale_y_continuous(\n        expand = expansion(),\n        labels = ~ paste(\"very very long labels\", .x)\n    ) +\n    # add left annotation\n    anno_left(unit(20, \"mm\")) +\n    # add a dendrogram to the left annotation\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this case, the left annotation stack is positioned far from the heatmap body due to the wide axis labels in the top annotation stack. This occurs because the top annotation stack is aligned with the heatmap body. To fix this, you can remove the left borders around the panel of the top annotation stack by setting free_spaces = \"l\".\n\nggheatmap(small_mat) +\n    # add top annotation\n    anno_top(size = unit(30, \"mm\")) -\n    # we remove the spaces of the left borders in the top annotation\n    scheme_align(free_spaces = \"l\") +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # here, we use long labels for visual example\n    scale_y_continuous(\n        expand = expansion(),\n        labels = ~ paste(\"very very long labels\", .x)\n    ) +\n    # add left annotation\n    anno_left(unit(20, \"mm\")) +\n    # add a dendrogram to the left annotation\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nOne useful way to utilize free_spaces is to position the guide legends next to the annotations. (Note the guide legend from the bottom annotation):\n\nheatmap_collect_all_guides +\n    # reset the active context to the heatmap layout\n    quad_active() -\n    # we set global `guides` argument for the heatmap layout\n    # we only collect guides in the top side\n    scheme_align(guides = \"t\") +\n    # `+` apply it to the current active plot\n    # for the heatmap body, we collect guide in the left side\n    scheme_align(guides = \"l\") -\n    with_quad(scheme_align(free_spaces = \"l\"), \"t\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nUsually you want to apply free_spaces with the whole layout, instead of individual plots.\nIn ggheatmap()/quad_layout(), the behavior of the free_spaces and free_labs arguments differs from guides arguments in scheme_align() when inheriting from the parent layout:\n\nFor top and bottom annotations, it inherits from the left (“l”) and right (“r”) axes.\nFor left and right annotations, it inherits from the top (“t”) and bottom (“b”) axes.\n\n\n\n11.3.3 free_labs\nBy default, we won’t align the axis titles.\n\nggheatmap(small_mat) +\n    ylab(\"Heatmap title\") +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    ylab(\"Annotation title\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo align axis titles, you can set free_labs = NULL. Alternatively, A single string containing one or more of axis positions (“t”, “l”, “b”, “r”) to indicate which axis titles should be free from alignment.\n\nggheatmap(small_mat) -\n    scheme_align(free_labs = NULL) +\n    ylab(\"Heatmap title\") +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    ylab(\"Annotation title\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Schemes</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html",
    "href": "difference-with-ggplot2.html",
    "title": "12  Difference with ggplot2",
    "section": "",
    "text": "12.1 Position Scales\nggalign focuses on aligning axes across multiple plots. While it builds on the ggplot2 framework, there are key differences in how scales, facets, and coordinates are handled. This vignette highlights these syntax differences.\nTo better fit the alignment-based layout, ggalign introduces adjustments to breaks, labels, and expand arguments.\nFor discrete values, ggalign introduces special syntax and handling for these axes, differing from the default behavior in ggplot2. These adjustments ensure that observations are properly aligned and operations are user-friendly.\nThe following syntax applies to the axes used to align observations (discrete values).",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#position-scales",
    "href": "difference-with-ggplot2.html#position-scales",
    "title": "12  Difference with ggplot2",
    "section": "",
    "text": "12.1.1 breaks\nbreaks and labels are typically handled similarly to discrete scales, as we focus on aligning observations (which should be regarded as discrete variables); no matter what you use is continuous scale or discrete scale.\nbreaks should be one of:\n- `NULL` for no breaks\n\n- `waiver()` for the default breaks (the full data index or `NULL` if no\ndata names and `labels` is `waiver()`)\n\n- A character vector of breaks (rownames / colunames of the matrix).\n\n- A numeric vector of data index (must be an integer).\n\n- A function that takes the data names or the data index as input and\nreturns breaks as output. Also accepts rlang lambda function notation. \nDefault breaks without names:\n\nno_names &lt;- small_mat\ncolnames(no_names) &lt;- NULL\nggheatmap(no_names) + scale_x_continuous()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNo breaks:\n\nggheatmap(small_mat) + scale_x_continuous(breaks = NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.discrete_x, .discrete_y, fill = value)) +\n    scale_x_discrete(breaks = NULL)\n\n\n\n\n\n\n\n\nCharacter-based breaks use data names (or indices if names are absent)\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(\"column3\", \"column5\")) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.discrete_x, .discrete_y, fill = value)) +\n    scale_x_discrete(breaks = c(\"column3\", \"column5\")) +\n    anno_top() +\n    align_dendro(k = 3L)\n\n\n\n\n\n\n\n\nInteger-based breaks are interpreted as data indices:\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(3, 5)) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.discrete_x, .discrete_y, fill = value)) +\n    scale_x_discrete(breaks = c(3, 5)) +\n    anno_top() +\n    align_dendro(k = 3L)\n\n\n\n\n\n\n\n\nFloating numbers are invalid for breaks:\n\nggheatmap(small_mat) + scale_x_continuous(breaks = c(3.5, 5))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; Error in `scale_x_continuous()`:\n#&gt; ! Can't convert from `breaks` &lt;double&gt; to &lt;integer&gt; due to loss of precision.\n#&gt; • Locations: 1\n\nTo interpret integers as plot-specific coordinate indices, wrap them with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = I(3:4)) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n12.1.2 labels\nlabels should be one of:\n- `NULL` for no labels\n\n- `waiver()` for the default labels (data names)\n\n- A character vector giving labels (must be same length as breaks)\n\n- An expression vector (must be the same length as breaks). See `?plotmath`\nfor details. \n\n- A function that takes the data names (or data index if data has no names)\nas input and returns labels as output. This can be also a rlang lambda\nfunction.\nThe default labels are the data names (or indices if names are absent):\n\nggheatmap(small_mat) + scale_x_continuous() +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNo labels:\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = NULL) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nCharacter labels will be reordered based on the data’s ordering:\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = letters[seq_len(ncol(small_mat))]) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo retain the original order of character labels, wrap them with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = I(letters[seq_len(ncol(small_mat))])) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, labels correspond to breaks:\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(5, 3), labels = c(\"a\", \"b\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo override the default matching, wrap the labels vector with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(5, 3), labels = I(c(\"a\", \"b\")))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#theme",
    "href": "difference-with-ggplot2.html#theme",
    "title": "12  Difference with ggplot2",
    "section": "12.2 theme",
    "text": "12.2 theme\nAlthough ggplot2 does not officially support vectorized input for theme elements, we can still utilize it. ggalign extends this feature, allowing theme elements to be vectorized and applied across panels.\n\nggheatmap(small_mat) +\n    theme(\n        axis.text.x = element_text(\n            colour = c(rep(\"red\", 4), rep(\"blue\", 5))\n        ),\n        axis.ticks.x = element_line(\n            colour = c(rep(\"red\", 4), rep(\"blue\", 5))\n        ),\n        axis.ticks.length.x = unit(rep(c(1, 4), times = c(4, 5)), \"mm\")\n    ) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_y_continuous(expand = expansion()) &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#facets",
    "href": "difference-with-ggplot2.html#facets",
    "title": "12  Difference with ggplot2",
    "section": "12.3 Facets",
    "text": "12.3 Facets\nWhen working with facets, manual configuration of the panel using the facet_*() functions is not possible since the internal structure will use facet_grid() to set the row/column groups defined by align_*() functions. However, you can still use facet_grid() or facet_null() (if no panel) to control other arguments except aligned panels (rows in horizontal stack layout or cols in vertical stack layout, or both rows and cols in heatmap body).\nA common use case is to modify the panel strip text. The default theme (theme_ggalign()) will always remove the panel strip text, you can override this behaviour with theme(strip.text = element_text()) to add the panel title in the plot area.\n\nggheatmap(small_mat) +\n    facet_grid(labeller = labeller(.column_panel = function(x) letters[as.integer(x)])) +\n    theme(strip.text = element_text()) +\n    anno_top() +\n    align_kmeans(centers = 3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "plot-composer.html",
    "href": "plot-composer.html",
    "title": "13  Plot Composer",
    "section": "",
    "text": "13.1 Plot Assembly\nSpecial thanks to the patchwork project—many core codes of the plot composer process were adapted from patchwork. We have added new features to better implement ggalign’s layout functions (stack_layout() and quad_layout()), including:\nThese features have not been pushed to patchwork because they required significant modification of core code. We attempted to merge them, but the author of patchwork decided to implement some of these features independently. The latest version of patchwork now includes free_align(), free_lab(), and free_space() functionality under a single function: patchwork::free(). For more details, see: https://www.tidyverse.org/blog/2024/09/patchwork-1-3-0/.\nThe plot composer function in ggalign is align_plots(), which behaves similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, you can directly use align_plots() with quad_layout()/ggheatmap() and stack_layout(), ensuring that they align correctly by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, although they won’t align by panel area with ggplot2.\nWe’ll start with a few well-known example plots:\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp))\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(gear, disp, group = gear))\np3 &lt;- ggplot(mtcars) +\n    geom_bar(aes(gear)) +\n    facet_wrap(~cyl)\np4 &lt;- ggplot(mtcars) +\n    geom_bar(aes(carb))\np5 &lt;- ggplot(mtcars) +\n    geom_violin(aes(cyl, mpg, group = cyl))\nEither add the plots as single arguments\nalign_plots(p1, p2, p3, p4, p5)\nOr use bang-bang-bang to add a list of plots\nalign_plots(!!!list(p1, p2, p3), p4, p5)",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#empty-area",
    "href": "plot-composer.html#empty-area",
    "title": "13  Plot Composer",
    "section": "13.2 Empty area",
    "text": "13.2 Empty area\nYou can use NULL to indicate the empty area.\n\nalign_plots(p1, NULL, p2, NULL, p3, NULL)",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#controlling-the-grid",
    "href": "plot-composer.html#controlling-the-grid",
    "title": "13  Plot Composer",
    "section": "13.3 Controlling the grid",
    "text": "13.3 Controlling the grid\nLike patchwork, if no specific layout is provided, align_plots() will attempt to create a grid that is as square as possible, with each column and row taking up equal space:\n\nalign_plots(p1, p2, p3, p4, ncol = 3)\n\n\n\n\n\n\n\n\nTo adjust the widths of columns, use:\n\nalign_plots(p1, p2, p3, p4, widths = c(2, 1))",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#guide-legends",
    "href": "plot-composer.html#guide-legends",
    "title": "13  Plot Composer",
    "section": "13.4 Guide legends",
    "text": "13.4 Guide legends\nBy default, align_plots() won’t collect any guide legends. You can use the guides argument to control which side of the guide legends should be collected. They will be collected to their original side. Here, we use patch_titles() to indicate the guide legend position (instead of using ggtitle()). patch_titles() can add titles on four sides, and the title will be placed between the plot panel and the guide legend.\n\np_right &lt;- ggplot(mtcars) +\n    geom_point(aes(hp, wt, colour = mpg)) +\n    patch_titles(\"right\") +\n    labs(color = \"right\")\np_top &lt;- p_right +\n    patch_titles(\"top\") +\n    scale_color_continuous(\n        name = \"top\",\n        guide = guide_colorbar(position = \"top\")\n    )\np_left &lt;- p_right +\n    patch_titles(\"left\") +\n    scale_color_continuous(\n        name = \"left\",\n        guide = guide_colorbar(position = \"left\")\n    )\np_bottom &lt;- p_right +\n    patch_titles(\"bottom\") +\n    scale_color_continuous(\n        name = \"bottom\",\n        guide = guide_colorbar(position = \"bottom\")\n    )\nalign_plots(p_right, p_bottom, p_top, p_left, guides = \"tlbr\")\n\n\n\n\n\n\n\n\nIf align_plots() is nested in another align_plots(), the nested align_plots() will inherit the guides argument from the upper-level align_plots(). And the top-level align_plots() won’t collect guide legends from plots within the nested align_plots() unless the nested align_plots() collects them first.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#free_guide",
    "href": "plot-composer.html#free_guide",
    "title": "13  Plot Composer",
    "section": "13.5 free_guide",
    "text": "13.5 free_guide\nThe free_guide() function allows you to override the guides argument for a single plot.\n\nalign_plots(\n    free_guide(p_right, NULL),\n    free_guide(p_bottom, NULL),\n    free_guide(p_top, NULL),\n    free_guide(p_left, NULL),\n    guides = \"tlbr\"\n)\n\n\n\n\n\n\n\n\nYou can also specify which guide positions to be collected for individual plots.\n\nalign_plots(\n    free_guide(p_right, \"r\"),\n    free_guide(p_bottom, \"b\"),\n    free_guide(p_top, \"t\"),\n    free_guide(p_left, \"l\")\n)",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "oncoplot.html",
    "href": "oncoplot.html",
    "title": "14  ggoncoplot",
    "section": "",
    "text": "14.1 Input data\nThe ggoncoplot() function generates oncoPrint visualizations that display genetic alterations in a matrix format. This function is especially useful for visualizing complex genomic data, such as mutations, copy number variations, and other genomic alterations in cancer research.\nThe input should be a character matrix which encodes the alterations, you can use string of \";\", \":\", \",\", and \"|\" to separate multiple alterations. Internally, ggoncoplot() will use fortify_matrix() to get such matrix.\nmat &lt;- read.table(\n    textConnection(\n        \"s1,s2,s3\n         g1,snv;indel,snv,indel\n         g2,,snv;indel,snv\n         g3,snv,,indel;snv\"\n    ),\n    row.names = 1, header = TRUE, sep = \",\", stringsAsFactors = FALSE\n)\nmat\n#&gt;                    s1        s2        s3\n#&gt;          g1 snv;indel       snv     indel\n#&gt;          g2           snv;indel       snv\n#&gt;          g3       snv           indel;snv\nA basic oncoprint can be generated as follows:\nggoncoplot(mat)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#oncoprint-customization",
    "href": "oncoplot.html#oncoprint-customization",
    "title": "14  ggoncoplot",
    "section": "14.2 oncoPrint Customization",
    "text": "14.2 oncoPrint Customization\nBy default, all alterations are represented with tiles of equal width and height, which may lead to overlapping. You can control the width and height of the tiles using the map_width and map_height arguments (we will introduce another more effective ways to handle this in the Specialized Geoms section):\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9))\n\n\n\n\n\n\n\n\nBy default, all empty string will be converted to NA value and ggplot2 will translate the NA values and render it in the legend. To prevent this, you can turn off the translation using na.translate = FALSE:\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n\n\n\n\n\n\n\n\nThe function automatically reorders rows and columns based on alteration frequency. Disable this with reorder_row = FALSE and reorder_column = FALSE.\nYou can further customize layouts using methods from vignette(\"layout-customize\").\n\nggoncoplot(mat,\n    map_width = c(snv = 0.5), map_height = c(indel = 0.9),\n    reorder_row = FALSE, reorder_column = FALSE\n) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#advanced-data-handling",
    "href": "oncoplot.html#advanced-data-handling",
    "title": "14  ggoncoplot",
    "section": "14.3 Advanced Data Handling",
    "text": "14.3 Advanced Data Handling\nggoncoplot() is built on ggheatmap() with a default scheme_data() (see vignette(\"plot-options\") for details), which splits alterations into separate entries for visualization. (See ggplot2 specification section in ggheatmap() for the input data of scheme_data()):\n\npdata &lt;- function(data) {\n    tidyr::separate_longer_delim(data,\n        cols = value,\n        delim = stringr::regex(\"\\\\s*[;:,|]\\\\s*\")\n    )\n}\n# Note: this figure will contain an empty string value.\n#\n# `ggoncoplot()` will automatically convert any empty strings to `NA`\n# before pass it to `ggheatmap`.\nggheatmap(mat) -\n    scheme_data(pdata) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, the scheme_data() is inherited from the parent layout if the data of the plot is inherited from the layout. You can apply the parent scheme_data() first and then apply another transformation by setting inherit = TRUE. This functionality is especially useful when working with ggoncoplot().\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +\n    anno_top(size = 0.2) +\n    ggalign() +\n    # by setting `inherti = TRUE`, we apply the parent layout `scheme_data()`\n    # (from the `ggoncoplot()` layout) firstly, which will split the alteration\n    # string and unnested the columns.\n    # Here: We then remove `NA` value\n    scheme_data(~ subset(.x, !is.na(value)), inherit = TRUE) +\n    geom_bar(aes(.x, after_stat(count), fill = value)) +\n    # note: `ggoncoplot()` use `geom_tile()` to draw the oncoPrint,\n    # the guide is different from `geom_bar()`, though both looks\n    # like the same, we remove the guide of `geom_bar()` plot\n    guides(fill = \"none\") &\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#integration-with-maftools",
    "href": "oncoplot.html#integration-with-maftools",
    "title": "14  ggoncoplot",
    "section": "14.4 Integration with maftools",
    "text": "14.4 Integration with maftools\nThe ggoncoplot() function supports MAF objects from the maftools package using the fortify_matrix.MAF() method. It includes options to control data generation for ggoncoplot(), such as drawing the top n_top genes.\n\n# load data from `maftools`\nlaml.maf &lt;- system.file(\"extdata\", \"tcga_laml.maf.gz\", package = \"maftools\")\n# clinical information containing survival information and histology. This is optional\nlaml.clin &lt;- system.file(\"extdata\", \"tcga_laml_annot.tsv\", package = \"maftools\")\nlaml &lt;- maftools::read.maf(\n    maf = laml.maf,\n    clinicalData = laml.clin,\n    verbose = FALSE\n)\n# Visualizing the Top 20 Genes\nggoncoplot(laml, n_top = 20) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n\n\n\n\n\n\n\n\nBy default, samples without alterations in the selected genes are removed. To include all samples, set remove_empty_samples = FALSE:\n\nalign_plots(\n    ggoncoplot(laml, n_top = 20L, remove_empty_samples = FALSE) +\n        scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n        theme_no_axes(\"x\") +\n        ggtitle(\"Keep empty samples\"),\n    ggoncoplot(laml, n_top = 20L, remove_empty_samples = TRUE) +\n        scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n        theme_no_axes(\"x\") +\n        ggtitle(\"Remove empty samples\"),\n    ncol = 1L,\n    guides = \"tlbr\"\n)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#specialized-geoms",
    "href": "oncoplot.html#specialized-geoms",
    "title": "14  ggoncoplot",
    "section": "14.5 Specialized Geoms",
    "text": "14.5 Specialized Geoms\n\n14.5.1 geom_subtile()\nWhen multiple alterations occur in the same sample and gene, they are combined into a single value, \"Multi_Hit\", by default. To visualize these alterations separately, you can set collapse_vars = FALSE. However, doing so can lead to overlapping alterations within the same cell, making the visualization cluttered and hard to interpret.\nIn such cases, disabling the default filling and defining a custom heatmap layer with geom_subtile() is more effective. This function subdivides each cell into smaller rectangles, allowing the distinct alterations to be clearly displayed.\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), direction = \"v\") +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\nWe focus exclusively on cells with multiple alterations to highlight the differences, by filtering the data before applying geom_subtile():\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    scheme_data(function(data) {\n        dplyr::filter(data, dplyr::n() &gt; 1L, .by = c(\".x\", \".y\"))\n        # we apply the parent layout `scheme_data()` first (`inherit = TRUE`),\n        # which will split the alteration string and unnested the columns.\n    }, inherit = TRUE) +\n    geom_subtile(aes(fill = value), direction = \"v\") +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\n\n\n14.5.2 geom_draw2()\ngeom_subtile() often suffices for most scenarios. However, if you require a strategy similar to that of ComplexHeatmap, consider using geom_draw2(), which offers greater flexibility for complex customizations.\nKey Features of geom_draw2():\n\nCustom Drawing Logic: Accepts a draw aesthetic, allowing each cell to be rendered as a specific graphical object (grob).\nManual Scaling: Requires scale_draw_manual() to map draw values to corresponding drawing functions.\nFlexible Aesthetic Mapping: Functions mapped through scale_draw_manual() can utilize any number of ggplot2 aesthetics and output custom graphical objects (grob). Beyond the x, y, xmin, xmax, width, and height aesthetics, you may want to rely solely on mapped aesthetics (aes()). Unmapped aesthetics will default to ggplot2’s behavior, which might not produce the desired outcome. And always use native unit.\n\n:) Sorry, I cannot deal with a pretty example for this, but the function provided in values argument of scale_draw_manual operates similarly to alter_fun in ComplexHeatmap. Currently, geom_subtile() performs well enough for most cases, making geom_draw2() somewhat cumbersome to use. Managing alteration types, especially in the case of overlapping alterations, requires meticulous design to ensure that the visual elements do not interfere with each other.\n\nlibrary(grid)\ndraw_mapping &lt;- list(\n    function(x, y, width, height, fill) {\n        rectGrob(x, y,\n            width = width, height = height,\n            gp = gpar(fill = fill),\n            default.units = \"native\"\n        )\n    },\n    function(x, y, width, height, fill) {\n        rectGrob(x, y,\n            width = width, height = height,\n            gp = gpar(fill = fill),\n            default.units = \"native\"\n        )\n    },\n    function(x, y, width, height, fill) {\n        rectGrob(x, y,\n            width = width, height = height,\n            gp = gpar(fill = fill),\n            default.units = \"native\"\n        )\n    },\n    function(x, y, width, height, shape) {\n        gList(\n            pointsGrob(x, y, pch = shape),\n            # To ensure the rectangle color is shown in the legends, you\n            # must explicitly provide a color argument and include it in\n            # the `gpar()` of the graphical object\n            rectGrob(x, y, width, height,\n                gp = gpar(col = \"black\", fill = NA)\n            )\n        )\n    },\n    function(xmin, xmax, ymin, ymax) {\n        segmentsGrob(\n            xmin, ymin,\n            xmax, ymax,\n            gp = gpar(lwd = 2)\n        )\n    }\n)\n\nvalue &lt;- sample(letters, 5L)\nggplot(data.frame(value = value, y = seq_len(5))) +\n    geom_draw2(aes(x = 1, y = y, draw = value, fill = value)) +\n    scale_draw_manual(values = draw_mapping) +\n    scale_fill_brewer(palette = \"Dark2\")\nggplot(data.frame(value = c(value, value[5L]), y = c(1, 2, 3, 1, 2, 3))) +\n    geom_draw2(aes(x = 1, y = y, draw = value, fill = value)) +\n    scale_draw_manual(values = draw_mapping) +\n    scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#ggalign-attributes",
    "href": "oncoplot.html#ggalign-attributes",
    "title": "14  ggoncoplot",
    "section": "14.6 ggalign attributes",
    "text": "14.6 ggalign attributes\nExcept for the data used for the main plot, fortify_matrix.MAF() also attaches several useful attributes.\n\ngene_summary: gene summary informations. See maftools::getGeneSummary() for details.\nsample_summary: sample summary informations. See maftools::getSampleSummary() for details.\nsample_anno: sample clinical informations. See maftools::getClinicalData() for details.\nn_genes: Total of genes.\nn_samples: Total of samples.\ntitv: A list of data.frames with Transitions and Transversions summary. See maftools::titv() for details.\n\nYou can extract these attributes using the ggalign_attr() function. Below is an example of how to extract the sample summary data (e.g., TMB) using ggalign_attr() and add it to the top annotation of an oncoplot:\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), direction = \"v\") +\n    theme_no_axes(\"x\") +\n    anno_top(size = 0.2) +\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"sample_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:(ncol(data) - 1L)])\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    ylab(\"TMB\") &\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\nWe can draw the example from maftools vignette.\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), direction = \"v\") +\n    theme_no_axes(\"x\") +\n    # since legends from geom_tile (oncoPrint body) and `geom_bar`\n    # is different, though both looks like the same, the internal\n    # won't merge the legends. we remove the legends of oncoPrint body\n    guides(fill = \"none\") +\n    # add top annotation\n    anno_top(size = 0.2) +\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"sample_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:(ncol(data) - 1L)])\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    ylab(\"TMB\") +\n    # add right annotation\n    anno_right(size = 0.2) -\n    # remove bottom spaces of the right annotation when aligning\n    scheme_align(free_spaces = \"b\") +\n    # add the text percent for the alterated samples in the right annotation\n    ggalign(data = function(data) {\n        # Atomic vector will be put in the `value` column of the data frame.\n        ggalign_attr(data, \"gene_summary\")$AlteredSamples /\n            ggalign_attr(data, \"n_samples\")\n    }) +\n    geom_text(aes(1, label = scales::label_percent()(value)), hjust = 1) +\n    scale_x_continuous(\n        expand = expansion(),\n        name = NULL, breaks = NULL,\n        limits = c(0, 1)\n    ) +\n    theme(plot.margin = margin()) +\n    # add the bar plot in the right annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"gene_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:8])\n    }) +\n    geom_bar(aes(value, fill = .column_names),\n        stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    xlab(\"No. of samples\") -\n    # we apply the scale mapping to the top and right annotation: `position = \"tr\"`\n    # and the main plot: `main = TRUE`\n    with_quad(\n        scale_fill_brewer(\"Mutations\",\n            palette = \"Dark2\", na.translate = FALSE\n        ),\n        position = \"tr\",\n        main = TRUE\n    ) +\n    # add bottom annotation\n    anno_bottom(size = 0.2) +\n    # add bar plot in the bottom annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"titv\")$fraction.contribution\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:7])\n    }) +\n    geom_bar(aes(y = value, fill = .column_names), stat = \"identity\") +\n    ylab(\"Ti/Tv\") +\n    scale_fill_brewer(\"Ti/Tv\", palette = \"Set2\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n#&gt; Warning: Removed 24 rows containing missing values or values outside the scale range\n#&gt; (`geom_bar()`).",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#integration-with-gistic-results-from-maftools",
    "href": "oncoplot.html#integration-with-gistic-results-from-maftools",
    "title": "14  ggoncoplot",
    "section": "14.7 Integration with GISTIC results from maftools",
    "text": "14.7 Integration with GISTIC results from maftools\nThe package also includes a fortify_matrix.GISTIC() method designed to handle GISTIC objects from the maftools package. This allows you to seamlessly apply the same operations to visualize GISTIC results. The following ggalign attributes are generated as part of the analysis:\n\nsample_anno: sample clinical informations provided in sample_anno argument.\nsample_summary: sample copy number summary informations. See data@cnv.summary for details.\ncytoband_summary: cytoband summary informations. See data@cytoband.summary for details.\ngene_summary: gene summary informations. See data@gene.summary for details.\nsummary: A data frame of summary information. See data@summary for details.\n\n\n# Ensure the maftools package is installed and load the example GISTIC data\nall.lesions &lt;- system.file(\"extdata\", \"all_lesions.conf_99.txt\", package = \"maftools\")\namp.genes &lt;- system.file(\"extdata\", \"amp_genes.conf_99.txt\", package = \"maftools\")\ndel.genes &lt;- system.file(\"extdata\", \"del_genes.conf_99.txt\", package = \"maftools\")\nscores.gistic &lt;- system.file(\"extdata\", \"scores.gistic\", package = \"maftools\")\nlaml.gistic &lt;- maftools::readGistic(\n    gisticAllLesionsFile = all.lesions, gisticAmpGenesFile = amp.genes,\n    gisticDelGenesFile = del.genes, gisticScoresFile = scores.gistic\n)\n#&gt; -Processing Gistic files..\n#&gt; --Processing amp_genes.conf_99.txt\n#&gt; --Processing del_genes.conf_99.txt\n#&gt; --Processing scores.gistic\n#&gt; --Summarizing by samples\nggoncoplot(laml.gistic) +\n    scale_fill_brewer(\"CNV\", palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "complete-examples.html",
    "href": "complete-examples.html",
    "title": "15  Complete examples",
    "section": "",
    "text": "15.1 Simple heatmap\nggheatmap(small_mat)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#heatmap-layout-customize",
    "href": "complete-examples.html#heatmap-layout-customize",
    "title": "15  Complete examples",
    "section": "15.2 heatmap layout customize",
    "text": "15.2 heatmap layout customize\n\n15.2.1 Based on dendrogram\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch, y = y)) +\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n15.2.2 Based on kmeans\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n15.2.3 Based on a group variable\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n15.2.4 Based on an ordering weights\nHere, we ordered the heatmap rows based on the row means.\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#heatmap-annotation-plot",
    "href": "complete-examples.html#heatmap-annotation-plot",
    "title": "15  Complete examples",
    "section": "15.3 Heatmap annotation plot",
    "text": "15.3 Heatmap annotation plot\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch, y = y)) +\n    scale_color_brewer(palette = \"Dark2\") +\n    ggalign(mapping = aes(y = value)) +\n    geom_boxplot(aes(factor(.x), fill = .panel)) +\n    scale_fill_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = 0.5) +\n    align_dendro(aes(color = branch), k = 3L) +\n    ggalign(rowSums, aes(y = value)) +\n    geom_bar(stat = \"identity\", aes(fill = factor(.panel))) +\n    scale_fill_brewer(name = NULL, palette = \"Dark2\") +\n    anno_left(size = 0.5) +\n    align_dendro(aes(color = branch), size = 0.5, k = 4L) +\n    ggalign(rowSums, aes(x = value)) +\n    geom_bar(\n        aes(y = .y, fill = factor(.y)),\n        stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    scale_fill_brewer(name = NULL, palette = \"Paired\", guide = \"none\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#multiple-heatmaps",
    "href": "complete-examples.html#multiple-heatmaps",
    "title": "15  Complete examples",
    "section": "15.4 Multiple heatmaps",
    "text": "15.4 Multiple heatmaps\n\n15.4.1 Horizontal layout\n\n(stack_alignh(small_mat) +\n    ggheatmap() +\n    ggheatmap() &\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))) +\n    stack_active() +\n    align_dendro(aes(color = branch), k = 4L, size = 0.2) +\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n15.4.2 Vertical layout\n\nstack_alignv(small_mat) -\n    scheme_theme(\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank()\n    ) +\n    align_dendro(aes(color = branch), k = 4L, size = 0.2) +\n    scale_color_brewer(palette = \"Dark2\") +\n    ggheatmap() +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#marginal-plots",
    "href": "complete-examples.html#marginal-plots",
    "title": "15  Complete examples",
    "section": "15.5 marginal plots",
    "text": "15.5 marginal plots\n\nggside(mpg, aes(displ, hwy, colour = class)) -\n    # set default theme for all plots in the layout\n    scheme_theme(theme_bw()) +\n    geom_point(size = 2) +\n    # add top annotation\n    anno_top(size = 0.3) -\n    # set default theme for the top annotation\n    scheme_theme(theme_no_axes(\"tb\")) +\n    # add a plot in the top annotation\n    ggalign() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    anno_right(size = 0.3) -\n    # set default theme for the right annotation\n    scheme_theme(theme_no_axes(\"lr\")) +\n    # add a plot in the right annotation\n    ggalign() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    ) +\n    theme(axis.text.x = element_text(angle = 90, vjust = .5)) &\n    scale_color_brewer(palette = \"Dark2\")",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complexheatmap.html",
    "href": "complexheatmap.html",
    "title": "ComplexHeatmap",
    "section": "",
    "text": "In this chapter, we’ll use ggalign to draw all the heatmap in https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html.\nThe chapter is divided into several sections, following the structure of the original book.",
    "crumbs": [
      "ComplexHeatmap"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html",
    "href": "complexheatmap-single-heatmap.html",
    "title": "16  A Single Heatmap",
    "section": "",
    "text": "16.1 Colors\nIn this thread, we’ll use ggalign to draw all the heatmap in https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html\nIt is important to note that the ComplexHeatmap package reorders the dendrogram by default, while align_dendro() in ggalign does not modify the tree layout.\nAnother key difference is in how the two packages treat the starting point. ggalign considers the left-bottom as the starting point, whereas ComplexHeatmap starts from the left-top. When reordering the dendrogram, ComplexHeatmap does so in decreasing order, while ggalign uses an ascending order.\nTo modify colors in the heatmap, you can use the scale_fill_*() function from ggplot2, which provides a flexible way and enriched pallete to adjust color schemes.\ndim(mat)\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat)\n#&gt; [1] 18 24\nggheatmap(mat) +\n    scale_fill_gradient2(low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro() +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\noob argument in the scale_fill_* function can be used to deal with the outliers.\nmat2 &lt;- mat\nmat2[1, 1] &lt;- 100000\nggheatmap(mat2) +\n    scale_fill_gradient2(\n        low = \"green\", high = \"red\",\n        limits = c(-2, 2),\n        oob = scales::squish\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nWe can use align_plots() to arrange them.\nh1 &lt;- ggheatmap(mat) +\n    scale_fill_gradient2(name = \"mat\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh2 &lt;- ggheatmap(mat / 4) +\n    scale_fill_gradient2(\n        name = \"mat/4\", limits = c(-2, 2L),\n        oob = scales::squish,\n        low = \"green\", high = \"red\"\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh3 &lt;- ggheatmap(abs(mat)) +\n    scale_fill_gradient2(name = \"abs(mat)\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\nalign_plots(h1, h2, h3, ncol = 2L)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nggheatmap(mat) +\n    scale_fill_gradientn(colors = rev(rainbow(10))) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nFor character matrix, you can use ggplot2 discrete filling scales.\ndiscrete_mat &lt;- matrix(sample(1:4, 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = c(\"1\", \"2\", \"3\", \"4\")) # black, red, green, blue\nggheatmap(discrete_mat, aes(fill = factor(value))) +\n    scale_fill_manual(values = colors) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\ndiscrete_mat &lt;- matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = letters[1:4])\nggheatmap(discrete_mat) +\n    scale_fill_manual(values = colors)\n#&gt; → heatmap built with `geom_tile()`\nmat_with_na &lt;- mat\nna_index &lt;- sample(c(TRUE, FALSE),\n    nrow(mat) * ncol(mat),\n    replace = TRUE, prob = c(1, 9)\n)\nmat_with_na[na_index] &lt;- NA\nggheatmap(mat_with_na) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", na.value = \"black\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nWe won’t compare the LAB and RGB space. If you want to convert color between different color space, try to use farver pacakge.\nIn ggplot2, you can use panel.border argument in theme() function to control the Heatmap body border.\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        panel.border = element_rect(linetype = \"dashed\", fill = NA)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nYou can use the filling argument to turn off the heatmap cell filling, allowing you to customize the heatmap body geoms. Use the color aesthetic to specify the cell border color and the linewidth aesthetic to set the border width.\nggheatmap(mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\nTo draw a blank heatmap body:\nggheatmap(mat, filling = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#titles",
    "href": "complexheatmap-single-heatmap.html#titles",
    "title": "16  A Single Heatmap",
    "section": "16.2 Titles",
    "text": "16.2 Titles\nWe can use patch_titles() to add titles around each border of the plot. You can use theme() to control the text appearance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(right = \"I am a row title\") +\n    theme(plot.patch_title.right = element_text(face = \"bold\", size = 16)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"I am a column title\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#clustering",
    "href": "complexheatmap-single-heatmap.html#clustering",
    "title": "16  A Single Heatmap",
    "section": "16.3 Clustering",
    "text": "16.3 Clustering\n\n16.3.1 Distance methods\n\n# ComplexHeatmap::Heatmap(mat,\n#   name = \"mat\", clustering_distance_rows = \"pearson\",\n#   column_title = \"pre-defined distance method (1 - pearson)\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = \"pearson\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"pre-defined distance method (1 - pearson)\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", clustering_distance_rows = function(m) dist(m),\n#     column_title = \"a function that calculates distance matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = dist, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"a function that calculates distance matrix\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n16.3.2 Clustering methods\nMethod to perform hierarchical clustering can be specified by method argument, Possible methods are those supported in hclust() function.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     clustering_method_rows = \"single\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(method = \"single\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nUse distance = NULL if you don’t want to calculate the distance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::diana,\n        reorder_dendrogram = TRUE\n    ) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::agnes,\n        reorder_dendrogram = TRUE\n    ) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n16.3.3 Render dendrograms\nIt’s easy for ggalign to color the branches by setting the color mapping, since ggalign will add the cutree() results into the underlying data.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(aes(color = branch), k = 2L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#set-row-and-column-orders",
    "href": "complexheatmap-single-heatmap.html#set-row-and-column-orders",
    "title": "16  A Single Heatmap",
    "section": "16.4 Set row and column orders",
    "text": "16.4 Set row and column orders\nWe can use align_order() to set the order.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     row_order = order(as.numeric(gsub(\"row\", \"\", rownames(mat)))),\n#     column_order = order(as.numeric(gsub(\"column\", \"\", colnames(mat)))),\n#     column_title = \"reorder matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(as.numeric(gsub(\"row\", \"\", rownames(mat)))) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(as.numeric(gsub(\"column\", \"\", colnames(mat)))) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#seriation",
    "href": "complexheatmap-single-heatmap.html#seriation",
    "title": "16  A Single Heatmap",
    "section": "16.5 Seriation",
    "text": "16.5 Seriation\nalign_reorder() can directly take the seriate() function as the input and extract the ordering information.\n\nmat2 &lt;- max(mat) - mat\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe above code will execute seriate() twice—once for each dimension. However, since a single run of seriate() can provide the ordering for both dimensions, we can manually extract the ordering indices to avoid redundancy.\n\no &lt;- seriation::seriate(mat2, method = \"BEA_TSP\")\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(seriation::get_order(o, 1L)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(seriation::get_order(o, 2L)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFor more use of the seriate() function, please refer to the seriation package.",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#dimension-labels",
    "href": "complexheatmap-single-heatmap.html#dimension-labels",
    "title": "16  A Single Heatmap",
    "section": "16.6 Dimension labels",
    "text": "16.6 Dimension labels\nggplot2 use scales and theme to control the axis labels, Please see chapter for more details.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", row_names_side = \"left\", row_dend_side = \"right\",\n#     column_names_side = \"top\", column_dend_side = \"bottom\"\n# )\nggheatmap(mat) +\n    scale_x_continuous(position = \"top\") +\n    scale_y_continuous(position = \"right\") +\n    theme(axis.text.x = element_text(angle = 60, hjust = 0)) +\n    anno_left(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_x_continuous(position = \"top\") +\n    anno_bottom(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_y_continuous(position = \"right\") +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    scale_y_continuous(breaks = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(face = \"bold\", size = 16)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(\n            face = \"bold\", size = 16,\n            colour = c(rep(\"red\", 10), rep(\"blue\", 8))\n        )\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#heatmap-split",
    "href": "complexheatmap-single-heatmap.html#heatmap-split",
    "title": "16  A Single Heatmap",
    "section": "16.7 Heatmap split",
    "text": "16.7 Heatmap split\n\n16.7.1 Split by k-means clustering\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe dendrogram was calculated in each group defined by kmeans.\n\n\n16.7.2 Split by categorical variables\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"A\", \"B\"), 9)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"C\", \"D\"), 12)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n16.7.3 Split by dendrogram\nWhen you splitted by a dendrogram, the cutted height will be indicated with a dashed line.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(k = 3L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(aes(color = branch), k = 3L, reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n16.7.4 Order of slices (panels)\nThe order of the panels always follow the factor level. Note: the merging of dendrogram between ComplexHeatmap and ggalign is a little different.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    quad_active() -\n    with_quad(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    quad_active() -\n    with_quad(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n16.7.5 Titles for splitting (facet strip text)\nBy default, the facet strip text is removed. You can override this behavior with theme(strip.text = element_text()). Since align_group() does not create a new plot, the panel title can only be added to the heatmap plot.\nwaiting for complete …\n\n\n16.7.6 Graphic parameters for splitting\n\nggh4x::facet_grid2(strip = ggh4x::strip_themed(\n    background_x = list(\n        element_rect(fill = \"red\"),\n        element_rect(fill = \"blue\"),\n        element_rect(fill = \"green\")\n    )\n))\n#&gt; &lt;ggproto object: Class FacetGrid2, FacetGrid, Facet, gg&gt;\n#&gt;     attach_axes: function\n#&gt;     compute_layout: function\n#&gt;     draw_back: function\n#&gt;     draw_front: function\n#&gt;     draw_labels: function\n#&gt;     draw_panels: function\n#&gt;     finish_data: function\n#&gt;     finish_panels: function\n#&gt;     init_scales: function\n#&gt;     map_data: function\n#&gt;     params: list\n#&gt;     setup_aspect_ratio: function\n#&gt;     setup_axes: function\n#&gt;     setup_data: function\n#&gt;     setup_panel_table: function\n#&gt;     setup_params: function\n#&gt;     shrink: TRUE\n#&gt;     strip: &lt;ggproto object: Class StripElemental, Strip, gg&gt;\n#&gt;         assemble_strip: function\n#&gt;         build_strip: function\n#&gt;         clip: inherit\n#&gt;         draw_labels: function\n#&gt;         elements: list\n#&gt;         finish_strip: function\n#&gt;         get_strips: function\n#&gt;         given_elements: list\n#&gt;         incorporate_grid: function\n#&gt;         incorporate_wrap: function\n#&gt;         init_strip: function\n#&gt;         params: list\n#&gt;         setup: function\n#&gt;         setup_elements: function\n#&gt;         strips: list\n#&gt;         super:  &lt;ggproto object: Class StripElemental, Strip, gg&gt;\n#&gt;     train_scales: function\n#&gt;     vars: function\n#&gt;     vars_combine: function\n#&gt;     super:  &lt;ggproto object: Class FacetGrid2, FacetGrid, Facet, gg&gt;",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-more-examples.html",
    "href": "complexheatmap-more-examples.html",
    "title": "17  More examples",
    "section": "",
    "text": "17.1 Add more information for gene expression matrix\nIn this section, we’ll use ggalign to draw all the heatmap in https://jokergoo.github.io/ComplexHeatmap-reference/book/more-examples.html.\nexpr &lt;- read_example(\"gene_expression.rds\")\nmat &lt;- as.matrix(expr[, grep(\"cell\", colnames(expr))])\nbase_mean &lt;- rowMeans(mat)\nmat_scaled &lt;- t(apply(mat, 1, scale))\ntype &lt;- gsub(\"s\\\\d+_\", \"\", colnames(mat))\n\nheat1 &lt;- ggheatmap(mat_scaled) -\n    scheme_align(free_spaces = \"l\") +\n    scale_y_continuous(breaks = NULL) +\n    scale_fill_viridis_c(option = \"magma\") +\n    # add dendrogram for this heatmap\n    anno_top() +\n    align_dendro() +\n    # add a block for the heatmap column\n    ggalign(data = type, size = unit(1, \"cm\")) +\n    geom_tile(aes(y = 1, fill = factor(value))) +\n    scale_y_continuous(breaks = NULL, name = NULL) +\n    scale_fill_brewer(\n        palette = \"Set1\", name = \"type\",\n        guide = guide_legend(position = \"top\")\n    )\n\nheat2 &lt;- ggheatmap(base_mean, width = unit(2, \"cm\")) +\n    scale_y_continuous(breaks = NULL) +\n    scale_x_continuous(name = \"base mean\", breaks = FALSE) +\n    scale_fill_gradientn(colours = c(\"#2600D1FF\", \"white\", \"#EE3F3FFF\")) +\n    # set the active context of the heatmap to the top\n    # and set the size of the top stack\n    anno_top(size = unit(4, \"cm\")) +\n    # add box plot in the heatmap top\n    ggalign() +\n    geom_boxplot(aes(y = value, fill = factor(.extra_panel))) +\n    scale_x_continuous(expand = expansion(), breaks = NULL) +\n    scale_fill_brewer(\n        palette = \"Dark2\", name = \"base mean\",\n        guide = guide_legend(position = \"top\")\n    ) +\n    theme(axis.title.y = element_blank())\n\nheat3 &lt;- ggheatmap(expr$type, width = unit(2, \"cm\")) +\n    scale_fill_brewer(palette = \"Set3\", name = \"gene type\") +\n    scale_x_continuous(breaks = NULL, name = \"gene type\") +\n    # add barplot in the top annotation, and remove the spaces in the y-axis\n    anno_top() -\n    scheme_align(free_spaces = \"lr\") +\n    ggalign() +\n    geom_bar(\n        aes(.extra_panel, fill = factor(value)),\n        position = position_fill()\n    ) +\n    scale_y_continuous(expand = expansion()) +\n    scale_fill_brewer(palette = \"Set3\", name = \"gene type\", guide = \"none\") -\n    scheme_theme(plot.margin = margin())\n\nstack_alignh(mat_scaled) +\n    stack_active(sizes = c(0.2, 1, 1)) +\n    # group stack rows into 5 groups\n    align_kmeans(centers = 5L) +\n    # add a block plot for each group in the stack\n    ggalign(size = unit(1, \"cm\"), data = NULL) +\n    geom_tile(aes(x = 1, fill = factor(.panel))) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"Kmeans group\") +\n    scale_x_continuous(breaks = NULL, name = NULL) +\n    # add a heatmap plot in the stack\n    heat1 +\n    # add another heatmap in the stack\n    heat2 +\n    # we move into the stack layout\n    stack_active() +\n    # add a point plot\n    ggalign(data = expr$length, size = unit(2, \"cm\")) +\n    geom_point(aes(x = value)) +\n    labs(x = \"length\") +\n    theme(\n        panel.border = element_rect(fill = NA),\n        axis.text.x = element_text(angle = -60, hjust = 0)\n    ) +\n    # add another heatmap\n    heat3 &\n    theme(\n        plot.background = element_blank(),\n        panel.background = element_blank(),\n        legend.background = element_blank()\n    )\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>More examples</span>"
    ]
  },
  {
    "objectID": "complexheatmap-more-examples.html#the-measles-vaccine-heatmap",
    "href": "complexheatmap-more-examples.html#the-measles-vaccine-heatmap",
    "title": "17  More examples",
    "section": "17.2 The measles vaccine heatmap",
    "text": "17.2 The measles vaccine heatmap\n\nmat &lt;- read_example(\"measles.rds\")\nggheatmap(mat, filling = FALSE) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    scale_fill_gradientn(\n        colours = c(\"white\", \"cornflowerblue\", \"yellow\", \"red\"),\n        values = scales::rescale(c(0, 800, 1000, 127000), c(0, 1))\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right() +\n    align_dendro(plot_dendrogram = FALSE) +\n    anno_top(size = unit(2, \"cm\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(y = value), fill = \"#FFE200\", stat = \"identity\") +\n    scale_y_continuous(expand = expansion()) +\n    ggtitle(\"Measles cases in US states 1930-2001\\nVaccine introduced 1961\") +\n    theme(plot.title = element_text(hjust = 0.5)) +\n    anno_right(size = unit(2, \"cm\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(x = value),\n        fill = \"#FFE200\", stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    scale_x_continuous(expand = expansion()) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>More examples</span>"
    ]
  }
]