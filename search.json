[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggalign: Bridging the Grammar of Graphics and Complex layout",
    "section": "",
    "text": "Preface\nWelcome to ggalign documents. Examples in the book are generated under version 0.0.5.9000.\nIn the world of data visualization, aligning multiple plots in a coherent and organized layout is often a challenging task, especially when dealing with complex datasets that require precise alignment across rows, columns, and even within plot elements. While existing tools provide some solutions, they often fall short in offering the flexibility, control, and simplicity that users need to create intricate and beautiful plots. This is where ggalign comes in.\nThe ggalign package, built on top of the powerful ggplot2 framework, is designed to solve this very problem. It offers a suite of functions specifically crafted for aligning and organizing plots with minimal effort. Whether you need to align observations based on statistical measures, group plots by categorical factors, or fine-tune the layout to match the precise needs of your data, ggalign gives you the tools you need to create polished, publication-ready visualizations.\nThis book serves as both an introduction to the ggalign package and a comprehensive guide to mastering its features. Whether you’re a beginner or an experienced user of ggplot2, you’ll find detailed explanations, step-by-step tutorials, and real-world examples to help you leverage the full potential of ggalign in your work.\nThroughout this book, we will cover everything from basic concepts to advanced layout customizations, focusing on key functions like stack_layout(), align_* series (including align_group(), align_order(), and align_hclust()), and how to combine them with other ggplot2 layers to create aligned plots. Additionally, you’ll learn how to adapt ggalign for different data types and scenarios, allowing you to develop flexible, dynamic visualizations tailored to your specific needs.\nBy the end of this book, you will be equipped to use ggalign effectively in your own projects, whether for scientific research, data analysis, or any other field where data visualization is key. Our goal is to provide you with the knowledge and confidence to tackle complex visualization challenges and transform your datasets into clear, impactful, and visually appealing plots.\nThank you for choosing ggalign. We hope this book will inspire you to explore the endless possibilities that come with aligned data visualization.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Installation\nggalign extends ggplot2 by providing advanced tools for aligning and organizing multiple plots, particularly those that automatically reorder observations, such as dendrogram. It offers fine control over layout adjustment and plot annotations, enabling you to create complex visualizations while leveraging the familiar grammar of ggplot2.\nYou can install ggalign from CRAN using:\ninstall.packages(\"ggalign\")\nAlternatively, install the development version from r-universe with:\ninstall.packages(\"ggalign\",\n    repos = c(\"https://yunuuuu.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nor from GitHub with:\n# install.packages(\"remotes\")\nremotes::install_github(\"Yunuuuu/ggalign\")",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#general-design",
    "href": "introduction.html#general-design",
    "title": "1  Introduction",
    "section": "1.2 General design",
    "text": "1.2 General design\nThe core feature of ggalign lies in its integration of the grammar of graphics into advanced visualization through its object-oriented Layout system. The package provides two main Layout classes:\n\nthe StackLayout class: Put plots horizontally or vertically.\nthe QuadLayout class: Arranges plots in the four quadrants (top, left, bottom, right) around a main plot. This layout is ideal for designs that require supplementary plots or annotations surrounding a central figure.\n\nBoth Layout classes support the alignment of observations (ordinal variable). Observations refer to data points or samples, allowing for consistent alignment of corresponding data across multiple plots when using the same axis values. Depending on whether you want to align observations across multiple plots within the layout, the following variants are available:\nFor StackLayout:\n\nstack_align(): Align the observations along the stack.\nstack_free(): Does not align the observations.\n\nFor QuadLayout:\n\nquad_free/ggside: Never align observations.\nquad_alignh: Align observations in the horizontal direction.\nquad_alignv: Align observations in the vertical direction.\nquad_alignb: Align observations in both horizontal and vertical directions.\n\n\n\n\nGeneral design of ggalign",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#getting-started",
    "href": "introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.3 Getting Started",
    "text": "1.3 Getting Started\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n\nThe usage of ggalign is simple if you’re familiar with ggplot2 syntax, the typical workflow includes:\n\nInitialize the layout using:\n\n\nstack_layout(): Arrange Plots Horizontally or Vertically\n\ncross_align: Arrange Plots Crosswise Horizontally or Vertically\n\nquad_layout(): Arrange Plots in the Quad-Side of a main plot\n\nggheatmap(): Create a Complex Heatmap.\nggoncoplot(): Create OncoPrint Visualizations from Genetic Alteration Data\n\n\n\nCustomize the layout with:\n\n\nalign_group(): Group observations into panel with a group variable.\nalign_kmeans(): Group observations into panel by kmeans.\nalign_order(): Reorder layout observations based on statistical weights or by manually specifying the observation index.\nalign_hclust(): Reorder or group observations based on hierarchical clustering.\nalign_reorder: Reorder observations using an arbitrary statistical function.\n\n\nAdding plots with align_dendro(), ggalign() or ggfree(), and then layer additional ggplot2 elements such as geoms, stats, or scales.\n\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(56), nrow = 7)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\n\nEvery *_layout() function accepts default data, which will be inherited by all plots within the layout.\nHere’s a simple example:\n\n1stack_alignv(small_mat) +\n2    align_dendro() +\n3    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThis produces a simple dendrogram. By default, stack_alignv() removes the axis text on the axis used for aligning observations. This is because it’s often unclear which plot should display the axis text, as typically, we want it to appear in only one plot. However, you can easily use the theme() function to control where the axis text appears.\nInternally, align_dendro() will reorder the observations based on the dendrogram, and other plots in the layout will follow this ordering.\n\n1stack_alignv(small_mat) +\n2    align_dendro() +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.names, value), stat = \"identity\") +\n5    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThe data in the underlying ggplot object of ggalign() function contains at least following columns (more details will be introduced in the Section 5.1):\n\n.panel: the group panel for the aligned axis. It means x-axis for vertical stack layout, y-axis for horizontal stack layout.\n.x or .y: the x or y coordinates\n.names and .index: A factor of the names (only applicable when names exists) and an integer of index of the original data.\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\nIt is recommended to use .x/.y, or .names as the x/y mapping.\nalign_dendro() can also split the observations into groups.\n\n1stack_alignv(small_mat) +\n2    align_dendro(k = 3) +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.names, value, fill = .panel), stat = \"identity\") +\n5    scale_fill_brewer(palette = \"Dark2\", name = \"Group\") +\n6    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd fill mapping scale.\n\n6\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nOne common visualization associated with the dendrogram is the heatmap. You can use ggheatmap() to initialize a heatmap layout. When grouping the observations using align_dendro(k = 3), a special column named branch is added, which you can use to color the dendrogram tree.\n\n1ggheatmap(small_mat) +\n2    anno_left() +\n3    align_dendro(aes(color = branch), k = 3) +\n4    scale_fill_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\nWe initialize a heatmap layout.\n\n2\n\nwe initialize an annotation in the left side of the heatmap body, and set it as the active context, in this way, all following addition will be directed to the left annotation.\n\n3\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree, coloring the tree by branch.\n\n4\n\nAdd fill mapping scale.\n\n\n\n\n\n\n\n\n\n\n\nggheatmap() will automatically add axis text in the heatmap body, so you don’t need to manually adjust axis text visibility using theme(axis.text.x = element_text())/theme(axis.text.y = element_text()).\nHaving explored the core principles of ggalign, you should now be familiar with its basic workflow. In the next chapter, we’ll introduce the StackLayout functionality, a powerful tool for arranging multiple plots in a stacked fashion—either horizontally or vertically—while maintaining full control over their alignment. We’ll explore how stack_layout() and its various functions can give you even greater flexibility in creating sophisticated layouts.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "stack-layout.html",
    "href": "stack-layout.html",
    "title": "2  stack layout",
    "section": "",
    "text": "2.1 Input data\nstack_layout() arranges plots either horizontally or vertically, and we can also use the alias ggstack(). Based on whether we want to align the observations, there are two types of stack layouts:\nSeveral aliases are available for convenience:\nWhen aligning observations, we typically use a matrix, as it is easy to melt the matrix into a long-formatted data frame. Additionally, matrices are used to fit the observation concept, as they can be transposed (rows to columns, columns to rows), which is necessary for use in functions like quad_layout() and ggheatmap(), where observations may be aligned in both directions simultaneously.\nBy default, fortify_data_frame() will invoke the ggplot2::fortify() function for conversion. Note, for matrix, it will be converted to a long-formatted data frame.\nstack_align()/stack_free() will set up the layout, but no plot will be drawn until you add a plot element:\n1stack_alignh(small_mat) +\n2    layout_annotation(\n        theme = theme(plot.background = element_rect(color = \"red\"))\n    )\n# the same for `stack_free()`\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nAdd a plot background in for the entire layout.\nIn this example, we use layout_annotation() to insert a plot background in the entire layout, it can be also used to control the theme of title, subtitle, caption (layout_title()), guides, margins, panel.border.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-input-data",
    "href": "stack-layout.html#sec-stack-layout-input-data",
    "title": "2  stack layout",
    "section": "",
    "text": "For stack_free(), a data frame is required, and the input will be automatically converted using fortify_data_frame() if needed.\nFor stack_align(), a matrix is required, and the input will be automatically converted using fortify_matrix() if needed.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-layout-customize",
    "href": "stack-layout.html#sec-stack-layout-layout-customize",
    "title": "2  stack layout",
    "section": "2.2 Layout Customize",
    "text": "2.2 Layout Customize\nWhen we use stack_align(), it aligns the observations across multiple plots along the specified direction:\n\nFor stack_alignh(): Alignment occurs along the horizontal direction (y-axis).\nFor stack_alignv(): Alignment occurs along the vertical direction (x-axis).\n\nThe package offers a suite of align_* functions designed to give you precise control over the observations. These functions enable you to reorder the observations or partition the observations into multiple groups. Instead of detailing each align_* function individually, we will focus on the general usage and how to combine them with stack_align().\nHere, we remain take align_dendro() as an example, it can reorder the observations, split them into groups, and can add a plot for visualization.\nWhen used for stack_alignh(), the observations are aligned along the y-axis:\n\n1stack_alignh(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen used for stack_alignv(), the observations are aligned along the x-axis:\n\n1stack_alignv(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen align_dendro() is added to the layout, it performs following actions:\n\nreorder the observations.\nset the active plot to the dendrogram.\n\nThe active plot refers to the plot that subsequent ggplot2 components will target. In this case, the active plot is the dendrogram, and any new layers added will be applied to it. For instance, we can add additional layers to visualize the dendrogram’s structure or data. The default data underlying the ggplot object of align_dendro() consists of the dendrogram node data. It is also possible to use the dendrogram’s edge data for customization, which I will introduce in Section 5.4.\n\n1stack_alignh(small_mat) +\n2    align_dendro() +\n3    geom_point()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n3\n\nadd a point layer to the dendrogram\n\n\n\n\n\n\n\n\n\n\n\nThe active argument controls whether a plot should be set as the active plot. It accepts an active() object with the use argument to specify if the plot should be active when added.\n\n1stack_alignh(small_mat) +\n2    align_dendro(active = active(use = FALSE)) +\n3    geom_point()\n#&gt; Error in `stack_layout_add()`:\n#&gt; ! Cannot add `geom_point()` to `stack_align()`\n#&gt; ℹ No active plot component\n#&gt; ℹ Did you forget to initialize a &lt;ggplot&gt; object with `ggalign()` or\n#&gt;   `ggfree()`?\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, but don’t set the active plot to this plot.\n\n3\n\ntry to add a point layer to the dendrogram, should fail due to no active plot\n\n\n\n\nUsually, you don’t need to set this manually, as the active context is automatically applied only for functions that add plot areas. You can inspect whether a align_* function will add a plot by print it:\n\nalign_dendro()\n#&gt; `align_dendro()` object:\n#&gt;   plot: yes\n#&gt;   reorder: yes\n#&gt;   split: no\n\nYou might find it confusing that we mentioned align_dendro() will split observations into groups, while the print output shows split = \"no\". This happens because we haven’t specified the k/h argument in align_dendro().\n\nalign_dendro(k = 3L)\n#&gt; `align_dendro()` object:\n#&gt;   plot: yes\n#&gt;   reorder: yes\n#&gt;   split: yes\n\nYou don’t need to explicitly provide data to align_dendro(). By default, it inherits data from the layout. However, you can always provide another data source, but note that this package uses the concept of number of observations (NROW()). When aligning the observations, you must ensure the number of observations is consistent across all plots.\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = matrix(rnorm(56), nrow = 8)) +\n3    theme(axis.text.y = element_text())\n#&gt; Error in `align()`:\n#&gt; ! `align_dendro(data = matrix(rnorm(56), nrow = 8))` (nobs: 8) is not\n#&gt;   compatible with the `stack_align()` (nobs: 7)\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on hierarchical clustering, add a dendrogram tree, and set the active plot to this one, using self-provided data. This should fail because the number of observations is inconsistent.\n\n3\n\ntry to add y-axis text to the dendrogram.\n\n\n\n\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = matrix(rnorm(70), nrow = 7)) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot, using self-provided data\n\n3\n\nadd y-axis text to the dendrogram.\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can provide a function (or purrr-lambda) that will be applied to the layout’s matrix. For layouts that align observations, a matrix is always required, so the data input must be in matrix form.\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = ~ .x[sample(nrow(.x)), ]) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot, using self-provided data function\n\n3\n\nadd y-axis text to the dendrogram.\n\n\n\n\n\n\n\n\n\n\n\nWithout adding another plot, it’s difficult to appreciate the benefits. Let’s now explore how to incorporate a plot.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-initialize",
    "href": "stack-layout.html#sec-stack-layout-plot-initialize",
    "title": "2  stack layout",
    "section": "2.3 Plot initialize",
    "text": "2.3 Plot initialize\nThere are two primary functions for adding plots:\n\nalign_gg()/ggalign(): Create a ggplot object and align with the layout.\nfree_gg()/ggfree(): Create a ggplot object without aligning.\n\nBoth functions initialize a ggplot object and, by default, set the active plot when added to the layout.\nFor stack_align(), plots can be added regardless of whether they need to align observations.\n\n1stack_alignh(small_mat) +\n2    align_dendro() +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(value, .names), stat = \"identity\") +\n5    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n3\n\ninitialize a ggplot object, and set the active plot to this plot, using self-provided data function\n\n4\n\nadd a bar to the plot\n\n5\n\nadd y-axis text\n\n\n\n\n\n\n\n\n\n\n\nYou can build the plot separately and then add it to the layout:\n\nmy_bar &lt;- ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \nstack_alignh(small_mat) +\n    align_dendro() +\n    my_bar\n\n\n\n\n\n\n\n\nThe active argument can also control the place of the plot area to be added. It accepts an active() object with the order argument to specify the order of the plot area.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums, active = active(order = 1)) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can also stack plots vertically using stack_alignv():\n\nstack_alignv(small_mat) + \n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nstack_align() can also add plot without aligning observations. free_gg() focuses on layout integration without enforcing strict axis alignment. ggfree() is an alias for free_gg.\n\nstack_alignv() +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nThe & operator applies the added element to all plots in the layout, similar to its functionality in the patchwork package.\nFor stack_free(), only free plots (ggfree()) can be added. This layout arranges plots in one row or column without enforcing axis alignment:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nBy default, ggfree() will also inherit data from the layout and call fortify_data_frame() to convert the data to a data frame. So, note that if the layout data is a matrix, it will be converted into a long-formatted data frame.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-size",
    "href": "stack-layout.html#sec-stack-layout-plot-size",
    "title": "2  stack layout",
    "section": "2.4 Plot Size",
    "text": "2.4 Plot Size\nBoth ggalign() and ggfree() functions have a size argument to control the relative width (for horizontal stack layout) or height (for vertical stack layout) of the plot’s panel area.\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 2) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 1) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nAlternatively, you can define an absolute size by using a unit() object:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = unit(1, \"cm\")) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-active-plot",
    "href": "stack-layout.html#sec-stack-layout-active-plot",
    "title": "2  stack layout",
    "section": "2.5 active plot",
    "text": "2.5 active plot\nAs mentioned earlier, the active plot refers to the plot that subsequent ggplot2 components will target. The package provide two functions to work with active plot.\n\nstack_switch(): switch the active context\nstack_active(): An alias for stack_switch(), which sets what = NULL\n\nThe stack_switch() function accepts the what argument, which can either be the index of the plot added (based on its adding order) or the plot name specified via the active() object using the name argument.\nNote that the what argument must be explicitly named, as it is placed second in the function signature. This is because, in most cases, we don’t need to switch the active plot manually—adjusting the order of plot additions typically suffices.\n\n\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    stack_switch(what = 1) +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by integer\")\n\n\n\n\n\n\n\n\n\n\n\nstack_alignh(small_mat) +\n    align_dendro(active = active(name = \"tree\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    stack_switch(what = \"tree\") +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by string\")\n\n\n\n\n\n\n\n\n\n\nIn the example, we use layout_title() to insert a title for the entire layout. Alternatively, you can add a title to a single plot with ggtitle().\nBy setting what = NULL (or alias stack_active()), we remove the active plot. This is particularly useful when the active plot is a nested Layout object, as any additions would otherwise be directed to that nested Layout. By removing the active plot, you can continue adding components directly to the StackLayout.\nIn the next chapter, we will dive into the HeatmapLayout, which can take the StackLayout as input. Heatmap layouts offer additional features for aligning observations in both directions. Let’s move ahead and explore how heatmaps can be seamlessly integrated into your layout workflows.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html",
    "href": "heatmap-layout.html",
    "title": "3  heatmap layout",
    "section": "",
    "text": "3.1 input data\nThe heatmap_layout() function provides a powerful way to create customizable heatmaps in R using ggplot2. This chapter will guide you through its usage.\nheatmap_layout() is a specialized version of quad_alignb(), which itself is a specific variant of QuadLayout (quad_layout()) designed to align observations both horizontally and vertically. We introduce heatmap_layout() directly, as it is more familiar to many users, especially those experienced with popular heatmap packages like pheatmap and ComplexHeatmap.\nheatmap_layout() simplifies the creation of heatmap plots by integrating essential elements for a standard heatmap layout, ensuring that the appropriate data mapping and visualization layers are automatically applied. ggheatmap() is an alias for heatmap_layout().\nAs mentioned in Section 2.1, we typically require a matrix for the Layout which need align observations. Internally, fortify_matrix() will be used to process the data. You can provide a numeric or character vector, a data frame, or any other data type that can be converted into a matrix using as.matrix().\nggheatmap(small_mat)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#main-plot-heatmap-body",
    "href": "heatmap-layout.html#main-plot-heatmap-body",
    "title": "3  heatmap layout",
    "section": "3.2 Main plot (heatmap body)",
    "text": "3.2 Main plot (heatmap body)\nThe ggheatmap()/quad_layout() functions arrange plots in the Quad-Side layout of the main plot. When the layout is initialized, a ggplot object is automatically created for the main plot.\nFor ggheatmap(), the matrix input will be converted into a long-format data frame when drawing. The data in the underlying ggplot object includes the following columns:\n\n.xpanel and .ypanel: the column and row panel\n.x and .y: the x and y coordinates\n.row_names and .column_names: A factor of the row and column names of the original matrix (only applicable when names exist).\n.row_index and .column_index: the row and column index of the original matrix.\nvalue: the actual matrix value.\n\nThe default mapping will use aes(.data$.x, .data$.y), but can be customized using mapping argument.\nBy default, the main plot is regarded as the active plot, meaning you can add ggplot2 elements directly to the main plot.\n\nggheatmap(small_mat) + \n    geom_point() + \n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, ggheatmap() adds a heatmap layer. If the matrix has more than 20,000 cells (nrow * ncol &gt; 20000), it uses geom_raster() for performance efficiency; for smaller matrices, geom_tile() is used. You can explicitly choose the layer by providing a single string (\"raster\" or \"tile\") in the filling argument.\n\nggheatmap(small_mat, filling = \"raster\")\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = \"tile\")\n\n\n\n\n\n\n\n\nNote, the filling layer will always use mapping of aes(.data$.x, .data$.y), if you want to customize filling, you can set filling = NULL, which will remove the filling layer and allow you to add custom filling geoms.\n\nggheatmap(small_mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"black\", width = 0.9, height = 0.9)\n\n\n\n\n\n\n\n\nA heatmap pie charts can be easily drawn:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#rasterization",
    "href": "heatmap-layout.html#rasterization",
    "title": "3  heatmap layout",
    "section": "3.3 rasterization",
    "text": "3.3 rasterization\nWhen working with large heatmaps, it’s often beneficial to rasterize the heatmap body layer. You can achieve this by using the raster_magick() function. The res argument controls the resolution of the raster image. By default, the res argument matches the resolution of the current device, but specifying a different value can help reduce the resolution of the rasterized heatmap body.\n\nggheatmap(small_mat, filling = NULL) +\n    raster_magick(geom_tile(aes(fill = value)), res = 50)\n\n\n\n\n\n\n\n\nBy leveraging raster_magick(), you can also perform image post-processing using the magick package. This allows for custom image resizing with filters.\n\nggheatmap(small_mat, filling = NULL) +\n    # Use `magick::filter_types()` to check available `filter` arguments\n    raster_magick(geom_raster(aes(fill = value)),\n        magick = function(image) {\n            magick::image_resize(image,\n                # we resize to the 50% of width\n                geometry = \"50%x\", filter = \"Lanczos\"\n            )\n        }\n    )\n\n\n\n\n\n\n\n\nNote: When using magick::image_resize(), you should specify the geometry argument to resize the image. If only the filter is specified, it will only distort the image data (though subtle). For more information on image resizing, refer to ImageMagick’s resize documentation.\nYou can also rasterize all plots in the layout directly with raster_magick(). This method is defined for both ggheatmap()/quad_layout() and stack_layout() objects.\nAdditionally, You can use external packages like ggrastr or ggfx to rasterize the heatmap body.\n\nggheatmap(small_mat, filling = FALSE) +\n    ggrastr::rasterise(geom_tile(aes(fill = value)), dev = \"ragg\")\n\n\n\n\n\n\n\n\nLikewise, you can also rasterize all plots in the layout directly with ggrastr::rasterise() for both ggheatmap()/quad_layout() and stack_layout().\n\nggrastr::rasterise(ggheatmap(small_mat), dev = \"ragg\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFurthermore, ggfx offers many image filters that can be applied to ggplot2 layers. See the package for the details.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "href": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "title": "3  heatmap layout",
    "section": "3.4 annotations",
    "text": "3.4 annotations\nIn ggheatmap()/quad_layout(), annotations are handled by a stack_layout() object and can be positioned at the top, left, bottom, or right of the main plot (heatmap body).\nBy default, ggheatmap()/quad_layout() do not activate an annotation, You can use quad_anno() to activate an annotation, directing all subsequent additions to the specified annotation position. The quad_anno() function has the following aliases:\n\nanno_top: A special case of quad_anno() with position = \"top\".\nanno_left: A special case of quad_anno() with position = \"left\".\nanno_bottom: A special case of quad_anno() with position = \"bottom\".\nanno_right: A special case of quad_anno() with position = \"right\".\n\nWhen quad_anno() is added to a ggheatmap()/quad_layout(), it will try to automatically create a new stack_layout(). For top and bottom annotations, stack_alignv() or stack_freev() will be used; for left and right annotations, stack_alignh() or stack_freeh() will be applied.\nquad_anno() will always attempt to initialize a stack_layout() with the same alignment as the current direction. This means that if observations need to be aligned horizontally, stack_alignh() will be used for left and right annotations, otherwise, stack_freeh() will be initialized instead. The same logic applies for vertical alignment—stack_alignv() or stack_freev() will be applied for top and bottom annotations, depending on whether alignment is required. However, you can also manually add a stack_free() for directions that require alignment, which I’ll cover in the following section.\nAdditionally, quad_anno() will set the active context to the annotation. This means that subsequent additions will be directed to the annotation rather than the main plot. We use the term active context in contrast to active plot (as described in Section 2.2), since the annotation is a Layout object.\n\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the left annotation\n    anno_left() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, the annotation stack_layout() will try to inherit data from ggheatmap()/quad_layout(). If the observations require alignment vertically, this means the data from ggheatmap()/quad_layout() should be a matrix, the column annotations will also require a matrix and the matrix from ggheatmap()/quad_layout() will be transposed for use in the column annotations.\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can further customize the layout design or add new plots in the annotation stack, as described in Chapter 2.\n\nggheatmap(small_mat) +\n    # in the heatmap body, we set the axis text theme\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the right annotation\n    anno_right() +\n    # in the right annotation, we add a dendrogram\n    align_dendro(k = 3L) +\n    # in the dendrogram, we add a point layer\n    geom_point(aes(color = factor(branch)))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this example:\n\nanno_right() initialize the right annotation stack, and change the active context to the right of the heatmap.\nalign_dendro(k = 3L) adds a dendrogram to the annotation and sets itself as the active plot in the annotation stack.\ngeom_point(aes(color = factor(branch))) is then added to this active plot within the annotation stack, here, it means the align_dendro() plot.\n\nggheatmap() aligns observations both horizontally and vertically, so it’s safe to always use quad_anno() directly, as all annotations require a matrix, and the layout data is also a matrix. However, for quad_alignh() and quad_alignv() (which I’ll discuss in more detail in a Chapter 6), which only align observations in one direction, the data in the layout may not fit the data for the annotation (when the layout requires alignment of observations, we typically use a matrix, regardless of whether alignment is needed in one or two directions)\n- `quad_alignh()`: aligning observations in horizontal direction, for column\nannotations, we ll need a data frame for `stack_free()`.\n- `quad_alignv()`: aligning observations in vertical direction, for row\nannotations, we ll need a data frame for `stack_free()`.\nIn both cases, quad_anno() won’t initialize the annotation by default, instead, you must provide the annotation stack_layout() manually.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "href": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "title": "3  heatmap layout",
    "section": "3.5 Adding stack layout",
    "text": "3.5 Adding stack layout\nSimilar to adding a plot in stack_layout() (Chapter 2), when the direction requires alignment, you can add both stack_align() and stack_free(). However, if the direction does not require alignment, you can add only stack_free().\nTo add a stack_layout() to the ggheatmap(), we must prevent the automatical creation of annotation by quad_anno() by setting initialize = FALSE\n\n\n\nmy_stack_align &lt;- stack_alignh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_align +\n    layout_title(\"stack_align()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nmy_stack_free &lt;- stack_freeh(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_free +\n    layout_title(\"stack_free()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nNote when aligning the observations, you must ensure the number of observations is consistent in the direction. So for column annotations, you need transpose the data manually.\n\nmy_stack &lt;- stack_alignv(t(small_mat)) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    anno_top(initialize = FALSE) +\n    my_stack\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_active",
    "href": "heatmap-layout.html#quad_active",
    "title": "3  heatmap layout",
    "section": "3.6 quad_active()",
    "text": "3.6 quad_active()\nTo remove the active context and redirect additions back to the heatmap body, you can use quad_active().\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_active() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_switchhmanno",
    "href": "heatmap-layout.html#quad_switchhmanno",
    "title": "3  heatmap layout",
    "section": "3.7 quad_switch()/hmanno()",
    "text": "3.7 quad_switch()/hmanno()\nWe also provide quad_switch()/hmanno() (heatmap annotation) which integrates quad_active() and quad_anno() into one function for ease of use. Feel free to use any of these functions to streamline your annotation process.\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    quad_switch(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_switch() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c() +\n    layout_title(\"quad_switch()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    hmanno(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    hmanno() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()+\n    layout_title(\"hmanno()\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#plot-size",
    "href": "heatmap-layout.html#plot-size",
    "title": "3  heatmap layout",
    "section": "3.8 Plot Size",
    "text": "3.8 Plot Size\n\n3.8.1 Heatmap Body Size\nYou can specify the relative sizes of the heatmap body using the width and height arguments in the ggheatmap() function.\n\nggheatmap(small_mat, height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAlternatively, the quad_active() function allows you to control the heatmap body sizes.\n\nggheatmap(small_mat) +\n    quad_active(height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n3.8.2 Annotation Stack Size\nThe quad_anno() function allows you to control the total annotation stack size. The size argument controls the relative width (for left and right annotations) or height (for top and bottom annotations) of the whole annotation stack.\n\nggheatmap(small_mat) +\n    anno_top(size = 1) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also specify it as an absolute size using unit():\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that the size of an individual plot (Section 2.4) does not affect the total annotation stack size. You must adjust the annotation size using the method described above.\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(size = unit(30, \"mm\")) +\n    layout_title(\"plot size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    layout_title(\"annotation size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nIn this chapter, we explored the usage of heatmap layout. These features provide a strong foundation for visualizing matrix-based data in a structured way. However, as your visualization needs grow more complex, the ability to further customize and fine-tune the layout becomes essential.\nIn the next chapter, we will dive into the Layout Customize functionalities, where you can gain full control over your plot’s layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "layout-customize.html",
    "href": "layout-customize.html",
    "title": "4  Layout customize",
    "section": "",
    "text": "4.1 align_group()\nFor layouts that can align observations, the package provides a suite of align_* functions designed to give you precise control over the observations. These functions allow you to reorder observations or partition them into multiple groups.\nCurrently, there are four key align_* functions available for layout customization:\nNote that these functions do not add plot areas and set the active context, meaning you cannot incorporate ggplot2 elements directly into these objects. You can inspect the behavior of any align_* function by printing it.\nThe align_group() function allows you to split the observations into groups.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\nNote that all align_* functions which split observations into groups must not break the previous established groups. This means the new groups must nest in the old groups, usually they cannot be used if groups already exist.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE)) +\n    align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n#&gt; Error in `align()`:\n#&gt; ! align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n#&gt;   disrupt the previously established panel groups of the top annotation\n#&gt;   `stack_align()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_order",
    "href": "layout-customize.html#align_order",
    "title": "4  Layout customize",
    "section": "4.2 align_order()",
    "text": "4.2 align_order()\nThe align_order() function reorder the observations based on the summary weights.\nIn this example, we order the rows based on their means. By default, the ordering is in ascending order according to the summary weights. You can reverse the order by setting reverse = TRUE.\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans) +\n    layout_title(title = \"reverse = FALSE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans, reverse = TRUE) +\n    layout_title(title = \"reverse = TRUE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nAdditionally, you can provide the ordering integer index or character index directly:\n\nset.seed(1234)\nmy_order &lt;- sample(nrow(small_mat))\nprint(rownames(small_mat)[my_order])\n#&gt; [1] \"row4\" \"row2\" \"row5\" \"row7\" \"row3\" \"row1\" \"row6\"\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(my_order)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rownames(small_mat)[my_order])\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nSome align_* functions also accept a data argument. It’s important to note that all align_* functions treat rows as the observations. This means NROW(data) must match the number of observations along the axis used for alignment. The data argument can also accept a function (supporting purrr-like lambda syntax), which will be applied to the layout matrix.\nAs mentioned in Section 3.4, for top and bottom annotations, the data matrix of quad_layout()/ggheatmap() is transposed to create the annotation stack_layout(). Therefore, you can use rowMeans() to calculate the mean value across all columns.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSome align_* functions that reorder observations include an argument called strict. This argument is especially useful when previous groups have already been established. If previous groups have been created and strict = FALSE, the function will reorder the observations within each group.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))+\n    align_order(rowMeans, strict = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that we always prevent reordering the observations into two different orderings. If you want to apply two different orderings, you should use cross_layout() instead, which I’ll introduce in a later chapter:\n\nset.seed(1234)\nanother_order &lt;- sample(ncol(small_mat))\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans) +\n    align_order(another_order)\n#&gt; Error in `align()`:\n#&gt; ! align_order(another_order) disrupt the previously established ordering\n#&gt;   index of the top annotation `stack_align()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_kmeans",
    "href": "layout-customize.html#align_kmeans",
    "title": "4  Layout customize",
    "section": "4.3 align_kmeans()",
    "text": "4.3 align_kmeans()\nThe align_kmeans() function split the observations into groups based on k-means clustering.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#sec-align_hclust",
    "href": "layout-customize.html#sec-align_hclust",
    "title": "4  Layout customize",
    "section": "4.4 align_hclust()",
    "text": "4.4 align_hclust()\nThe align_hclust() function is designed to reorder observations and group them based on hierarchical clustering. Unlike align_dendro(), however, align_hclust() does not add a dendrogram tree to the plot. All the arguments intruduced here can also be used by align_dendro().\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nHierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. You can use the distance and method argument to control the builind process.\nThere are two ways to specify distance metric for clustering:\n\nspecify distance as a pre-defined option. The valid values are the supported methods in dist() function and coorelation coefficient \"pearson\", \"spearman\" and \"kendall\". The correlation distance is defined as 1 - cor(x, y, method = distance).\na self-defined function which calculates distance from a matrix. The function should only contain one argument.\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = \"pearson\") +\n    layout_title(\"pre-defined distance method (1 - pearson)\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = function(m) dist(m)) +\n    layout_title(\"a function that calculates distance matrix\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method. Possible methods are those supported in hclust() function. And you can also provide a self-defined function, which accepts the distance object and return a hclust object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(method = \"ward.D2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can specify k or h to split observations into groups, which work similarly to cutree():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can reorder the dendrogram based on the mean values of the observations by setting reorder_dendrogram = TRUE.\n\nh1 &lt;- ggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3, reorder_dendrogram = TRUE) +\n    layout_title(\"reorder_dendrogram = TRUE\")\nh2 &lt;- ggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3) +\n    layout_title(\"reorder_dendrogram = FALSE\")\nalign_plots(h1, h2)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this example, we use align_plots() to arrange the layouts, which functions similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, unlike those, align_plots() can be directly used with quad_layout() and stack_layout(), ensuring proper alignment by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, though they won’t align by panel area in the same way as ggplot2 plots.\nalign_hclust() can also perform clustering between groups, meaning it can be used even if there are existing groups present in the layout, in this way, you cannot specify k or h:\n\nset.seed(3L)\ncolumn_groups &lt;- sample(letters[1:3], ncol(small_mat), replace = TRUE)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can reorder the groups by setting reorder_group = TRUE, which reorders the hierarchical clusters based on the group tree:\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(reorder_group = TRUE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIf you specify k or h, this will always turn off sub-clustering. The same principle applies to align_hclust(), where new groups must be nested within the previously established groups.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(k = 2L)\n#&gt; Error in `align()`:\n#&gt; ! align_hclust(k = 2L) disrupt the previously established panel groups\n#&gt;   of the top annotation `stack_align()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_reorder",
    "href": "layout-customize.html#align_reorder",
    "title": "4  Layout customize",
    "section": "4.5 align_reorder()",
    "text": "4.5 align_reorder()\nThe align_reorder() function enables the reordering of observations based on a specified statistical function. This function accepts a data argument and computes a statistic that determines the new ordering of the observations. The resulting order is extracted using the order2() function.\nFoe example, you can also use hierarchical clustering to reorder the observations like this:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_reorder(hclust2)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nHere, hclust2() is a special function used by align_hclust() to calculate the distance matrix and perform hierarchical clustering.\nIn addition to hierarchical clustering, the align_reorder() function can also handle objects from the seriation package. For example, you can use the seriate() function with a method like \"BEA_TSP\" to reorder the observations based on a specific seriation algorithm:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\", data = abs)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThis approach gives you the flexibility to apply different statistical or algorithmic methods for reordering observations, which can be especially useful for exploring complex patterns in data.\nWith the align_* functions in place, we’ve covered how to reorder and group observations within a heatmap layout. Now, having set the stage for proper observation alignment, we can move on to the next essential step: plot initialize. In the following chapter, we’ll dive deeper into how to set up your plots within the layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html",
    "href": "plot-initialize.html",
    "title": "5  Plot initialize",
    "section": "",
    "text": "5.1 align_gg()/ggalign()\nThere are three primary functions for adding plots:\nggalign() and ggfree() are aliases for align_gg() and free_gg(), respectively. All three functions will set the active plot when added to the layout.\nBoth ggalign() and align_dendro() can only be used with a stack_layout() that aligns observations (stack_align()), whereas ggfree() can be added to a stack_layout() that does not align the observations (stack_free()).\nggalign() is similar to ggplot in that it initializes a ggplot data and mapping. ggalign() allowing you to provide data in various formats, including matrices, data frames, or simple vectors. By default, it will inherit from the layout. If a function, it will apply with the layout matrix.\nggalign() always applies a default mapping for the axis of the data index in the layout. This mapping is aes(y = .data$.y) for horizontal stacking (including left and right quad layout annotation) and aes(x = .data$.x) for vertical stacking (including top and bottom quad layout annotation).\nThe data in the underlying ggplot object will contain following columns:\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = rowSums) +\n    geom_point(aes(y = value))\n#&gt; → heatmap built with `geom_tile()`\nIn the case where the input data is already a data frame, following columns (.x/.y, .names, .index, and .panel) will be added to the data frame if applicable. Note, NROW(data) must match the number of observations along the axis used for alignment.\nmy_df &lt;- mtcars[seq_len(ncol(small_mat)), ]\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = my_df) +\n    geom_point(aes(y = cyl))\n#&gt; → heatmap built with `geom_tile()`\nYou may wonder if the strict data requirements will prevent us from preparing the data for plotting. Don’t worry! In the later chapters, I’ll introduce powerful way to prepare data for your plots.\nIf data = NULL, the data in the underlying ggplot object contains following columns:\nYou can use it to integrate additional elements, such as block annotation or customized panel title, into your layout.\nggheatmap(small_mat) +\n    anno_top(size = unit(1, \"cm\")) +\n    align_kmeans(centers = 3L) +\n    ggalign(data = NULL) +\n    geom_tile(aes(y = 1L, fill = .panel, color = .panel))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#sec-ggalign",
    "href": "plot-initialize.html#sec-ggalign",
    "title": "5  Plot initialize",
    "section": "",
    "text": ".panel: the panel for the aligned axis. It means x-axis for vertical stack layout (including top and bottom annotation), y-axis for horizontal stack layout (including left and right annotation).\n.x or .y: the x or y coordinates.\n.names and .index: A factor of the names (only applicable when names exists) and an integer of index of the original data.\n.row_names and .row_index: the row names and an integer of row index of the original matrix (only applicable if data is a matrix).\n.column_names and .column_index: the column names and column index of the original matrix (only applicable if data is a matrix).\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\n\nIt is recommended to use .x/.y, or .names as the x/y mapping.\n\n\n\n\n\n\n\n.panel: the panel for the axis used for alignment.\n.index: the index of the original layout data.\n.x or .y: the x or y coordinates\n\n\n\n\n5.1.1 Cross panel sumamry\nWhen used in a quad_layout(), and the data is inherited from the quad_layout(), a special column .extra_panel will be added if applicable, which is the panel information for column (for left or right annotation) or row (for top or bottom annotation). This is useful if you want to create summary plot using another axis panel groups. In such cases, it’s often necessary to disable the automatic setting of limits (limits = FALSE in ggalign()).\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_right() +\n    align_kmeans(2) +\n    anno_top(size = 0.5) +\n    ggalign(limits = FALSE) +\n    geom_boxplot(aes(.extra_panel, value, fill = .extra_panel)) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"row groups\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThis approach replicates the functionality of ComplexHeatmap::anno_summary(), but is versatile enough to be used with any heatmap, not just single-column or single-row heatmaps.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#free_ggggfree",
    "href": "plot-initialize.html#free_ggggfree",
    "title": "5  Plot initialize",
    "section": "5.2 free_gg()/ggfree()",
    "text": "5.2 free_gg()/ggfree()\nThe ggfree() function allows you to incorporate a ggplot object into your layout. Unlike align_gg(), which aligns every axis value precisely, free_gg() focuses on layout integration without enforcing strict axis alignment.\nInternally, the function uses fortify_data_frame() to transform the input into a data frame. For matrices, it converts them into a long-formatted data frame. Note that ggfree() does not provide a default aesthetic mapping, which contrasts with ggalign(). You will need to manually provide the default mappings.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAlternatively, you can directly input the ggplot object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(ggplot(mtcars, aes(wt, mpg))) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also add the ggplot object directly without using ggfree(). However, doing so will limit control over the plot (like plot area size, and active components):\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggplot(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#ggwrap-and-inset",
    "href": "plot-initialize.html#ggwrap-and-inset",
    "title": "5  Plot initialize",
    "section": "5.3 ggwrap() and inset()",
    "text": "5.3 ggwrap() and inset()\nThe ggwrap() function allows you to wrap objects that can be converted into a grob, turning them into a ggplot for plotting. Further you can still add ggplot elements like title, subtitle, tag, caption, and geoms using the same approach as with normal ggplots (using ggtitle(), labs(), geom_*()) as well as styling using theme(). This enables you to pass these wrapped objects into ggfree().\n\nlibrary(grid)\nggheatmap(small_mat) +\n    anno_top() +\n    # `ggwrap()` will create a `ggplot` object, we use `ggfree` to add it into the layout\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also integrate base plots, pheatmap, ComplexHeatmap, e.g.\nAdditionally, you can add any graphics as a inset to a ggplot using the inset() function. Like ggwrap(), inset() can accept any object that can be converted to a grob.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\")) +\n    # we can then add any inset grobs (the same as ggwrap, it can take any objects\n    # which can be converted to a `grob`)\n    inset(rectGrob(gp = gpar(fill = \"steelblue\")), align = \"panel\") +\n    inset(textGrob(\"Here are some text\", gp = gpar(color = \"black\")),\n        align = \"panel\"\n    )\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#sec-align-dendro",
    "href": "plot-initialize.html#sec-align-dendro",
    "title": "5  Plot initialize",
    "section": "5.4 align_dendro()",
    "text": "5.4 align_dendro()\nalign_dendro() is an extension of align_hclust() that adds a dendrogram to the layout. All functions of align_hclust() introduced in Section 4.4 can be used with align_dendro(). Here, we focus on the plot-related function.\nalign_dendro() will initialize a ggplot object, the data underlying the ggplot object contains the dendrogram node data with dendrogram edge data attached in a special attribute.\ndendrogram node and edge contains following columns: - index: the original index in the tree for the current node - label: node label text - x and y: x-axis and y-axis coordinates for current node or the start node of the current edge. - xend and yend: the x-axis and y-axis coordinates of the terminal node for current edge. - branch: which branch current node or edge is. You can use this column to color different groups. - leaf: A logical value indicates whether current node is a leaf.\nBy default, plot_dendrogram is set to TRUE, meaning a geom_segment() layer will be added using the dendrogram edge data when drawing. Note that this layer is always added to the first.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can choose between two dendrogram types: \"rectangle\" (default) and \"triangle\". However, if there are any groups in the stack, \"rectangle\" will be used.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(type = \"triangle\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also manually add the dendrogram tree using the edge data by setting plot_dendrogram = FALSE. In this case, you can access the dendrogram edge data with ggalign_attr(). The edge data is stored in the edge field of ggalign_attr():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro() +\n    geom_segment(\n        aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend),\n        data = function(x) ggalign_attr(x, \"edge\")\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen there are multiple groups, a branch column will be available. This can be used to color the nodes or edges based on the group source.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nalign_dendro() will draw dendrogram tree in each group when previous group exists.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can merge the sub-tree by settting merge_dendrogram = TRUE.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch), merge_dendrogram = TRUE)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#plot-titles",
    "href": "plot-initialize.html#plot-titles",
    "title": "5  Plot initialize",
    "section": "5.5 Plot titles",
    "text": "5.5 Plot titles\nggplot2 only allow add titles in the top or add caption in the bottom. we extends this capability, allowing you to place titles around any border of the plot using the patch_titles() function.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe appearance and alignment of these patch titles can be customized using ggplot2::theme(): - plot.patch_title/plot.patch_title.*: Controls the text appearance of patch titles. By default, plot.patch_title inherit from plot.title, and settings for each border will inherit from plot.patch_title, with the exception of the angle property, which is not inherited. - plot.patch_title.position/plot.patch_title.position.*: Determines the alignment of the patch titles. By default, plot.patch_title.position inherit from plot.title.position, and settings for each border will inherit from plot.patch_title. The value \"panel\" aligns the patch titles with the plot panels. Setting this to \"plot\" aligns the patch title with the entire plot (excluding margins and plot tags).\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    ) +\n    theme(\n        plot.patch_title.position = \"plot\",\n        plot.patch_title = element_text(hjust = 0)\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNow, let’s move on to the next chapter, where we will introduce quad_layout() in full. While we’ve already introduced ggheatmap()—a specialized version of quad_layout()—most of the operations discussed in Chapter 3 can also be applied to quad_layout(). In the next section, we’ll delve into quad_layout() and explore its full functionality.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "quad-layout.html",
    "href": "quad-layout.html",
    "title": "6  quad-layout",
    "section": "",
    "text": "6.1 introduction\nquad_layout() arranges plots in the Quad-Side of a main plot.\nDepending on whether you want to align observations in the horizontal or vertical direction, there are four main types of quad_layout():\nWhen the layout requires alignment of observations, we typically use a matrix, regardless of whether alignment is needed in one or two directions.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#introduction",
    "href": "quad-layout.html#introduction",
    "title": "6  quad-layout",
    "section": "",
    "text": "Alignment of Observations\nhorizontal\nvertical\nData Format\n\n\n\n\nquad_free()/ggside()\n❌\n❌\ndata frame\n\n\nquad_alignh()\n✅\n❌\nmatrix\n\n\nquad_alignv()\n❌\n✅\nmatrix\n\n\nquad_alignb()/ggheatmap()\n✅\n✅\nmatrix\n\n\n\n\n\nFor data frame, the input will be automatically converted using fortify_data_frame() if needed.\nFor matrix, the input will be automatically converted using fortify_matrix() if required.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#annotations",
    "href": "quad-layout.html#annotations",
    "title": "6  quad-layout",
    "section": "6.2 Annotations",
    "text": "6.2 Annotations\nAnnotation is typically handled using a stack_layout(). Depending on whether you want to align observations in the specified direction, different stack_layout() are compatible (Section 3.5). Below is a table outlining the compatibility of various layout types for annotations:\n\n\n\n\n\n\n\n\nAnnotations\nleft and right\ntop and bottom\n\n\n\n\nquad_free()/ggside()\nstack_freeh()\nstack_freev()\n\n\nquad_alignh()\nstack_freeh()/stack_alignh()\nstack_freev()\n\n\nquad_alignv()\nstack_freeh()\nstack_freev()/stack_alignv()\n\n\nquad_alignb()/ggheatmap()\nstack_freeh()/stack_alignh()\nstack_freev()/stack_alignv()",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_alignb",
    "href": "quad-layout.html#quad_alignb",
    "title": "6  quad-layout",
    "section": "6.3 quad_alignb()",
    "text": "6.3 quad_alignb()\nquad_alignb() aligns observations in both horizontal and vertical directions. It serves as the base version of ggheatmap()/heatmap_layout() and does not automatically add default layers or mappings.\nThe underlying ggplot data of the main plot is the same with ggheatmap()/heatmap_layout(), it is recommended to use .y, or .row_names as the y mapping and use .x or .column_names as the x mapping in the main plot.\n\nquad_alignb(small_mat, aes(.x, .y)) +\n    geom_tile(aes(fill = value)) +\n    scale_fill_viridis_c()",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_alignhquad_alignv",
    "href": "quad-layout.html#quad_alignhquad_alignv",
    "title": "6  quad-layout",
    "section": "6.4 quad_alignh()/quad_alignv()",
    "text": "6.4 quad_alignh()/quad_alignv()\nquad_alignh() aligns observations horizontally, while quad_alignv() aligns observations vertically.\nThe underlying ggplot data is the same with ggheatmap()/heatmap_layout(), it is recommended to use .y, or .row_names as the y mapping in the main plot for quad_alignh() but use .x or .column_names as the x mapping in the main plot for quad_alignv().\n\n\n\nquad_alignh(small_mat) +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquad_alignv(small_mat) +\n    geom_boxplot(aes(.column_names, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\n\nAs discussed in Section 3.4, quad_anno() will always attempt to initialize a stack_layout() with the same alignment as the current direction. For top and bottom annotations in quad_alignh(), and left and right annotations in quad_alignv(), quad_anno() will not initialize the annotation due to inconsistent data types.\n\nquadh &lt;- quad_alignh(small_mat) +\n    anno_top()\n#&gt; Warning: `data` in `quad_alignh()` is a double matrix, but the top annotation stack need\n#&gt; a &lt;data.frame&gt;, won't initialize the top annotation stack\nquadv &lt;- quad_alignv(small_mat) +\n    anno_left()\n#&gt; Warning: `data` in `quad_alignv()` is a double matrix, but the left annotation stack\n#&gt; need a &lt;data.frame&gt;, won't initialize the left annotation stack\n\nManual adding of a stack_layout() is required in such cases, you can set initialize = FALSE to prevent the warning message.\n\nquadh &lt;- quad_alignh(small_mat) +\n    anno_top(initialize = FALSE)\nquadv &lt;- quad_alignv(small_mat) +\n    anno_left(initialize = FALSE)\n\n\n\n\nquadh +\n    stack_freev(mpg) +\n    # add a plot in the top annotation\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquadv +\n    stack_freeh(data = mpg) +\n    # add a plot in the top annotation\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(.column_names, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can set initialize = TRUE, which will initialize the annotation stack layout with no data. In this case, you must provide data in each plot within the annotation.\n\n\n\nquad_alignh(small_mat) +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_top(initialize = TRUE) +\n    ggfree(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquad_alignv(small_mat) +\n    geom_boxplot(aes(.column_names, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_left(initialize = TRUE) +\n    ggfree(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignv()\")",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_free",
    "href": "quad-layout.html#quad_free",
    "title": "6  quad-layout",
    "section": "6.5 quad_free()",
    "text": "6.5 quad_free()\nquad_free() does not align observations and is functionally equivalent to the ggside package. For convenience, ggside() is provided as an alias for quad_free(). This layout is particularly useful for adding metadata or summary graphics along a continuous axis.\n\nggside(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    # initialize top annotation\n    anno_top(size = 0.3) +\n    # add a plot in the top annotation\n    ggfree() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    # initialize right annotation\n    anno_right(size = 0.3) +\n    # add a plot in the right annotation\n    ggfree() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    ) &\n    theme_bw()\n\n\n\n\n\n\n\n\nggside() allows facetting for the main plot, which should also be applied to the annotations for proper alignment.\n\ni2 &lt;- iris\ni2$Species2 &lt;- rep(c(\"A\", \"B\"), 75)\nggside(i2, aes(Sepal.Width, Sepal.Length, color = Species)) +\n    geom_point(size = 2) +\n    facet_grid(Species ~ Species2) +\n    anno_top(size = 0.3) +\n    ggfree() +\n    geom_density(aes(Sepal.Width, y = after_stat(density), colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(cols = vars(Species2)) +\n    anno_right(size = 0.3) +\n    ggfree() +\n    geom_density(aes(x = after_stat(density), Sepal.Length, colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(rows = vars(Species)) &\n    theme_bw()\n\n\n\n\n\n\n\n\nIf an annotation contains multiple plots, it can be tedious to add the same element to each one individually. One way to simplify this is by creating an external stack_layout() and adding the desired elements using the & operator. Then, you can add this stack_layout() to the quad_layout(). In a later chapter, I will introduce another operator that seamlessly combines with the + operator, allowing you to add elements to multiple plots at once.\nIn the next chapter, we will explore even more advanced techniques for combining multiple quad_layout()s. These methods will provide you with the tools to manage more complex plot arrangements and make your visualizations even more flexible and powerful.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html",
    "href": "multiple-quad-layouts.html",
    "title": "7  A list of quad_layout()",
    "section": "",
    "text": "7.1 stack_align()\nSimilarly, stack_layout() can be added to a quad_layout(), and a quad_layout() can also be added to a stack_layout().\nAs discussed in Section 2.3, stack_align() can accept plots regardless of whether alignment of observations is required.\nstack_alignh(small_mat) +\n    ggheatmap() +\n    theme(axis.text.x = element_text(hjust = -60, angle = -90)) +\n    ggheatmap() +\n    theme(axis.text.x = element_text(hjust = -60, angle = -90))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nWhen ggheatmap()/quad_layout() is added to a stack_layout(), it will also set the active context to itself, which means subsequent addition will be directed to ggheatmap()/quad_layout(). One exception is the ggheatmap()/quad_layout() itself, which cannot be added to another quad_layout(). In this case, they will be added directly to the stack_layout().\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nThe data of ggheatmap()/quad_layout() can inherit from the stack_layout(), but the data format must match. Otherwise, you will need to manually provide the data. For stack_align(), the data is always expected to be a matrix, if you try to add a ggside() (which uses a data frame), it will result in an error.\nstack_alignh(small_mat) +\n    ggside()\n#&gt; Error in `stack_layout_add()`:\n#&gt; ! Cannot add `quad_free()` to `stack_align()`\n#&gt; ℹ `data` in `stack_align()` is a double matrix, but `quad_free()` need a\n#&gt;   &lt;data.frame&gt;.\n#&gt; ℹ Try provide `data` in `quad_free()`\nWhen ggheatmap()/quad_layout() is added to a vertical stack_align(), the inherited matrix is transposed before use. This is because the columns of ggheatmap()/quad_layout() must match the number of observations in stack_align().\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nstack_align() ensures that all plots aligned along the stack have the same ordering index or groups for the observations. Here’s a table summarizing which quad_layout() will be aligned in stack_align().\nWe can customize the layout in the stack_align() directly, or in quad_layout(). As introduced in Section 2.5, you can easily switch from the ggheatmap()/quad_layout() to the stack_layout() using stack_active().\nWhen applied to a stack_layout(), the orientation of the dendrogram may need to be manually adjusted.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#stack_align",
    "href": "multiple-quad-layouts.html#stack_align",
    "title": "7  A list of quad_layout()",
    "section": "",
    "text": "stack_alignh()\nstack_alignv()\n\n\n\n\nquad_free()/ggside()\n❌\n❌\n\n\nquad_alignh()\n✅\n❌\n\n\nquad_alignv()\n❌\n✅\n\n\nquad_alignb()/ggheatmap()\n✅\n✅\n\n\n\n\n\n\n\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3)+\n    layout_title(\"dendrogram in ggheatmap()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    stack_active() +\n    align_dendro(aes(color = branch), k = 3, size = 0.2) +\n    scale_y_reverse() +\n    layout_title(\"dendrogram in stack_layout()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#stack_free",
    "href": "multiple-quad-layouts.html#stack_free",
    "title": "7  A list of quad_layout()",
    "section": "7.2 stack_free()",
    "text": "7.2 stack_free()\nHowever, stack_free() is designed to only accept plots that are not aligned along the axis (Section 2.3). Below is a table summarizing which quad_layout() are compatible with stack_free():\n\n\n\n\nstack_freeh()\nstack_freev()\n\n\n\n\nquad_free()/ggside()\n✅\n✅\n\n\nquad_alignh()\n❌\n✅\n\n\nquad_alignv()\n✅\n❌\n\n\nquad_alignb()/ggheatmap()\n❌\n❌\n\n\n\n\nalignh_quad_plot &lt;- quad_alignh(small_mat) +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")\nstack_freev() +\n    alignh_quad_plot +\n    alignh_quad_plot",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#control-sizes",
    "href": "multiple-quad-layouts.html#control-sizes",
    "title": "7  A list of quad_layout()",
    "section": "7.3 Control sizes",
    "text": "7.3 Control sizes\nA numeric or a unit object of length 3 should be provided in stack_align()/stack_free() when placing a quad_layout(). For vertical stack_layout(), this means quad_layout() with left or right annotations; for horizontal stack_layout(), this means quad_layout() with top or bottom annotations. The first size controls the relative width/height of the left or top annotation, the second controls the relative width/height of the main plot, and the third controls the relative width/height of the right or bottom annotation.\nBy default the three rows/columns will have equal sizes.\n\nstack_alignv(small_mat) +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nheat1 &lt;- ggheatmap(t(small_mat)) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\")\n\nstack_alignv(small_mat, sizes = c(1, 2, 1)) +\n    heat1 +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this way, the width/height of main plot specified in quad_active() or quad_layout()/ggheatmap() won’t work.\n\nstack_alignv(small_mat) +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNext, we will build on these concepts and explore even more advanced strategies for integrating elements across multiple plots or annotations in a layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "operator.html",
    "href": "operator.html",
    "title": "8  Operators",
    "section": "",
    "text": "8.1 Addition operator\nIn ggalign, operators are used to manage and manipulate the plot elements in various layouts. These operators help you build complex visualizations by adding, modifying, or removing elements across multiple plots or annotations in a layout. You may be familiar with the + and & operators, this section will expand on their usage, as well as introduce the subtraction operator (-) and how to apply it in different contexts.\nThe + operator is straightforward and should be used as needed.\nIn stack_layout(), a nested layout will only occur if you pass a quad_layout() into stack_layout() (Chapter 7). If the active context in the stack_layout() is quad_layout(), this quad_layout() is treated as the active layout, and the + operator will add elements to it, following the same principles as in quad_layout(). Otherwise, the stack_layout() itself is treated as the active layout, and the + operator will add elements directly to this plot.\nstack_alignh(small_mat) +\n    align_dendro() +\n    geom_point() +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\nIn quad_layout(), four nested layouts are available for annotations: top, left, bottom, and right. If no active annotation is set, quad_layout() treat itself as the active layout. Since there is only one main plot in the quad_layout(), the main plot is always treated as the active plot in this context. Otherwise, the active annotation is treated as the active layout, and the + operator will add elements to it, following the same principles as in stack_layout().\nggheatmap(small_mat) +\n    scale_fill_viridis_c() +\n    anno_left(size = 0.2) +\n    align_dendro() +\n    anno_right(size = 0.2) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#addition-operator",
    "href": "operator.html#addition-operator",
    "title": "8  Operators",
    "section": "",
    "text": "+: adds elements to the active plot in the active layout.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#logical-and-operator",
    "href": "operator.html#logical-and-operator",
    "title": "8  Operators",
    "section": "8.2 logical AND operator",
    "text": "8.2 logical AND operator\n\n&: applies elements to all plots in the layout including plots in the nested layout.\n\nThe & operator works similarly to patchwork, applying an element across all plots in a layout. Since & has lower precedence than +, it’s generally best to use it at the end of an expression or you should wrap it in parentheses when needed.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    # Add a dendrogram in the left annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    # Add a dendrogram in the right annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) &\n    # Set color scale for all plots\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#subtraction-operator",
    "href": "operator.html#subtraction-operator",
    "title": "8  Operators",
    "section": "8.3 Subtraction operator",
    "text": "8.3 Subtraction operator\nThe - operator is more powerful than the & operator, enabling flexible addition of elements to multiple plots. While its use might initially seem unintuitive, the reason behind this is that - shares the same precedence group as +, which allows it to seamlessly combine with +.\n\n8.3.1 quad_layout()\nIf the active context is the ggheatmap()/quad_layout() itself (no active annotation), the - operator behaves similarly to &. It applies the specified elements to all plots within the layout.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Remove any active annotation\n    quad_active() -\n    # Set color scale for all plots, since the active layout is the `ggheatmap()`/`quad_layout()`\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIf the active layout is an annotation stack, the - operator will only add the elements to all plots in the active annotation stack:\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the the color scales of all plots in the left annotation\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n8.3.2 stack_layout()\nIf the active layout is the stack_layout() itself, - applies the elements to all plots in the layout except the nested ggheatmap()/quad_layout().\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout except the heatmap layout\n    theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen the active layout is the nested ggheatmap()/quad_layout(), the - operator applies the elements to this nested layout, following the same principles as in the Section 8.3.1.\nWant apply elements for plots in both stack_layout() and the nested ggheatmap()/quad_layout() at the same time? refer to the following section.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#with_quad",
    "href": "operator.html#with_quad",
    "title": "8  Operators",
    "section": "8.4 with_quad()",
    "text": "8.4 with_quad()\nThe with_quad() function adjusts the context in which elements are applied in ggheatmap()/quad_layout(). It allows you to control how objects such as themes, scales, and other plot modifications are applied to specific annotation stacks or the main plot, without changing the currently active layout or plot.\nThis function accepts three arguments:\n\nx: An object which can be added to the plot.\nposition: A string containing one or more of \"t\", \"l\", \"b\", and \"r\" specifies the context for applying x.\nmain: A single boolean value indicates whether x should also apply to the main plot within ggheatmap()/quad_layout(). Only used when position is not NULL.\n\n\n8.4.1 quad_layout()\nDefault Behavior by wrapping object with with_quad():\n\nWhen ggheatmap()/quad_layout() has no active annotation stack, objects added via + or - operate normally without with_quad().\nWhen the active annotation stack is set, with_quad() ensures the applied object also modifies:\n\nThe main plot (by default).\nOpposite annotation stacks when using -.\n\n\nBy wrapping object with with_quad(), the + operator will apply the object not only to the active plot in the annotation stack, but also to the main plot unless specified by main argument otherwise.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # apply the object not only to the active plot in the annotation stack, but\n    # also to the main plot\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy wrapping object with with_quad(), the - operator will apply the object not only to that annotation stack but also to the opposite one (i.e., bottom if top is active, and vice versa). In these cases, the object will also be applied to the main plot by default unless specified by main argument otherwise.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Change the active layout to the left annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the theme of all plots in the bottom and the opposite annotation\n    # in this way, the `main` argument by default would be `TRUE`\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe position argument can be a string containing one or more of \"t\", \"l\", \"b\", and \"r\", indicating which annotation stack should be used as the context. When the position argument is manually set, the default value of the main argument will be FALSE.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots in the left and top annotation\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), \"tl\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSetting position to NULL change the context to the ggheatmap()/quad_layout() itself.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # we apply the theme to the main plot only\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n8.4.2 stack_layout()\nWhen the active layout is the stack_layout() itself, by default, by wrapping object with with_quad(), - operator will apply changes to all plots along the stack_layout(), which means if the stack layout is in horizontal, - operator will also add the element to the left and right annotation, if the stack layout is in vertical, - operator will also add element to the top and bottom annotation. In these cases, the object will also be applied to the main plot by default unless specified by main argument otherwise.\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    anno_top() +\n    align_dendro() +\n    ggtitle(\"I'm from the nested heatmap\") +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout (including plots in the heatmap layout)\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n+ operator won’t do anything special when the active layout is the stack_layout() itself.\nWhen the active layout is the nested ggheatmap()/quad_layout(), the +/- operator applies the elements to this nested layout, following the same principles as for ggheatmap()/quad_layout().",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "schemes.html",
    "href": "schemes.html",
    "title": "9  schemes",
    "section": "",
    "text": "9.1 scheme_theme()\nSechemes control the actions of plots within the layout. These sechemes can be applied either globally to the layout or individually to specific plots.\nThe package currently provides three schemes, each prefixed with scheme_:\nThe scheme_theme() function extends theme() to set a default theme for plots, allowing you to input theme() elements directly or add the theme elements.\nTo set a scheme for a single plot, simply use the + operator:\n1ggheatmap(small_mat) +\n2    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\ninitialize a heatmap layout\n\n2\n\nset the default theme, change the plot background for the main plot\nYou can use a theme() object directly in scheme_theme().\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(fill = value), width = 0.9, height = 0.9) +\n    scheme_theme(theme_bw(), plot.background = element_rect(fill = \"red\"))\nNote that scheme_theme() serves as the default theme and will always be overridden by any theme() settings applied directly to the plot. The default theme (scheme_theme()) is applied first, followed by any specific theme() settings, even if theme() is added before scheme_theme().\nggheatmap(small_mat) +\n    # change the plot theme of the heatmap body\n    theme(plot.background = element_rect(fill = \"blue\")) +\n    # change the default theme of the heatmap body\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\nBy using the - operator with schemes, we apply the scheme directly to the active layout.\nggheatmap(small_mat) +\n    # Change the active layout to the top annotation\n    anno_top() +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # add a bar plot to the top annotation\n    ggalign(aes(.names, value, fill = factor(.names)), data = rowSums) +\n    geom_bar(stat = \"identity\") -\n    # Change the default theme of the top annotation\n    # All plots in the top annotation will inherit this default theme\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\nUnlike individual ggplot2 elements, which will be added directly to each plot by - operator, layout-level schemes set by - operator are inherited by all plots in the layout when rendered. Any plot-specific schemes will override these layout-level schemes, regardless of the order in which they are added.\nggheatmap(small_mat) +\n    # Change the active layout to the top annotation\n    anno_top() +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # change the scheme_theme for the dendrogram plot\n    scheme_theme(plot.background = element_rect(fill = \"blue\")) +\n    # add a bar plot to the top annotation\n    ggalign(aes(.names, value, fill = factor(.names)), data = rowSums) +\n    geom_bar(stat = \"identity\") -\n    # Change the default theme of the top annotation\n    # All plots in the top annotation will inherit this default theme\n    # But the plot-specific options will override these\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>schemes</span>"
    ]
  },
  {
    "objectID": "schemes.html#scheme_data",
    "href": "schemes.html#scheme_data",
    "title": "9  schemes",
    "section": "9.2 scheme_data()",
    "text": "9.2 scheme_data()\nalign_gg()/ggalign() requires the specific data format for its operations. If you need to transform or filter data for individual geoms, you can use the data argument within each geom. However, if you have multiple geoms and want a consistent transformation applied across all, you can utilize the scheme_data() function. This allows you to transform the default data for the entire plot.\nThe scheme_data() accepts a function that takes a data frame as input and returns a modified data frame. By default, scheme_data() will attempt to inherit from the parent layout if the data is inherited from it. However, there is one exception: align_dendro() will not inherit scheme_data() transformations by default.\n\nset.seed(1234L)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L) +\n    # we add a bar plot\n    ggalign() +\n    # we subest the plot data\n    scheme_data(~ subset(.x, .panel == 1L)) +\n    geom_bar(aes(y = value, fill = .row_names), stat = \"identity\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>schemes</span>"
    ]
  },
  {
    "objectID": "schemes.html#scheme_align",
    "href": "schemes.html#scheme_align",
    "title": "9  schemes",
    "section": "9.3 scheme_align()",
    "text": "9.3 scheme_align()\nThe scheme_align() function controls the align specifications for plots.\n\n9.3.1 guides\nBy default, ggheatmap() will collect all guide legends on the side from which they originate.\n\nheatmap_collect_all_guides &lt;- ggheatmap(small_mat, width = 2, height = 2L) +\n    # we set the legend to the left side\n    scale_fill_gradient2(\n        low = \"blue\", high = \"red\",\n        name = \"I'm from heatmap body\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we add a top annotation\n    anno_top() +\n    # in the top annotation, we add a dendrogram\n    align_dendro(aes(color = branch), k = 3L) +\n    # we set the legends of the dendrogram to the left side\n    scale_color_brewer(\n        name = \"I'm from top annotation\", palette = \"Dark2\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    # we add a left annotation\n    anno_left() +\n    align_dendro(aes(color = branch), k = 3L) +\n    # we set the legends of the dendrogram to the top side\n    scale_color_brewer(\n        name = \"I'm from left annotation\", palette = \"Dark2\",\n        guide = guide_legend(position = \"top\", direction = \"vertical\")\n    ) &\n    # we remove all margins for all plots\n    theme(plot.margin = margin())\nheatmap_collect_all_guides\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe guides argument schemes which side of guide legends should be gathered. In the following example, we’ll collect the guide legends only on the top (t) sides:\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side\n    with_quad(scheme_align(guides = \"t\"), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also apply the scheme_align() function directly to specific plots:\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for the heatmap layout\n    # we only collect guides in the top side\n    with_quad(scheme_align(guides = \"t\"), NULL) +\n    # `+` apply it to the active plot\n    # for the heatmap body, we collect guide in the left side\n    with_quad(scheme_align(guides = \"l\"), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote: The legend on the left side of the heatmap body is collected and positioned on the left side at the layout level.\nIf you’re annoyed by the large space between the left annotation and the heatmap body, don’t worry! This issue will be addressed in Section 9.3.2.\nNow, Let’s dive deeper into the guide collection process.\nIn the last example, we set the guides argument for the heatmap body. But what happens when we set the guides for the dendrogram in the top annotation?\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side in the heatmap layout\n    with_quad(scheme_align(guides = \"t\"), NULL) +\n    # `+` apply it to the active plot\n    # for the dendrogram in the top annotation, we collect guide in the left side\n    with_quad(scheme_align(guides = \"l\"), \"t\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNothing seems to have changed, right? This is because guide legends within annotation stacks are first collected by the annotation stack_layout() and only then passed to the top-level layout for further integration.\nBy default, the annotation stack inherits the guides arguments from the heatmap layout, followed by the inherited of individual plot in the annotation. So guides argument set at top-level (heatmap layout) will affect all guide collection behaviour.\nIn this example:\n\nThe legend on the left side of the dendrogram in the top annotation is collected first at the annotation level.\nSince the heatmap layout is not set to collect legends from the left side, it remains at the left side within the annotation stack.\nFor this specific case, the top annotation contains only one plot, so its annotation-level placement is identical to plot-level placement.\n\nTo override this, you can use the free_guides argument of the quad_anno()/anno_*() function. This differs from the guides argument in scheme_align(), which schemes the behavior for the plots in the layout. The free_guides argument specifies which guide legends from at the annotation stack layout level should be collected by the heatmap layout.\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side in the heatmap layout\n    with_quad(scheme_align(guides = \"t\"), NULL) +\n    # we also collect guides in the left side for the top annotation stack\n    # in the heatmap layout\n    anno_top(free_guides = \"l\") +\n    # `+` apply it to the active plot\n    # for the dendrogram in the top annotation, we collect guide in the left side\n    scheme_align(guides = \"l\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nNote: The heatmap layout will only collect guide legends from the annotation stack if the stack layout collects its own guides first.\n\n\n\n9.3.2 free_spaces\nBy default, ggheatmap() will align all elements of the plot, which can sometimes lead to unwanted spacing. Consider the following example:\n\nggheatmap(small_mat) +\n    # add top annotation\n    anno_top(size = unit(30, \"mm\")) +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # here, we use long labels for visual example\n    scale_y_continuous(\n        expand = expansion(),\n        labels = ~ paste(\"very very long labels\", .x)\n    ) +\n    # add left annotation\n    anno_left(unit(20, \"mm\")) +\n    # add a dendrogram to the left annotation\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this case, the left annotation stack is positioned far from the heatmap body due to the wide axis labels in the top annotation stack. This occurs because the top annotation stack is aligned with the heatmap body. To fix this, you can remove the left borders around the panel of the top annotation stack by setting free_spaces = \"l\".\n\nggheatmap(small_mat) +\n    # add top annotation\n    anno_top(size = unit(30, \"mm\")) -\n    # we remove the spaces of the left borders in the top annotation\n    scheme_align(free_spaces = \"l\") +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # here, we use long labels for visual example\n    scale_y_continuous(\n        expand = expansion(),\n        labels = ~ paste(\"very very long labels\", .x)\n    ) +\n    # add left annotation\n    anno_left(unit(20, \"mm\")) +\n    # add a dendrogram to the left annotation\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nOne useful way to utilize free_spaces is to position the guide legends next to the annotations. (Note the guide legend from the bottom annotation):\n\nheatmap_collect_all_guides +\n    # reset the active context to the heatmap layout\n    quad_active() -\n    # we set global `guides` argument for the heatmap layout\n    # we only collect guides in the top side\n    scheme_align(guides = \"t\") +\n    # `+` apply it to the current active plot\n    # for the heatmap body, we collect guide in the left side\n    scheme_align(guides = \"l\") -\n    with_quad(scheme_align(free_spaces = \"l\"), \"t\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nUsually you want to apply free_spaces with the whole layout, instead of individual plots.\nIn ggheatmap()/quad_layout(), the behavior of the free_spaces and free_labs arguments differs from guides arguments in scheme_align() when inheriting from the parent layout:\n\nFor top and bottom annotations, it inherits from the left (“l”) and right (“r”) axes.\nFor left and right annotations, it inherits from the top (“t”) and bottom (“b”) axes.\n\n\n\n9.3.3 free_labs\nBy default, we won’t align the axis titles.\n\nggheatmap(small_mat) +\n    ylab(\"Heatmap title\") +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    ylab(\"Annotation title\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo align axis titles, you can set free_labs = NULL. Alternatively, A single string containing one or more of axis positions (“t”, “l”, “b”, “r”) to indicate which axis titles should be free from alignment.\n\nggheatmap(small_mat) -\n    scheme_align(free_labs = NULL) +\n    ylab(\"Heatmap title\") +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    ylab(\"Annotation title\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>schemes</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html",
    "href": "difference-with-ggplot2.html",
    "title": "10  Difference with ggplot2",
    "section": "",
    "text": "10.1 Axes used for alignment\nggalign focuses on aligning observations across multiple plots. While it builds on the ggplot2 framework, there are key differences in how scales, facets, and coordinates are handled in alignment axes. This vignette highlights these syntax differences.\nThe following syntax applies to all align_* functions that add a plot area, and to the main plot in quad_layout() when alignment is needed.\nAxes used for alignment in ggalign refer to: - x-axis in vertical stack layouts\nggalign introduces special syntax and handling for these axes, differing from the default behavior in ggplot2. These adjustments ensure that observations are properly aligned and operations are user-friendly.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#axes-used-for-alignment",
    "href": "difference-with-ggplot2.html#axes-used-for-alignment",
    "title": "10  Difference with ggplot2",
    "section": "",
    "text": "x-axis in horizontal stack layouts\nx- and y- axes in the quad_layout() main plot",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#position-scales",
    "href": "difference-with-ggplot2.html#position-scales",
    "title": "10  Difference with ggplot2",
    "section": "10.2 Position Scales",
    "text": "10.2 Position Scales\nTo better fit the alignment-based layout, ggalign introduces adjustments to breaks, labels, and expand arguments.\n\n10.2.1 breaks\nbreaks and labels are typically handled similarly to discrete scales, as we focus on aligning observations (which should be regarded as discrete variables); no matter what you use is continuous scale or discrete scale.\nbreaks should be one of:\n- `NULL` for no breaks\n\n- `waiver()` for the default breaks (the full data index or `NULL` if no\ndata names and `labels` is `waiver()`)\n\n- A character vector of breaks (rownames / colunames of the matrix).\n\n- A numeric vector of data index (must be an integer).\n\n- A function that takes the data names or the data index as input and\nreturns breaks as output. Also accepts rlang lambda function notation. \nDefault breaks without names:\n\nno_names &lt;- small_mat\ncolnames(no_names) &lt;- NULL\nggheatmap(no_names) + scale_x_continuous()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNo breaks:\n\nggheatmap(small_mat) + scale_x_continuous(breaks = NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.column_names, .row_names, fill = value)) +\n    scale_x_discrete(breaks = NULL)\n\n\n\n\n\n\n\n\nCharacter-based breaks use data names (or indices if names are absent)\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(\"column3\", \"column5\")) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.column_names, .row_names, fill = value)) +\n    scale_x_discrete(breaks = c(\"column3\", \"column5\")) +\n    anno_top() +\n    align_dendro(k = 3L)\n\n\n\n\n\n\n\n\nInteger-based breaks are interpreted as data indices:\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(3, 5)) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.column_names, .row_names, fill = value)) +\n    scale_x_discrete(breaks = c(3, 5)) +\n    anno_top() +\n    align_dendro(k = 3L)\n\n\n\n\n\n\n\n\nFloating numbers are invalid for breaks:\n\nggheatmap(small_mat) + scale_x_continuous(breaks = c(3.5, 5))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; Error in `scale_x_continuous()`:\n#&gt; ! Can't convert from `breaks` &lt;double&gt; to &lt;integer&gt; due to loss of precision.\n#&gt; • Locations: 1\n\nTo interpret integers as plot-specific coordinate indices, wrap them with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = I(3:4)) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n10.2.2 labels\nlabels should be one of:\n- `NULL` for no labels\n\n- `waiver()` for the default labels (data names)\n\n- A character vector giving labels (must be same length as breaks)\n\n- An expression vector (must be the same length as breaks). See `?plotmath`\nfor details. \n\n- A function that takes the data names (or data index if data has no names)\nas input and returns labels as output. This can be also a rlang lambda\nfunction.\nThe default labels are the data names (or indices if names are absent):\n\nggheatmap(small_mat) + scale_x_continuous() +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNo labels:\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = NULL) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nCharacter labels will be reordered based on the data’s ordering:\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = letters[seq_len(ncol(small_mat))]) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo retain the original order of character labels, wrap them with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = I(letters[seq_len(ncol(small_mat))])) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, labels correspond to breaks:\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(5, 3), labels = c(\"a\", \"b\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo override the default matching, wrap the labels vector with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(5, 3), labels = I(c(\"a\", \"b\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n10.2.3 expand\nBy default, we utilize zero expansion for the aligned axis. This is typically the desired setting. If you wish to introduce expansion, you must manually adjust it and apply it to each plot to ensure proper axis alignment.\n\nggheatmap(small_mat) +\n    scale_x_continuous(expand = expansion(mult = 0.1)) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_x_continuous(expand = expansion(mult = 0.1))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can utilize ggh4x::facetted_pos_scales() to set scales for each panel.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#theme",
    "href": "difference-with-ggplot2.html#theme",
    "title": "10  Difference with ggplot2",
    "section": "10.3 theme",
    "text": "10.3 theme\nAlthough ggplot2 does not officially support vectorized input for theme elements, we can still utilize it. ggalign extends this feature, allowing theme elements to be vectorized and applied across panels.\n\nggheatmap(small_mat) +\n    theme(\n        axis.text.x = element_text(\n            colour = c(rep(\"red\", 4), rep(\"blue\", 5))\n        ),\n        axis.ticks.x = element_line(\n            colour = c(rep(\"red\", 4), rep(\"blue\", 5))\n        ),\n        axis.ticks.length.x = unit(rep(c(1, 4), times = c(4, 5)), \"mm\")\n    ) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_y_continuous(expand = expansion()) &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#facets",
    "href": "difference-with-ggplot2.html#facets",
    "title": "10  Difference with ggplot2",
    "section": "10.4 Facets",
    "text": "10.4 Facets\nWhen working with facets, manual configuration of the panel using the facet_*() functions is not possible since the internal structure will use facet_grid() to set the row/column groups defined by align_*() functions. However, you can still use facet_grid() or facet_null() (if no panel) to control other arguments except aligned panels (rows in horizontal stack layout or cols in vertical stack layout, or both rows and cols in heatmap body).\nA common use case is to modify the panel strip text. The default theme (theme_ggalign()) will always remove the panel strip text, you can override this behaviour with theme(strip.text = element_text()) to add the panel title in the plot area.\n\nggheatmap(small_mat) +\n    facet_grid(labeller = labeller(.column_panel = function(x) letters[as.integer(x)])) +\n    theme(strip.text = element_text()) +\n    anno_top() +\n    align_kmeans(centers = 3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#coords",
    "href": "difference-with-ggplot2.html#coords",
    "title": "10  Difference with ggplot2",
    "section": "10.5 Coords",
    "text": "10.5 Coords\nCurrently, only cartesian coordinate can be used to align axis well. Internally, the limits will always be set to the number of observations, with an additional range expansion of 0.5 added on both ends.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "plot-composer.html",
    "href": "plot-composer.html",
    "title": "11  Plot Composer",
    "section": "",
    "text": "11.1 Plot Assembly\nSpecial thanks to the patchwork project—many core codes of the plot composer process were adapted from patchwork. We have added new features to better implement ggalign’s layout functions (ggheatmap() and ggstack()), including:\nThese features have not been pushed to patchwork because they required significant modification of core code. We attempted to merge them, but the author of patchwork decided to implement some of these features independently. The latest version of patchwork now includes free_align(), free_lab(), and free_space() functionality under a single function: patchwork::free(). For more details, see: https://www.tidyverse.org/blog/2024/09/patchwork-1-3-0/.\nThe plot composer function in ggalign is align_plots(), which behaves similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, you can directly use align_plots() with quad_layout()/ggheatmap() and ggstack(), ensuring that they align correctly by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, although they won’t align by panel area with ggplot2.\nWe’ll start with a few well-known example plots:\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp))\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(gear, disp, group = gear))\np3 &lt;- ggplot(mtcars) +\n    geom_bar(aes(gear)) +\n    facet_wrap(~cyl)\np4 &lt;- ggplot(mtcars) +\n    geom_bar(aes(carb))\np5 &lt;- ggplot(mtcars) +\n    geom_violin(aes(cyl, mpg, group = cyl))\nEither add the plots as single arguments\nalign_plots(p1, p2, p3, p4, p5)\nOr use bang-bang-bang to add a list of plots\nalign_plots(!!!list(p1, p2, p3), p4, p5)",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#empty-area",
    "href": "plot-composer.html#empty-area",
    "title": "11  Plot Composer",
    "section": "11.2 Empty area",
    "text": "11.2 Empty area\nYou can use NULL to indicate the empty area.\n\nalign_plots(p1, NULL, p2, NULL, p3, NULL)",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#controlling-the-grid",
    "href": "plot-composer.html#controlling-the-grid",
    "title": "11  Plot Composer",
    "section": "11.3 Controlling the grid",
    "text": "11.3 Controlling the grid\nLike patchwork, if no specific layout is provided, align_plots() will attempt to create a grid that is as square as possible, with each column and row taking up equal space:\n\nalign_plots(p1, p2, p3, p4, ncol = 3)\n\n\n\n\n\n\n\n\nTo adjust the widths of columns, use:\n\nalign_plots(p1, p2, p3, p4, widths = c(2, 1))",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#guide-legends",
    "href": "plot-composer.html#guide-legends",
    "title": "11  Plot Composer",
    "section": "11.4 Guide legends",
    "text": "11.4 Guide legends\nBy default, align_plots() won’t collect any guide legends. You can use the guides argument to control which side of the guide legends should be collected. They will be collected to their original side. Here, we use patch_titles() to indicate the guide legend position (instead of using ggtitle()). patch_titles() can add titles on four sides, and the title will be placed between the plot panel and the guide legend.\n\np_right &lt;- ggplot(mtcars) +\n    geom_point(aes(hp, wt, colour = mpg)) +\n    patch_titles(\"right\") +\n    labs(color = \"right\")\np_top &lt;- p_right +\n    patch_titles(\"top\") +\n    scale_color_continuous(\n        name = \"top\",\n        guide = guide_colorbar(position = \"top\")\n    )\np_left &lt;- p_right +\n    patch_titles(\"left\") +\n    scale_color_continuous(\n        name = \"left\",\n        guide = guide_colorbar(position = \"left\")\n    )\np_bottom &lt;- p_right +\n    patch_titles(\"bottom\") +\n    scale_color_continuous(\n        name = \"bottom\",\n        guide = guide_colorbar(position = \"bottom\")\n    )\nalign_plots(p_right, p_bottom, p_top, p_left, guides = \"tlbr\")\n\n\n\n\n\n\n\n\nIf align_plots() is nested in another align_plots(), the nested align_plots() will inherit the guides argument from the upper-level align_plots(). And the top-level align_plots() won’t collect guide legends from plots within the nested align_plots() unless the nested align_plots() collects them first.",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#free_guide",
    "href": "plot-composer.html#free_guide",
    "title": "11  Plot Composer",
    "section": "11.5 free_guide",
    "text": "11.5 free_guide\nThe free_guide() function allows you to override the guides argument for a single plot.\n\nalign_plots(\n    free_guide(p_right, NULL),\n    free_guide(p_bottom, NULL),\n    free_guide(p_top, NULL),\n    free_guide(p_left, NULL),\n    guides = \"tlbr\"\n)\n\n\n\n\n\n\n\n\nYou can also specify which guide positions to be collected for individual plots.\n\nalign_plots(\n    free_guide(p_right, \"r\"),\n    free_guide(p_bottom, \"b\"),\n    free_guide(p_top, \"t\"),\n    free_guide(p_left, \"l\")\n)",
    "crumbs": [
      "Basics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "oncoplot.html",
    "href": "oncoplot.html",
    "title": "12  ggoncoplot",
    "section": "",
    "text": "12.1 Input data\nThe ggoncoplot() function generates oncoPrint visualizations that display genetic alterations in a matrix format. This function is especially useful for visualizing complex genomic data, such as mutations, copy number variations, and other genomic alterations in cancer research.\nThe input should be a character matrix which encodes the alterations, you can use string of \";\", \":\", \",\", and \"|\" to separate multiple alterations. Internally, ggoncoplot() will use fortify_matrix() to get such matrix.\nmat &lt;- read.table(\n    textConnection(\n        \"s1,s2,s3\n         g1,snv;indel,snv,indel\n         g2,,snv;indel,snv\n         g3,snv,,indel;snv\"\n    ),\n    row.names = 1, header = TRUE, sep = \",\", stringsAsFactors = FALSE\n)\nmat\n#&gt;                    s1        s2        s3\n#&gt;          g1 snv;indel       snv     indel\n#&gt;          g2           snv;indel       snv\n#&gt;          g3       snv           indel;snv\nA basic oncoprint can be generated as follows:\nggoncoplot(mat)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#oncoprint-customization",
    "href": "oncoplot.html#oncoprint-customization",
    "title": "12  ggoncoplot",
    "section": "12.2 oncoPrint Customization",
    "text": "12.2 oncoPrint Customization\nBy default, all alterations are represented with tiles of equal width and height, which may lead to overlapping. You can control the width and height of the tiles using the map_width and map_height arguments (we will introduce another more effective ways to handle this in the Specialized Geoms section):\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9))\n\n\n\n\n\n\n\n\nBy default, all empty string will be converted to NA value and ggplot2 will translate the NA values and render it in the legend. To prevent this, you can turn off the translation using na.translate = FALSE:\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n\n\n\n\n\n\n\n\nThe function automatically reorders rows and columns based on alteration frequency. Disable this with reorder_row = FALSE and reorder_column = FALSE.\nYou can further customize layouts using methods from vignette(\"layout-customize\").\n\nggoncoplot(mat,\n    map_width = c(snv = 0.5), map_height = c(indel = 0.9),\n    reorder_row = FALSE, reorder_column = FALSE\n) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#advanced-data-handling",
    "href": "oncoplot.html#advanced-data-handling",
    "title": "12  ggoncoplot",
    "section": "12.3 Advanced Data Handling",
    "text": "12.3 Advanced Data Handling\nggoncoplot() is built on ggheatmap() with a default scheme_data() (see vignette(\"plot-options\") for details), which splits alterations into separate entries for visualization. (See ggplot2 specification section in ggheatmap() for the input data of scheme_data()):\n\npdata &lt;- function(data) {\n    tidyr::separate_longer_delim(data,\n        cols = value,\n        delim = stringr::regex(\"\\\\s*[;:,|]\\\\s*\")\n    )\n}\n# Note: this figure will contain an empty string value.\n#\n# `ggoncoplot()` will automatically convert any empty strings to `NA`\n# before pass it to `ggheatmap`.\nggheatmap(mat) -\n    scheme_data(pdata) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, the scheme_data() is inherited from the parent layout if the data of the plot is inherited from the layout. You can apply the parent scheme_data() first and then apply another transformation by setting inherit = TRUE. This functionality is especially useful when working with ggoncoplot().\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +\n    anno_top(size = 0.2) +\n    ggalign() +\n    # by setting `inherti = TRUE`, we apply the parent layout `scheme_data()`\n    # (from the `ggoncoplot()` layout) firstly, which will split the alteration\n    # string and unnested the columns.\n    # Here: We then remove `NA` value\n    scheme_data(~ subset(.x, !is.na(value)), inherit = TRUE) +\n    geom_bar(aes(.x, after_stat(count), fill = value)) +\n    # note: `ggoncoplot()` use `geom_tile()` to draw the oncoPrint,\n    # the guide is different from `geom_bar()`, though both looks\n    # like the same, we remove the guide of `geom_bar()` plot\n    guides(fill = \"none\") &\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#integration-with-maftools",
    "href": "oncoplot.html#integration-with-maftools",
    "title": "12  ggoncoplot",
    "section": "12.4 Integration with maftools",
    "text": "12.4 Integration with maftools\nThe ggoncoplot() function supports MAF objects from the maftools package using the fortify_matrix.MAF() method. It includes options to control data generation for ggoncoplot(), such as drawing the top n_top genes.\n\n# load data from `maftools`\nlaml.maf &lt;- system.file(\"extdata\", \"tcga_laml.maf.gz\", package = \"maftools\")\n# clinical information containing survival information and histology. This is optional\nlaml.clin &lt;- system.file(\"extdata\", \"tcga_laml_annot.tsv\", package = \"maftools\")\nlaml &lt;- maftools::read.maf(\n    maf = laml.maf,\n    clinicalData = laml.clin,\n    verbose = FALSE\n)\n# Visualizing the Top 20 Genes\nggoncoplot(laml, n_top = 20) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n\n\n\n\n\n\n\n\nBy default, samples without alterations in the selected genes are removed. To include all samples, set remove_empty_samples = FALSE:\n\nalign_plots(\n    ggoncoplot(laml, n_top = 20L, remove_empty_samples = FALSE) +\n        scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n        theme_no_axes(\"x\") +\n        ggtitle(\"Keep empty samples\"),\n    ggoncoplot(laml, n_top = 20L, remove_empty_samples = TRUE) +\n        scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n        theme_no_axes(\"x\") +\n        ggtitle(\"Remove empty samples\"),\n    ncol = 1L,\n    guides = \"tlbr\"\n)",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#specialized-geoms",
    "href": "oncoplot.html#specialized-geoms",
    "title": "12  ggoncoplot",
    "section": "12.5 Specialized Geoms",
    "text": "12.5 Specialized Geoms\n\n12.5.1 geom_subtile()\nWhen multiple alterations occur in the same sample and gene, they are combined into a single value, \"Multi_Hit\", by default. To visualize these alterations separately, you can set collapse_vars = FALSE. However, doing so can lead to overlapping alterations within the same cell, making the visualization cluttered and hard to interpret.\nIn such cases, disabling the default filling and defining a custom heatmap layer with geom_subtile() is more effective. This function subdivides each cell into smaller rectangles, allowing the distinct alterations to be clearly displayed.\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), direction = \"vertical\") +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\nWe focus exclusively on cells with multiple alterations to highlight the differences, by filtering the data before applying geom_subtile():\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    scheme_data(function(data) {\n        dplyr::filter(data, dplyr::n() &gt; 1L, .by = c(\".x\", \".y\"))\n        # we apply the parent layout `scheme_data()` first (`inherit = TRUE`),\n        # which will split the alteration string and unnested the columns.\n    }, inherit = TRUE) +\n    geom_subtile(aes(fill = value), direction = \"vertical\") +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\n\n\n12.5.2 geom_draw()\ngeom_subtile() often suffices for most scenarios. However, if you require a strategy similar to that of ComplexHeatmap, consider using geom_draw(), which offers greater flexibility for complex customizations.\nKey Features of geom_draw():\n\nCustom Drawing Logic: Accepts a draw aesthetic, allowing each cell to be rendered as a specific graphical object (grob).\nManual Scaling: Requires scale_draw_manual() to map draw values to corresponding drawing functions.\nFlexible Aesthetic Mapping: Functions mapped through scale_draw_manual() can utilize any number of ggplot2 aesthetics and output custom graphical objects (grob). Beyond the x, y, xmin, xmax, width, and height aesthetics, you may want to rely solely on mapped aesthetics (aes()). Unmapped aesthetics will default to ggplot2’s behavior, which might not produce the desired outcome. And always use native unit.\n\n:) Sorry, I cannot deal with a pretty example for this, but the function provided in values argument of scale_draw_manual operates similarly to alter_fun in ComplexHeatmap. Currently, geom_subtile() performs well enough for most cases, making geom_draw() somewhat cumbersome to use. Managing alteration types, especially in the case of overlapping alterations, requires meticulous design to ensure that the visual elements do not interfere with each other.\n\nlibrary(grid)\ndraw_mapping &lt;- list(\n    function(x, y, width, height, fill) {\n        rectGrob(x, y,\n            width = width, height = height,\n            gp = gpar(fill = fill),\n            default.units = \"native\"\n        )\n    },\n    function(x, y, width, height, fill) {\n        rectGrob(x, y,\n            width = width, height = height,\n            gp = gpar(fill = fill),\n            default.units = \"native\"\n        )\n    },\n    function(x, y, width, height, fill) {\n        rectGrob(x, y,\n            width = width, height = height,\n            gp = gpar(fill = fill),\n            default.units = \"native\"\n        )\n    },\n    function(x, y, width, height, shape) {\n        gList(\n            pointsGrob(x, y, pch = shape),\n            # To ensure the rectangle color is shown in the legends, you\n            # must explicitly provide a color argument and include it in\n            # the `gpar()` of the graphical object\n            rectGrob(x, y, width, height,\n                gp = gpar(col = \"black\", fill = NA)\n            )\n        )\n    },\n    function(xmin, xmax, ymin, ymax) {\n        segmentsGrob(\n            xmin, ymin,\n            xmax, ymax,\n            gp = gpar(lwd = 2)\n        )\n    }\n)\n\nvalue &lt;- sample(letters, 5L)\nggplot(data.frame(value = value, y = seq_len(5))) +\n    geom_draw(aes(x = 1, y = y, draw = value, fill = value)) +\n    scale_draw_manual(values = draw_mapping) +\n    scale_fill_brewer(palette = \"Dark2\")\nggplot(data.frame(value = c(value, value[5L]), y = c(1, 2, 3, 1, 2, 3))) +\n    geom_draw(aes(x = 1, y = y, draw = value, fill = value)) +\n    scale_draw_manual(values = draw_mapping) +\n    scale_fill_brewer(palette = \"Dark2\")",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#ggalign-attributes",
    "href": "oncoplot.html#ggalign-attributes",
    "title": "12  ggoncoplot",
    "section": "12.6 ggalign attributes",
    "text": "12.6 ggalign attributes\nExcept for the data used for the main plot, fortify_matrix.MAF() also attaches several useful attributes.\n\ngene_summary: gene summary informations. See maftools::getGeneSummary() for details.\nsample_summary: sample summary informations. See maftools::getSampleSummary() for details.\nsample_anno: sample clinical informations. See maftools::getClinicalData() for details.\nn_genes: Total of genes.\nn_samples: Total of samples.\ntitv: A list of data.frames with Transitions and Transversions summary. See maftools::titv() for details.\n\nYou can extract these attributes using the ggalign_attr() function. Below is an example of how to extract the sample summary data (e.g., TMB) using ggalign_attr() and add it to the top annotation of an oncoplot:\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), direction = \"vertical\") +\n    theme_no_axes(\"x\") +\n    anno_top(size = 0.2) +\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"sample_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:(ncol(data) - 1L)])\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    ylab(\"TMB\") &\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\nWe can draw the example from maftools vignette.\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), direction = \"vertical\") +\n    theme_no_axes(\"x\") +\n    # since legends from geom_tile (oncoPrint body) and `geom_bar`\n    # is different, though both looks like the same, the internal\n    # won't merge the legends. we remove the legends of oncoPrint body\n    guides(fill = \"none\") +\n    # add top annotation\n    anno_top(size = 0.2) +\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"sample_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:(ncol(data) - 1L)])\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    ylab(\"TMB\") +\n    # add right annotation\n    anno_right(size = 0.2) -\n    # remove bottom spaces of the right annotation when aligning\n    scheme_align(free_spaces = \"b\") +\n    # add the text percent for the alterated samples in the right annotation\n    ggalign(data = function(data) {\n        # Atomic vector will be put in the `value` column of the data frame.\n        ggalign_attr(data, \"gene_summary\")$AlteredSamples /\n            ggalign_attr(data, \"n_samples\")\n    }) +\n    geom_text(aes(1, label = scales::label_percent()(value)), hjust = 1) +\n    scale_x_continuous(\n        expand = expansion(),\n        name = NULL, breaks = NULL,\n        limits = c(0, 1)\n    ) +\n    theme(plot.margin = margin()) +\n    # add the bar plot in the right annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"gene_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:8])\n    }) +\n    geom_bar(aes(value, fill = .column_names),\n        stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    xlab(\"No. of samples\") -\n    # we apply the scale mapping to the top and right annotation: `position = \"tr\"`\n    # and the main plot: `main = TRUE`\n    with_quad(\n        scale_fill_brewer(\"Mutations\",\n            palette = \"Dark2\", na.translate = FALSE\n        ),\n        position = \"tr\",\n        main = TRUE\n    ) +\n    # add bottom annotation\n    anno_bottom(size = 0.2) +\n    # add bar plot in the bottom annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"titv\")$fraction.contribution\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:7])\n    }) +\n    geom_bar(aes(y = value, fill = .column_names), stat = \"identity\") +\n    ylab(\"Ti/Tv\") +\n    scale_fill_brewer(\"Ti/Tv\", palette = \"Set2\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n#&gt; Warning: Removed 24 rows containing missing values or values outside the scale range\n#&gt; (`geom_bar()`).",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#integration-with-gistic-results-from-maftools",
    "href": "oncoplot.html#integration-with-gistic-results-from-maftools",
    "title": "12  ggoncoplot",
    "section": "12.7 Integration with GISTIC results from maftools",
    "text": "12.7 Integration with GISTIC results from maftools\nThe package also includes a fortify_matrix.GISTIC() method designed to handle GISTIC objects from the maftools package. This allows you to seamlessly apply the same operations to visualize GISTIC results. The following ggalign attributes are generated as part of the analysis:\n\nsample_anno: sample clinical informations provided in sample_anno argument.\nsample_summary: sample copy number summary informations. See data@cnv.summary for details.\ncytoband_summary: cytoband summary informations. See data@cytoband.summary for details.\ngene_summary: gene summary informations. See data@gene.summary for details.\nsummary: A data frame of summary information. See data@summary for details.\n\n\n# Ensure the maftools package is installed and load the example GISTIC data\nall.lesions &lt;- system.file(\"extdata\", \"all_lesions.conf_99.txt\", package = \"maftools\")\namp.genes &lt;- system.file(\"extdata\", \"amp_genes.conf_99.txt\", package = \"maftools\")\ndel.genes &lt;- system.file(\"extdata\", \"del_genes.conf_99.txt\", package = \"maftools\")\nscores.gistic &lt;- system.file(\"extdata\", \"scores.gistic\", package = \"maftools\")\nlaml.gistic &lt;- maftools::readGistic(\n    gisticAllLesionsFile = all.lesions, gisticAmpGenesFile = amp.genes,\n    gisticDelGenesFile = del.genes, gisticScoresFile = scores.gistic\n)\n#&gt; -Processing Gistic files..\n#&gt; --Processing amp_genes.conf_99.txt\n#&gt; --Processing del_genes.conf_99.txt\n#&gt; --Processing scores.gistic\n#&gt; --Summarizing by samples\nggoncoplot(laml.gistic) +\n    scale_fill_brewer(\"CNV\", palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")",
    "crumbs": [
      "Advanced",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "complete-examples.html",
    "href": "complete-examples.html",
    "title": "13  Complete examples",
    "section": "",
    "text": "13.1 Simple heatmap\nggheatmap(small_mat)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#heatmap-layout-customize",
    "href": "complete-examples.html#heatmap-layout-customize",
    "title": "13  Complete examples",
    "section": "13.2 heatmap layout customize",
    "text": "13.2 heatmap layout customize\n\n13.2.1 Based on dendrogram\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch, y = y)) +\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n13.2.2 Based on kmeans\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n13.2.3 Based on a group variable\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n13.2.4 Based on an ordering weights\nHere, we ordered the heatmap rows based on the row means.\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#heatmap-annotation-plot",
    "href": "complete-examples.html#heatmap-annotation-plot",
    "title": "13  Complete examples",
    "section": "13.3 Heatmap annotation plot",
    "text": "13.3 Heatmap annotation plot\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch, y = y)) +\n    scale_color_brewer(palette = \"Dark2\") +\n    ggalign(mapping = aes(y = value)) +\n    geom_boxplot(aes(factor(.x), fill = .panel)) +\n    scale_fill_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = 0.5) +\n    align_dendro(aes(color = branch), k = 3L) +\n    ggalign(rowSums, aes(y = value)) +\n    geom_bar(stat = \"identity\", aes(fill = factor(.panel))) +\n    scale_fill_brewer(name = NULL, palette = \"Dark2\") +\n    anno_left(size = 0.5) +\n    align_dendro(aes(color = branch), size = 0.5, k = 4L) +\n    ggalign(rowSums, aes(x = value)) +\n    geom_bar(\n        aes(y = .y, fill = factor(.y)),\n        stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    scale_fill_brewer(name = NULL, palette = \"Paired\", guide = \"none\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#multiple-heatmaps",
    "href": "complete-examples.html#multiple-heatmaps",
    "title": "13  Complete examples",
    "section": "13.4 Multiple heatmaps",
    "text": "13.4 Multiple heatmaps\n\n13.4.1 Horizontal layout\n\n(stack_alignh(small_mat) +\n    ggheatmap() +\n    ggheatmap() &\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))) +\n    stack_active() +\n    align_dendro(aes(color = branch), k = 4L, size = 0.2) +\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n13.4.2 Vertical layout\n\nstack_alignv(small_mat) -\n    scheme_theme(\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank()\n    ) +\n    align_dendro(aes(color = branch), k = 4L, size = 0.2) +\n    scale_color_brewer(palette = \"Dark2\") +\n    ggheatmap() +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complete-examples.html#marginal-plots",
    "href": "complete-examples.html#marginal-plots",
    "title": "13  Complete examples",
    "section": "13.5 marginal plots",
    "text": "13.5 marginal plots\n\nggside(mpg, aes(displ, hwy, colour = class)) -\n    # set default theme for all plots in the layout\n    scheme_theme(theme_bw()) +\n    geom_point(size = 2) +\n    # add top annotation\n    anno_top(size = 0.3) -\n    # set default theme for the top annotation\n    scheme_theme(theme_no_axes(\"tb\")) +\n    # add a plot in the top annotation\n    ggfree() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    anno_right(size = 0.3) -\n    # set default theme for the right annotation\n    scheme_theme(theme_no_axes(\"lr\")) +\n    # add a plot in the right annotation\n    ggfree() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    ) +\n    theme(axis.text.x = element_text(angle = 90, vjust = .5)) &\n    scale_color_brewer(palette = \"Dark2\")",
    "crumbs": [
      "Cases",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Complete examples</span>"
    ]
  },
  {
    "objectID": "complexheatmap.html",
    "href": "complexheatmap.html",
    "title": "ComplexHeatmap",
    "section": "",
    "text": "In this chapter, we’ll use ggalign to draw all the heatmap in https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html.\nThe chapter is divided into several sections, following the structure of the original book.",
    "crumbs": [
      "ComplexHeatmap"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html",
    "href": "complexheatmap-single-heatmap.html",
    "title": "14  A Single Heatmap",
    "section": "",
    "text": "14.1 Colors\nIn this thread, we’ll use ggalign to draw all the heatmap in https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html\nIt is important to note that the ComplexHeatmap package reorders the dendrogram by default, while align_dendro() in ggalign does not modify the tree layout.\nAnother key difference is in how the two packages treat the starting point. ggalign considers the left-bottom as the starting point, whereas ComplexHeatmap starts from the left-top. When reordering the dendrogram, ComplexHeatmap does so in decreasing order, while ggalign uses an ascending order.\nTo modify colors in the heatmap, you can use the scale_fill_*() function from ggplot2, which provides a flexible way and enriched pallete to adjust color schemes.\ndim(mat)\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat)\n#&gt; [1] 18 24\nggheatmap(mat) +\n    scale_fill_gradient2(low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro() +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\noob argument in the scale_fill_* function can be used to deal with the outliers.\nmat2 &lt;- mat\nmat2[1, 1] &lt;- 100000\nggheatmap(mat2) +\n    scale_fill_gradient2(\n        low = \"green\", high = \"red\",\n        limits = c(-2, 2),\n        oob = scales::squish\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nWe can use align_plots() to arrange them.\nh1 &lt;- ggheatmap(mat) +\n    scale_fill_gradient2(name = \"mat\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh2 &lt;- ggheatmap(mat / 4) +\n    scale_fill_gradient2(\n        name = \"mat/4\", limits = c(-2, 2L),\n        oob = scales::squish,\n        low = \"green\", high = \"red\"\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n\nh3 &lt;- ggheatmap(abs(mat)) +\n    scale_fill_gradient2(name = \"abs(mat)\", low = \"green\", high = \"red\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\nalign_plots(h1, h2, h3, ncol = 2L)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nggheatmap(mat) +\n    scale_fill_gradientn(colors = rev(rainbow(10))) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nFor character matrix, you can use ggplot2 discrete filling scales.\ndiscrete_mat &lt;- matrix(sample(1:4, 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = c(\"1\", \"2\", \"3\", \"4\")) # black, red, green, blue\nggheatmap(discrete_mat, aes(fill = factor(value))) +\n    scale_fill_manual(values = colors) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\ndiscrete_mat &lt;- matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10)\ncolors &lt;- structure(1:4, names = letters[1:4])\nggheatmap(discrete_mat) +\n    scale_fill_manual(values = colors)\n#&gt; → heatmap built with `geom_tile()`\nmat_with_na &lt;- mat\nna_index &lt;- sample(c(TRUE, FALSE),\n    nrow(mat) * ncol(mat),\n    replace = TRUE, prob = c(1, 9)\n)\nmat_with_na[na_index] &lt;- NA\nggheatmap(mat_with_na) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", na.value = \"black\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nWe won’t compare the LAB and RGB space. If you want to convert color between different color space, try to use farver pacakge.\nIn ggplot2, you can use panel.border argument in theme() function to control the Heatmap body border.\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        panel.border = element_rect(linetype = \"dashed\", fill = NA)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\nYou can use the filling argument to turn off the heatmap cell filling, allowing you to customize the heatmap body geoms. Use the color aesthetic to specify the cell border color and the linewidth aesthetic to set the border width.\nggheatmap(mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\nTo draw a blank heatmap body:\nggheatmap(mat, filling = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#titles",
    "href": "complexheatmap-single-heatmap.html#titles",
    "title": "14  A Single Heatmap",
    "section": "14.2 Titles",
    "text": "14.2 Titles\nWe can use patch_titles() to add titles around each border of the plot. You can use theme() to control the text appearance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(right = \"I am a row title\") +\n    theme(plot.patch_title.right = element_text(face = \"bold\", size = 16)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"I am a column title\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#clustering",
    "href": "complexheatmap-single-heatmap.html#clustering",
    "title": "14  A Single Heatmap",
    "section": "14.3 Clustering",
    "text": "14.3 Clustering\n\n14.3.1 Distance methods\n\n# ComplexHeatmap::Heatmap(mat,\n#   name = \"mat\", clustering_distance_rows = \"pearson\",\n#   column_title = \"pre-defined distance method (1 - pearson)\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = \"pearson\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"pre-defined distance method (1 - pearson)\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", clustering_distance_rows = function(m) dist(m),\n#     column_title = \"a function that calculates distance matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(distance = dist, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    patch_titles(top = \"a function that calculates distance matrix\") +\n    theme(plot.patch_title.top = element_text(face = \"bold\", size = 16)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n14.3.2 Clustering methods\nMethod to perform hierarchical clustering can be specified by method argument, Possible methods are those supported in hclust() function.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     clustering_method_rows = \"single\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(method = \"single\", reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nUse distance = NULL if you don’t want to calculate the distance.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::diana,\n        reorder_dendrogram = TRUE\n    ) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(\n        distance = NULL, method = cluster::agnes,\n        reorder_dendrogram = TRUE\n    ) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n14.3.3 Render dendrograms\nIt’s easy for ggalign to color the branches by setting the color mapping, since ggalign will add the cutree() results into the underlying data.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_dendro(aes(color = branch), k = 2L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#set-row-and-column-orders",
    "href": "complexheatmap-single-heatmap.html#set-row-and-column-orders",
    "title": "14  A Single Heatmap",
    "section": "14.4 Set row and column orders",
    "text": "14.4 Set row and column orders\nWe can use align_order() to set the order.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\",\n#     row_order = order(as.numeric(gsub(\"row\", \"\", rownames(mat)))),\n#     column_order = order(as.numeric(gsub(\"column\", \"\", colnames(mat)))),\n#     column_title = \"reorder matrix\"\n# )\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(as.numeric(gsub(\"row\", \"\", rownames(mat)))) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(as.numeric(gsub(\"column\", \"\", colnames(mat)))) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#seriation",
    "href": "complexheatmap-single-heatmap.html#seriation",
    "title": "14  A Single Heatmap",
    "section": "14.5 Seriation",
    "text": "14.5 Seriation\nalign_reorder() can directly take the seriate() function as the input and extract the ordering information.\n\nmat2 &lt;- max(mat) - mat\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe above code will execute seriate() twice—once for each dimension. However, since a single run of seriate() can provide the ordering for both dimensions, we can manually extract the ordering indices to avoid redundancy.\n\no &lt;- seriation::seriate(mat2, method = \"BEA_TSP\")\nggheatmap(mat2) +\n    scale_fill_gradient2(low = \"blue\", high = \"red\", midpoint = 2L) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(20, \"mm\")) +\n    align_order(seriation::get_order(o, 1L)) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_order(seriation::get_order(o, 2L)) &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFor more use of the seriate() function, please refer to the seriation package.",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#dimension-labels",
    "href": "complexheatmap-single-heatmap.html#dimension-labels",
    "title": "14  A Single Heatmap",
    "section": "14.6 Dimension labels",
    "text": "14.6 Dimension labels\nggplot2 use scales and theme to control the axis labels, Please see chapter for more details.\n\n# ComplexHeatmap::Heatmap(mat,\n#     name = \"mat\", row_names_side = \"left\", row_dend_side = \"right\",\n#     column_names_side = \"top\", column_dend_side = \"bottom\"\n# )\nggheatmap(mat) +\n    scale_x_continuous(position = \"top\") +\n    scale_y_continuous(position = \"right\") +\n    theme(axis.text.x = element_text(angle = 60, hjust = 0)) +\n    anno_left(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_x_continuous(position = \"top\") +\n    anno_bottom(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    scale_y_continuous(position = \"right\") +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    scale_y_continuous(breaks = NULL) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(face = \"bold\", size = 16)\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(\n        axis.text.x = element_text(angle = -60, hjust = 0),\n        axis.text.y = element_text(\n            face = \"bold\", size = 16,\n            colour = c(rep(\"red\", 10), rep(\"blue\", 8))\n        )\n    ) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-single-heatmap.html#heatmap-split",
    "href": "complexheatmap-single-heatmap.html#heatmap-split",
    "title": "14  A Single Heatmap",
    "section": "14.7 Heatmap split",
    "text": "14.7 Heatmap split\n\n14.7.1 Split by k-means clustering\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_kmeans(2L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_kmeans(3L) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe dendrogram was calculated in each group defined by kmeans.\n\n\n14.7.2 Split by categorical variables\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"A\", \"B\"), 9)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(c(\"C\", \"D\"), 12)) +\n    align_dendro(reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n14.7.3 Split by dendrogram\nWhen you splitted by a dendrogram, the cutted height will be indicated with a dashed line.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(k = 3L, reorder_dendrogram = TRUE) +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_dendro(aes(color = branch), k = 3L, reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_dendro(k = 2L, reorder_dendrogram = TRUE) +\n    quad_active() &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n14.7.4 Order of slices (panels)\nThe order of the panels always follow the factor level. Note: the merging of dendrogram between ComplexHeatmap and ggalign is a little different.\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch),\n        reorder_dendrogram = TRUE,\n        reorder_group = TRUE,\n        merge_dendrogram = TRUE\n    ) +\n    quad_active() -\n    with_quad(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(size = unit(15, \"mm\")) +\n    align_group(rep(LETTERS[1:3], 6)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    scale_color_brewer(palette = \"Dark2\") +\n    anno_top(size = unit(15, \"mm\")) +\n    align_group(rep(letters[1:6], 4)) +\n    align_dendro(aes(color = branch), reorder_dendrogram = TRUE) +\n    quad_active() -\n    with_quad(theme(strip.text = element_text()), \"tr\") &\n    theme(plot.margin = margin())\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n14.7.5 Titles for splitting (facet strip text)\nBy default, the facet strip text is removed. You can override this behavior with theme(strip.text = element_text()). Since align_group() does not create a new plot, the panel title can only be added to the heatmap plot.\nwaiting for complete …\n\n\n14.7.6 Graphic parameters for splitting\n\nggh4x::facet_grid2(strip = ggh4x::strip_themed(\n    background_x = list(\n        element_rect(fill = \"red\"),\n        element_rect(fill = \"blue\"),\n        element_rect(fill = \"green\")\n    )\n))\n#&gt; &lt;ggproto object: Class FacetGrid2, FacetGrid, Facet, gg&gt;\n#&gt;     attach_axes: function\n#&gt;     compute_layout: function\n#&gt;     draw_back: function\n#&gt;     draw_front: function\n#&gt;     draw_labels: function\n#&gt;     draw_panels: function\n#&gt;     finish_data: function\n#&gt;     finish_panels: function\n#&gt;     init_scales: function\n#&gt;     map_data: function\n#&gt;     params: list\n#&gt;     setup_aspect_ratio: function\n#&gt;     setup_axes: function\n#&gt;     setup_data: function\n#&gt;     setup_panel_table: function\n#&gt;     setup_params: function\n#&gt;     shrink: TRUE\n#&gt;     strip: &lt;ggproto object: Class StripElemental, Strip, gg&gt;\n#&gt;         assemble_strip: function\n#&gt;         build_strip: function\n#&gt;         clip: inherit\n#&gt;         draw_labels: function\n#&gt;         elements: list\n#&gt;         finish_strip: function\n#&gt;         get_strips: function\n#&gt;         given_elements: list\n#&gt;         incorporate_grid: function\n#&gt;         incorporate_wrap: function\n#&gt;         init_strip: function\n#&gt;         params: list\n#&gt;         setup: function\n#&gt;         setup_elements: function\n#&gt;         strips: list\n#&gt;         super:  &lt;ggproto object: Class StripElemental, Strip, gg&gt;\n#&gt;     train_scales: function\n#&gt;     vars: function\n#&gt;     vars_combine: function\n#&gt;     super:  &lt;ggproto object: Class FacetGrid2, FacetGrid, Facet, gg&gt;",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>A Single Heatmap</span>"
    ]
  },
  {
    "objectID": "complexheatmap-more-examples.html",
    "href": "complexheatmap-more-examples.html",
    "title": "15  More examples",
    "section": "",
    "text": "15.1 Add more information for gene expression matrix\nIn this section, we’ll use ggalign to draw all the heatmap in https://jokergoo.github.io/ComplexHeatmap-reference/book/more-examples.html.\nexpr &lt;- read_example(\"gene_expression.rds\")\nmat &lt;- as.matrix(expr[, grep(\"cell\", colnames(expr))])\nbase_mean &lt;- rowMeans(mat)\nmat_scaled &lt;- t(apply(mat, 1, scale))\ntype &lt;- gsub(\"s\\\\d+_\", \"\", colnames(mat))\n\nheat1 &lt;- ggheatmap(mat_scaled) -\n    scheme_align(free_spaces = \"l\") +\n    scale_y_continuous(breaks = NULL) +\n    scale_fill_viridis_c(option = \"magma\") +\n    # add dendrogram for this heatmap\n    anno_top() +\n    align_dendro() +\n    # add a block for the heatmap column\n    ggalign(data = type, size = unit(1, \"cm\")) +\n    geom_tile(aes(y = 1, fill = factor(value))) +\n    scale_y_continuous(breaks = NULL, name = NULL) +\n    scale_fill_brewer(\n        palette = \"Set1\", name = \"type\",\n        guide = guide_legend(position = \"top\")\n    )\n\nheat2 &lt;- ggheatmap(base_mean, width = unit(2, \"cm\")) +\n    scale_y_continuous(breaks = NULL) +\n    scale_x_continuous(name = \"base mean\", breaks = FALSE) +\n    scale_fill_gradientn(colours = c(\"#2600D1FF\", \"white\", \"#EE3F3FFF\")) +\n    # set the active context of the heatmap to the top\n    # and set the size of the top stack\n    anno_top(size = unit(4, \"cm\")) +\n    # add box plot in the heatmap top\n    ggalign() +\n    geom_boxplot(aes(y = value, fill = factor(.extra_panel))) +\n    scale_x_continuous(expand = expansion(), breaks = NULL) +\n    scale_fill_brewer(\n        palette = \"Dark2\", name = \"base mean\",\n        guide = guide_legend(position = \"top\")\n    ) +\n    theme(axis.title.y = element_blank())\n\nheat3 &lt;- ggheatmap(expr$type, width = unit(2, \"cm\")) +\n    scale_fill_brewer(palette = \"Set3\", name = \"gene type\") +\n    scale_x_continuous(breaks = NULL, name = \"gene type\") +\n    # add barplot in the top annotation, and remove the spaces in the y-axis\n    anno_top() -\n    scheme_align(free_spaces = \"lr\") +\n    ggalign(limits = FALSE) +\n    geom_bar(\n        aes(.extra_panel, fill = factor(value)),\n        position = position_fill()\n    ) +\n    scale_y_continuous(expand = expansion()) +\n    scale_fill_brewer(palette = \"Set3\", name = \"gene type\", guide = \"none\") -\n    scheme_theme(plot.margin = margin())\n\nstack_alignh(mat_scaled) +\n    stack_active(sizes = c(0.2, 1, 1)) +\n    # group stack rows into 5 groups\n    align_kmeans(centers = 5L) +\n    # add a block plot for each group in the stack\n    ggalign(size = unit(1, \"cm\"), data = NULL) +\n    geom_tile(aes(x = 1, fill = factor(.panel))) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"Kmeans group\") +\n    scale_x_continuous(breaks = NULL, name = NULL) +\n    # add a heatmap plot in the stack\n    heat1 +\n    # add another heatmap in the stack\n    heat2 +\n    # we move into the stack layout\n    stack_active() +\n    # add a point plot\n    ggalign(data = expr$length, size = unit(2, \"cm\")) +\n    geom_point(aes(x = value)) +\n    labs(x = \"length\") +\n    theme(\n        panel.border = element_rect(fill = NA),\n        axis.text.x = element_text(angle = -60, hjust = 0)\n    ) +\n    # add another heatmap\n    heat3 &\n    theme(\n        plot.background = element_blank(),\n        panel.background = element_blank(),\n        legend.background = element_blank()\n    )\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>More examples</span>"
    ]
  },
  {
    "objectID": "complexheatmap-more-examples.html#the-measles-vaccine-heatmap",
    "href": "complexheatmap-more-examples.html#the-measles-vaccine-heatmap",
    "title": "15  More examples",
    "section": "15.2 The measles vaccine heatmap",
    "text": "15.2 The measles vaccine heatmap\n\nmat &lt;- read_example(\"measles.rds\")\nggheatmap(mat, filling = FALSE) +\n    geom_tile(aes(fill = value), color = \"white\") +\n    scale_fill_gradientn(\n        colours = c(\"white\", \"cornflowerblue\", \"yellow\", \"red\"),\n        values = scales::rescale(c(0, 800, 1000, 127000), c(0, 1))\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right() +\n    align_dendro(plot_dendrogram = FALSE) +\n    anno_top(size = unit(2, \"cm\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(y = value), fill = \"#FFE200\", stat = \"identity\") +\n    scale_y_continuous(expand = expansion()) +\n    ggtitle(\"Measles cases in US states 1930-2001\\nVaccine introduced 1961\") +\n    theme(plot.title = element_text(hjust = 0.5)) +\n    anno_right(size = unit(2, \"cm\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(x = value),\n        fill = \"#FFE200\", stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    scale_x_continuous(expand = expansion()) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))",
    "crumbs": [
      "ComplexHeatmap",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>More examples</span>"
    ]
  }
]