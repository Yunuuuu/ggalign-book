[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggalign: Bridging the Grammar of Graphics and Complex layout",
    "section": "",
    "text": "Preface\nWelcome to ggalign documents, Examples in the book are generated under version \"0.0.5.9000\"\n\n\nSession infomations\n\nsessionInfo()\n\nR version 4.4.2 (2024-10-31)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 22.04.5 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0\n\nlocale:\n [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       \n [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   \n [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          \n[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   \n\ntime zone: UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.37      utf8_1.2.4         R6_2.5.1           fastmap_1.2.0     \n [5] xfun_0.49          magrittr_2.0.3     gtable_0.3.6       glue_1.8.0        \n [9] tibble_3.2.1       ggalign_0.0.5.9000 knitr_1.49         pkgconfig_2.0.3   \n[13] htmltools_0.5.8.1  rmarkdown_2.29     lifecycle_1.0.4    ggplot2_3.5.1     \n[17] cli_3.6.3          fansi_1.0.6        scales_1.3.0       grid_4.4.2        \n[21] vctrs_0.6.5        compiler_4.4.2     tools_4.4.2        pillar_1.9.0      \n[25] munsell_0.5.1      evaluate_1.0.1     colorspace_2.1-1   rlang_1.1.4       \n[29] jsonlite_1.8.9",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Installation\nggalign extends ggplot2 by providing advanced tools for aligning and organizing multiple plots, particularly those that automatically reorder observations, such as dendrogram. It offers fine control over layout adjustment and plot annotations, enabling you to create complex layout while still using the familiar grammar of ggplot2.\nYou can install ggalign from CRAN using:\ninstall.packages(\"ggalign\")\nAlternatively, install the development version from r-universe with:\ninstall.packages(\"ggalign\",\n    repos = c(\"https://yunuuuu.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nor from GitHub with:\n# install.packages(\"remotes\")\nremotes::install_github(\"Yunuuuu/ggalign\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#general-design",
    "href": "introduction.html#general-design",
    "title": "1  Introduction",
    "section": "1.2 General design",
    "text": "1.2 General design\nThe core feature of ggalign lies in its integration of the grammar of graphics principles into advanced visualization, achieved through its object-oriented Layout system. Two basic Layout classes are available:\n\nthe StackLayout class: Put plots horizontally or vertically.\nthe QuadLayout class: Arranges plots in the four quadrants (top, left, bottom, right) around a main plot. This layout is ideal for designs that require supplementary plots or annotations surrounding a central figure.\n\nBoth Layout classes support the alignment of observations (ordinal variable). Observations refer to data points or samples, allowing for consistent alignment of corresponding data across multiple plots when using the same axis values. Depending on whether you want to align observations across multiple plots within the layout, the following variants are available:\nFor StackLayout:\n\nstack_align(): Align the observations along the stack.\nstack_free(): Does not align the observations.\n\nFor QuadLayout:\n\nquad_free/ggside: Never align observations.\nquad_alignh: Align observations in the horizontal direction.\nquad_alignv: Align observations in the vertical direction.\nquad_alignb: Align observations in both horizontal and vertical directions.\n\n\n\n\nGeneral design of ggalign",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#getting-started",
    "href": "introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.3 Getting Started",
    "text": "1.3 Getting Started\n\nlibrary(ggalign)\n\nLoading required package: ggplot2\n\n\nThe usage of ggalign is simple if you’re familiar with ggplot2 syntax, the typical workflow includes:\n\nInitialize the layout using:\n\n\nstack_layout(): Arrange Plots Horizontally or Vertically\n\ncross_align: Arrange Plots Crosswise Horizontally or Vertically\n\nquad_layout(): Arrange Plots in the Quad-Side of a main plot\n\nggheatmap(): Create a Complex Heatmap.\nggoncoplot(): Create OncoPrint Visualizations from Genetic Alteration Data\n\n\n\nCustomize the layout with:\n\n\nalign_group(): Group observations into panel with a group variable.\nalign_kmeans(): Group observations into panel by kmeans.\nalign_order(): Reorder layout observations based on statistical weights or by manually specifying the observation index.\nalign_hclust()/align_dendro(): Reorder or Group layout based on hierarchical clustering.\n\n\nAdding plots with ggalign() or ggfree(), and then layer additional ggplot2 elements such as geoms, stats, or scales.\n\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(56), nrow = 7)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\n\nEvery *_layout() function accepts default data, which will be inherited by all plots within the layout.\nHere’s a simple example:\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nIn this example:\n\nWe initialize a vertical stack (stack_alignv(small_mat)).\nReorder the observations based on hierarchical clustering and add a dendrogram tree (align_dendro()).\nAdd y-axis text (theme(axis.text.y = element_text())).\n\nThis produces a simple dendrogram. By default, stack_alignv() removes the axis text on the axis used for aligning observations. This is because it’s often unclear which plot should display the axis text, as typically, we want it to appear in only one plot. However, you can easily use the theme() function to control where the axis text appears.\nInternally, align_dendro() will reorder the observations based on the dendrogram, and other plots in the layout will follow this ordering.\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(.names, value), stat = \"identity\") +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nIn this example:\n\nWe initialize a vertical stack (stack_alignv(small_mat)).\nReorder the observations based on hierarchical clustering and add a dendrogram tree (align_dendro()).\nCreate a new ggplot in the layout, and use data based on the sum of the layout data (ggalign(data = rowSums)).\nAdd a bar layer (geom_bar(aes(.names, value), stat = \"identity\")).\nAdd y-axis text (theme(axis.text.y = element_text())).\n\nThe data in the underlying ggplot object of ggalign function contains at least following columns (more details will be introduced in the later chapter):\n\n.panel: the group panel for the aligned axis. It means x-axis for vertical stack layout (including top and bottom annotation), y-axis for horizontal stack layout (including left and right annotation).\n.x or .y: the x or y coordinates\n.names and .index: A factor of the names (only applicable when names exists) and an integer of index of the original data.\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\nIt is recommended to use .x/.y, or .names as the x/y mapping.\nalign_dendro() can also split the observations into groups.\n\nstack_alignv(small_mat) +\n    align_dendro(k = 3) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(.names, value, fill = .panel), stat = \"identity\") +\n    scale_fill_brewer(palette = \"Dark2\", name = \"Group\") +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nIn this example:\n\nWe initialize a vertical stack (stack_alignv(small_mat)).\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree (align_dendro(k = 3)).\nCreate a new ggplot in the layout, and use data based on the sum of the layout data (ggalign(data = rowSums)).\nAdd a bar layer (geom_bar(aes(.names, value), stat = \"identity\")).\nAdd fill mapping scale (scale_fill_brewer(palette = \"Dark2\", name = \"Group\")).\nAdd y-axis text (theme(axis.text.y = element_text())).\n\nOne common visualization associated with the dendrogram is the heatmap. You can use ggheatmap() to initialize a heatmap layout. When grouping the observations using align_dendro(k = 3), a special column named branch is added, which you can use to color the dendrogram tree.\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_dendro(aes(color = branch), k = 3) +\n    scale_fill_brewer(palette = \"Dark2\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nIn this example:\n\nWe initialize a heatmap layout (ggheatmap(small_mat)).\nwe initialize an annotation in the left side of the heatmap body, and set it as the active context, in this way, all following addition will be directed to the left annotation. (anno_left())\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree, coloring the tree by branch (align_dendro(k = 3)).\nAdd fill mapping scale (scale_fill_brewer(palette = \"Dark2\")).\n\nggheatmap() will automatically add axis text in the heatmap body, so you don’t need to manually adjust axis text visibility using theme(axis.text.x = element_text())/theme(axis.text.y = element_text()).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "stack-layout.html",
    "href": "stack-layout.html",
    "title": "2  stack layout",
    "section": "",
    "text": "2.1 Input data\nstack_layout() arranges plots either horizontally or vertically, and we can also use the alias ggstack(). Based on whether we want to align the observations, there are two types of stack layouts:\nSeveral aliases are available for convenience:\nWhen aligning observations, we typically use a matrix, as it is easy to melt the matrix into a long-formatted data frame. Additionally, matrices are used to fit the observation concept, as they can be transposed (rows to columns, columns to rows), which is necessary for use in functions like quad_layout() and ggheatmap(), where observations may be aligned in both directions simultaneously.\nBy default, fortify_data_frame() will invoke the ggplot2::fortify() function for conversion. Note, for matrix, it will be converted to a long-formatted data frame.\nstack_align()/stack_free() will set up the layout, but no plot will be drawn until you add a plot element:\nstack_alignh(small_mat) +\n    layout_annotation(theme = theme(plot.background = element_rect(color = \"red\")))\n# the same for `stack_free()`\nIn this example, we use layout_annotation() to insert a plot background in the entire layout.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack_layout_input_data",
    "href": "stack-layout.html#sec-stack_layout_input_data",
    "title": "2  stack layout",
    "section": "",
    "text": "For stack_free(), a data frame is required, and the input will be automatically converted using fortify_data_frame() if needed.\nFor stack_align(), a matrix is required, and the input will be automatically converted using fortify_matrix() if needed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#layout-customization",
    "href": "stack-layout.html#layout-customization",
    "title": "2  stack layout",
    "section": "2.2 Layout Customization",
    "text": "2.2 Layout Customization\nWhen we use stack_align(), it aligns the observations across multiple plots along the specified direction:\n\nFor stack_alignh(): Alignment occurs along the horizontal direction (y-axis).\nFor stack_alignv(): Alignment occurs along the vertical direction (x-axis).\n\nThe package offers a suite of align_* functions designed to give you precise control over the layout. These functions enable you to reorder the observations or partition the observations into multiple groups. Instead of detailing each align_* function individually, we will focus on the general usage and how to combine them with stack_align().\nHere, we remain take align_dendro() as a example, it can reorder the observations, split them into groups, and can add a plot for visualization.\nWhen used for stack_alignh(), the observations are aligned along the y-axis:\n\nstack_alignh(small_mat) +\n    align_dendro()\n\n\n\n\n\n\n\n\nWhen used for stack_alignv(), the observations are aligned along the x-axis:\n\nstack_alignv(small_mat) +\n    align_dendro()\n\n\n\n\n\n\n\n\nWhen align_dendro() is added to the layout, it performs following actions:\n1. reorder the observations.\n2. set the active plot to the dendrogram.\nThe active plot refers to the plot that subsequent ggplot2 components will target. In this case, the active plot is the dendrogram, and any new layers added will be applied to it. For instance, we can add additional layers to visualize the dendrogram’s structure or data. The default data underlying the ggplot object of align_dendro() consists of the dendrogram node data, which can be used to further customize the dendrogram visualization. However, it is possible to use the dendrogram’s edge data for customization, which I will introduce in a later chapter.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    geom_point()\n\n\n\n\n\n\n\n\nThe active argument controls whether a plot is set as the active plot. It accepts an active() object with the use argument to specify if the plot should be active.\n\nstack_alignh(small_mat) +\n    align_dendro(active = active(use = FALSE)) +\n    geom_point()\n\nError in `stack_layout_add()`:\n! Cannot add `geom_point()` to `stack_align()`\nℹ No active plot component\nℹ Did you forget to initialize a &lt;ggplot&gt; object with `ggalign()` or\n  `ggfree()`?\n\n\nUsually, you don’t need to set this manually, as the active context is automatically applied only for functions that add plot areas. You can inspect whether a align_* function will add a plot by print it:\n\nalign_dendro()\n\n`align_dendro()` object:\n  plot: yes\n  reorder: yes\n  split: no\n\n\nYou might find it confusing that we mentioned align_dendro() will split observations into groups, while the print output shows split = \"no\". This happens because we haven’t specified the k/h argument in align_dendro().\n\nalign_dendro(k = 3L)\n\n`align_dendro()` object:\n  plot: yes\n  reorder: yes\n  split: yes\n\n\nYou don’t need to explicitly provide data to align_dendro(). By default, it inherits data from the layout. However, you can always provide another data source, but note that this package uses the concept of “number of observations” (NROW()). When aligning the observations, you must ensure the number of observations is consistent across all plots.\n\nset.seed(123)\nstack_alignh(small_mat) +\n    align_dendro(data = matrix(rnorm(56), nrow = 8)) +\n    theme(axis.text.y = element_text())\n\nError in `align()`:\n! `align_dendro(data = matrix(rnorm(56), nrow = 8))` (nobs: 8) is not\n  compatible with the `stack_align()` (nobs: 7)\n\n\n\nset.seed(123)\nstack_alignh(small_mat) +\n    align_dendro(data = matrix(rnorm(70), nrow = 7)) +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nAlternatively, you can provide a function (or purrr-lambda) that will be applied to the layout’s matrix. Note that, for layouts that align observations, a matrix is always required, so the data input must be in matrix form.\n\nset.seed(123)\nstack_alignh(small_mat) +\n    align_dendro(data = ~ .x[sample(nrow(.x)), ]) +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nWithout adding another plot, it’s difficult to appreciate the benefits. Let’s now explore how to incorporate a plot.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#plot-initialize",
    "href": "stack-layout.html#plot-initialize",
    "title": "2  stack layout",
    "section": "2.3 Plot initialize",
    "text": "2.3 Plot initialize\nThere are two primary functions for adding plots:\n\nalign_gg()/ggalign(): Create a ggplot object and align with the layout.\nfree_gg()/ggfree(): Create a ggplot object without aligning.\n\nBoth functions initialize a ggplot object and, by default, set the active plot when added to the layout.\nFor stack_align(), plots can be added regardless of whether they need to align observations.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can build the plot layer separately and then add it to the layout:\n\nmy_bar &lt;- ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \nstack_alignh(small_mat) +\n    align_dendro() +\n    my_bar\n\n\n\n\n\n\n\n\nThe active argument can also control the place of the plot area to be added. It accepts an active() object with the order argument to specify the order of the plot area.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums, active = active(order = 1)) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can also stack plots vertically using stack_alignv():\n\nstack_alignv(small_mat) + \n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nstack_align() can also add plot without aligning observations. free_gg() focuses on layout integration without enforcing strict axis alignment. ggfree() is an alias for free_gg.\n\nstack_alignv() +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nThe & operator applies the added element to all plots in the layout, similar to its functionality in the patchwork package.\nFor stack_free(), only free plots (ggfree()) can be added. This layout arranges plots in one row or column without enforcing axis alignment:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nBy default, ggfree() will also inherit data from the layout and call fortify_data_frame() to convert the data to a data frame. So, note that if the layout data is a matrix, it will be converted into a long-formatted data frame.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#plot-size",
    "href": "stack-layout.html#plot-size",
    "title": "2  stack layout",
    "section": "2.4 Plot Size",
    "text": "2.4 Plot Size\nBoth ggalign() and ggfree() functions have a size argument to control the relative width (for horizontal stack layout) or height (for vertical stack layout) of the plot’s panel area.\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 2) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 1) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nAlternatively, you can define an absolute size by using a unit() object:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = unit(1, \"cm\")) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#active-plot",
    "href": "stack-layout.html#active-plot",
    "title": "2  stack layout",
    "section": "2.5 active plot",
    "text": "2.5 active plot\nAs mentioned earlier, the active plot refers to the plot that subsequent ggplot2 components will target. The package provide two functions to work with active plot.\n\nstack_switch(): switch the active context\nstack_active: An alias for stack_switch(), which sets what = NULL\n\nThe stack_switch() function accepts the what argument, which can either be the index of the plot added (based on its adding order) or the plot name specified via the active() object using the name argument.\nNote that the what argument must be explicitly named, as it is placed second in the function signature. This is because, in most cases, we don’t need to switch the active plot manually—adjusting the order of plot additions typically suffices.\n\n\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    # switch to the `align_dendro()` plot area\n    stack_switch(what = 1) +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by integer\")\n\n\n\n\n\n\n\n\n\n\n\nstack_alignh(small_mat) +\n    align_dendro(active = active(name = \"tree\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    # switch to the `align_dendro()` plot area\n    stack_switch(what = \"tree\") +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by string\")\n\n\n\n\n\n\n\n\n\n\nIn the example, we use layout_title() to insert a title for the entire layout. Alternatively, you can add a title to a single plot with ggtitle().\nBy setting what = NULL (or alias stack_active()), we remove the active plot. This is particularly useful when the active plot is a nested Layout object, as any additions would otherwise be directed to that nested Layout. By removing the active plot, you can continue adding components directly to the StackLayout.\nNow, let’s move on to the next chapter where I’ll introduce a new Layout.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html",
    "href": "heatmap-layout.html",
    "title": "3  heatmap layout",
    "section": "",
    "text": "3.1 input data\nThe heatmap_layout() function provides a powerful way to create customizable heatmaps in R using ggplot2. This chapter will guide you through its usage.\nheatmap_layout() is a specialized version of quad_alignb(), which itself is a specific variant of QuadLayout (quad_layout()) designed to align observations both horizontally and vertically. We introduce heatmap_layout() directly, as it is more familiar to many users, especially those experienced with popular heatmap packages like pheatmap and ComplexHeatmap.\nheatmap_layout() simplifies the creation of heatmap plots by integrating essential elements for a standard heatmap layout, ensuring that the appropriate data mapping and visualization layers are automatically applied. ggheatmap() is an alias for heatmap_layout().\nAs mentioned in Section 2.1, we typically require a matrix for the Layout which need align observations. Internally, fortify_matrix() will be used to process the data. You can provide a numeric or character vector, a data frame, or any other data type that can be converted into a matrix using as.matrix().\nggheatmap(small_mat)\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#heatmap-body",
    "href": "heatmap-layout.html#heatmap-body",
    "title": "3  heatmap layout",
    "section": "3.2 heatmap body",
    "text": "3.2 heatmap body\nA ggplot object will be automatically created for the heatmap body, the matrix input will be converted into a long formated data frame when drawing. The data in the underlying ggplot object contains following columns:\n\n.xpanel and .ypanel: the column and row panel\n.x and .y: the x and y coordinates\n.row_names and .column_names: A factor of the row and column names of the original matrix (only applicable when names exist).\n.row_index and .column_index: the row and column index of the original matrix.\nvalue: the actual matrix value.\n\nThe default mapping will use aes(.data$.x, .data$.y), but can be customized using mapping argument.\nBy default, the heatmap body is regarded as the active plot, meaning you can add ggplot2 elements directly to the heatmap body.\n\nggheatmap(small_mat) + geom_point() + scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nBy default, ggheatmap()/heatmap_layout() adds a heatmap layer. If the matrix has more than 20,000 cells (nrow * ncol &gt; 20000), it uses geom_raster() for performance efficiency; for smaller matrices, geom_tile() is used. You can explicitly choose the layer by providing a single string (\"raster\" or \"tile\") in the filling argument.\n\nggheatmap(small_mat, filling = \"raster\")\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = \"tile\")\n\n\n\n\n\n\n\n\nNote, the filling layer will always use mapping of aes(.data$.x, .data$.y), if you want to customize filling, you can set filling = NULL, which will remove the filling layer and allow you to add custom filling geoms.\n\nggheatmap(small_mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"black\", width = 0.9, height = 0.9)\n\n\n\n\n\n\n\n\nA heatmap pie charts can be easily drawn:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#rasterization",
    "href": "heatmap-layout.html#rasterization",
    "title": "3  heatmap layout",
    "section": "3.3 rasterization",
    "text": "3.3 rasterization\nWhen working with large heatmaps, it’s often beneficial to rasterize the heatmap body layer. You can achieve this by using the raster_magick() function. The res argument controls the resolution of the raster image. By default, the res argument matches the resolution of the current device, but specifying a different value can help reduce the resolution of the rasterized heatmap body.\n\nggheatmap(small_mat, filling = NULL) +\n    raster_magick(geom_tile(aes(fill = value)), res = 50)\n\n\n\n\n\n\n\n\nBy leveraging raster_magick(), you can also perform image post-processing using the magick package. This allows for custom image resizing with filters.\n\nggheatmap(small_mat, filling = NULL) +\n    # Use `magick::filter_types()` to check available `filter` arguments\n    raster_magick(geom_raster(aes(fill = value)),\n        magick = function(image) {\n            magick::image_resize(image,\n                # we resize to the 50% of width\n                geometry = \"50%x\", filter = \"Lanczos\"\n            )\n        }\n    )\n\n\n\n\n\n\n\n\nNote: When using magick::image_resize(), you should specify the geometry argument to resize the image. If only the filter is specified, it will only distort the image data (though subtle). For more information on image resizing, refer to ImageMagick’s resize documentation.\nYou can also rasterize all plots in the layout directly with raster_magick(). This method is defined for both ggheatmap()/quad_layout() and stack_layout() objects.\nAdditionally, You can use external packages like ggrastr or ggfx to rasterize the heatmap body.\n\nggheatmap(small_mat, filling = FALSE) +\n    ggrastr::rasterise(geom_tile(aes(fill = value)), dev = \"ragg\")\n\n\n\n\n\n\n\n\nLikewise, you can also rasterize all plots in the layout directly with ggrastr::rasterise() for both ggheatmap()/quad_layout() and stack_layout().\n\nggrastr::rasterise(ggheatmap(small_mat), dev = \"ragg\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nFurthermore, ggfx offers many image filters that can be applied to ggplot2 layers. See the package for the details.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#annotations",
    "href": "heatmap-layout.html#annotations",
    "title": "3  heatmap layout",
    "section": "3.4 annotations",
    "text": "3.4 annotations\nIn ggheatmap()/quad_layout(), annotations are handled by a stack_layout() object and can be positioned at the top, left, bottom, or right of the main plot (heatmap body).\nBy default, ggheatmap()/quad_layout() do not activate an annotation, You can use quad_anno() to activate an annotation, directing all subsequent additions to the specified annotation position. The quad_anno() function has the following aliases:\n\nanno_top: A special case of quad_anno() with position = \"top\".\nanno_left: A special case of quad_anno() with position = \"left\".\nanno_bottom: A special case of quad_anno() with position = \"bottom\".\nanno_right: A special case of quad_anno() with position = \"right\".\n\nWhen quad_anno() is added to a ggheatmap()/quad_layout(), it will try to automatically create a new stack_layout() (either stack_align() or stack_free()) depending on whether you want to align observations in the specified direction. For top and bottom annotations, stack_alignv() or stack_freev() will be used; for left and right annotations, stack_alignh() or stack_freeh() will be applied.\nAdditionally, quad_anno() will set the active context to the annotation. This means that subsequent additions will be directed to the annotation rather than the main plot. We use the term active context in contrast to active plot (as described in Chapter 2), since the annotation is a Layout object.\n\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the left annotation\n    anno_left() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nBy default, the annotation stack_layout() will inherit data from ggheatmap()/quad_layout(). If the observations require alignment vertically, this means the data from ggheatmap()/quad_layout() should be a matrix, the column annotations will also require a matrix and the matrix from ggheatmap()/quad_layout() will be transposed for use in the column annotations.\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can further customize the layout design or add new plots in the annotation stack, as described in Chapter 2.\n\nggheatmap(small_mat) +\n    # in the heatmap body, we set the axis text theme\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the right annotation\n    anno_right() +\n    # in the right annotation, we add a dendrogram\n    align_dendro(k = 3L) +\n    # in the dendrogram, we add a point layer\n    geom_point(aes(color = factor(branch)))\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nIn this example:\n\nanno_right() initialize the right annotation stack, and change the active context to the right of the heatmap.\nalign_dendro(k = 3L) adds a dendrogram to the annotation and sets itself as the active plot in the annotation stack.\ngeom_point(aes(color = factor(branch))) is then added to this active plot within the annotation stack, here, it means the align_dendro() plot.\n\nggheatmap() aligns observations both horizontally and vertically, so it’s safe to always use quad_anno() directly, as all annotations require a matrix, and the layout data is also a matrix. However, for quad_alignh() and quad_alignv(), which only align observations in one direction, the data in the layout may not fit the data for the annotation (when the layout requires alignment of observations, we typically use a matrix, regardless of whether alignment is needed in one or two directions) - quad_alignh(): aligning observations in horizontal direction, for column annotations, we ll need a data frame for stack_free(). - quad_alignv(): aligning observations in vertical direction, for row annotations, we ll need a data frame for stack_free().\nIn both conditions, quad_anno() won’t initialize the annotation by default, instead, you must provide the annotation stack_layout() manually.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#adding-stack-layout",
    "href": "heatmap-layout.html#adding-stack-layout",
    "title": "3  heatmap layout",
    "section": "3.5 Adding stack layout",
    "text": "3.5 Adding stack layout\nLike adding plot in stack_layout() (Chapter 2), when the direction neeed alignment, you can add a stack_layout() regardless of whether it need to align observations.\nTo add a stack_layout() to the ggheatmap(), we must prevent the automatical creation of annotation by quad_anno() by setting initialize = FALSE\n\n\n\nmy_stack_align &lt;- stack_alignh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_align +\n    layout_title(\"stack_align()\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nmy_stack_free &lt;- stack_freeh(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_free +\n    layout_title(\"stack_free()\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nNote when aligning the observations, you must ensure the number of observations is consistent in the direction. So for column annotations, you need transpose the data manually.\n\nmy_stack &lt;- stack_alignv(t(small_mat)) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    anno_top(initialize = FALSE) +\n    my_stack\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_active",
    "href": "heatmap-layout.html#quad_active",
    "title": "3  heatmap layout",
    "section": "3.6 quad_active()",
    "text": "3.6 quad_active()\nTo remove the active context and redirect additions back to the heatmap body, you can use quad_active().\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_active() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_switchhmanno",
    "href": "heatmap-layout.html#quad_switchhmanno",
    "title": "3  heatmap layout",
    "section": "3.7 quad_switch()/hmanno()",
    "text": "3.7 quad_switch()/hmanno()\nWe also provide quad_switch()/hmanno() (heatmap annotation) which integrates quad_active() and quad_anno() into one function for ease of use. Feel free to use any of these functions to streamline your annotation process.\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    quad_switch(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_switch() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    hmanno(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    hmanno() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#plot-size",
    "href": "heatmap-layout.html#plot-size",
    "title": "3  heatmap layout",
    "section": "3.8 Plot Size",
    "text": "3.8 Plot Size\n\n3.8.1 Heatmap Body Size\nYou can specify the relative sizes of the heatmap body using the width and height arguments in the ggheatmap() function.\n\nggheatmap(small_mat, height = 2) +\n    anno_top() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nAlternatively, the quad_active() function allows you to control the heatmap body sizes.\n\nggheatmap(small_mat) +\n    quad_active(height = 2) +\n    anno_top() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n3.8.2 Annotation Stack Size\nThe quad_anno() function allows you to control the total annotation stack size. The size argument controls the relative width (for left and right annotations) or height (for top and bottom annotations) of the whole annotation stack.\n\nggheatmap(small_mat) +\n    anno_top(size = 1) +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can also specify it as an absolute size using unit():\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  }
]