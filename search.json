[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggalign: Bridging the Grammar of Graphics and Complex layout",
    "section": "",
    "text": "Preface\nWelcome to ggalign documents. Examples in the book are generated under version 0.0.5.9000.\nIn the world of data visualization, aligning multiple plots in a coherent and organized layout is often a challenging task, especially when dealing with complex datasets that require precise alignment across rows, columns, and even within plot elements. While existing tools provide some solutions, they often fall short in offering the flexibility, control, and simplicity that users need to create intricate and beautiful plots. This is where ggalign comes in.\nThe ggalign package, built on top of the powerful ggplot2 framework, is designed to solve this very problem. It offers a suite of functions specifically crafted for aligning and organizing plots with minimal effort. Whether you need to align observations based on statistical measures, group plots by categorical factors, or fine-tune the layout to match the precise needs of your data, ggalign gives you the tools you need to create polished, publication-ready visualizations.\nThis book serves as both an introduction to the ggalign package and a comprehensive guide to mastering its features. Whether you’re a beginner or an experienced user of ggplot2, you’ll find detailed explanations, step-by-step tutorials, and real-world examples to help you leverage the full potential of ggalign in your work.\nThroughout this book, we will cover everything from basic concepts to advanced layout customizations, focusing on key functions like stack_layout(), align_* series (including align_group(), align_order(), and align_hclust()), and how to combine them with other ggplot2 layers to create aligned plots. Additionally, you’ll learn how to adapt ggalign for different data types and scenarios, allowing you to develop flexible, dynamic visualizations tailored to your specific needs.\nBy the end of this book, you will be equipped to use ggalign effectively in your own projects, whether for scientific research, data analysis, or any other field where data visualization is key. Our goal is to provide you with the knowledge and confidence to tackle complex visualization challenges and transform your datasets into clear, impactful, and visually appealing plots.\nThank you for choosing ggalign. We hope this book will inspire you to explore the endless possibilities that come with aligned data visualization.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Installation\nggalign extends ggplot2 by providing advanced tools for aligning and organizing multiple plots, particularly those that automatically reorder observations, such as dendrogram. It offers fine control over layout adjustment and plot annotations, enabling you to create complex visualizations while leveraging the familiar grammar of ggplot2.\nYou can install ggalign from CRAN using:\ninstall.packages(\"ggalign\")\nAlternatively, install the development version from r-universe with:\ninstall.packages(\"ggalign\",\n    repos = c(\"https://yunuuuu.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nor from GitHub with:\n# install.packages(\"remotes\")\nremotes::install_github(\"Yunuuuu/ggalign\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#general-design",
    "href": "introduction.html#general-design",
    "title": "1  Introduction",
    "section": "1.2 General design",
    "text": "1.2 General design\nThe core feature of ggalign lies in its integration of the grammar of graphics into advanced visualization through its object-oriented Layout system. The package provides two main Layout classes:\n\nthe StackLayout class: Put plots horizontally or vertically.\nthe QuadLayout class: Arranges plots in the four quadrants (top, left, bottom, right) around a main plot. This layout is ideal for designs that require supplementary plots or annotations surrounding a central figure.\n\nBoth Layout classes support the alignment of observations (ordinal variable). Observations refer to data points or samples, allowing for consistent alignment of corresponding data across multiple plots when using the same axis values. Depending on whether you want to align observations across multiple plots within the layout, the following variants are available:\nFor StackLayout:\n\nstack_align(): Align the observations along the stack.\nstack_free(): Does not align the observations.\n\nFor QuadLayout:\n\nquad_free/ggside: Never align observations.\nquad_alignh: Align observations in the horizontal direction.\nquad_alignv: Align observations in the vertical direction.\nquad_alignb: Align observations in both horizontal and vertical directions.\n\n\n\n\nGeneral design of ggalign",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#getting-started",
    "href": "introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.3 Getting Started",
    "text": "1.3 Getting Started\n\nlibrary(ggalign)\n#&gt; Loading required package: ggplot2\n\nThe usage of ggalign is simple if you’re familiar with ggplot2 syntax, the typical workflow includes:\n\nInitialize the layout using:\n\n\nstack_layout(): Arrange Plots Horizontally or Vertically\n\ncross_align: Arrange Plots Crosswise Horizontally or Vertically\n\nquad_layout(): Arrange Plots in the Quad-Side of a main plot\n\nggheatmap(): Create a Complex Heatmap.\nggoncoplot(): Create OncoPrint Visualizations from Genetic Alteration Data\n\n\n\nCustomize the layout with:\n\n\nalign_group(): Group observations into panel with a group variable.\nalign_kmeans(): Group observations into panel by kmeans.\nalign_order(): Reorder layout observations based on statistical weights or by manually specifying the observation index.\nalign_hclust(): Reorder or group observations based on hierarchical clustering.\nalign_reorder: Reorder observations using an arbitrary statistical function.\n\n\nAdding plots with align_dendro(), ggalign() or ggfree(), and then layer additional ggplot2 elements such as geoms, stats, or scales.\n\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(56), nrow = 7)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\n\nEvery *_layout() function accepts default data, which will be inherited by all plots within the layout.\nHere’s a simple example:\n\n1stack_alignv(small_mat) +\n2    align_dendro() +\n3    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThis produces a simple dendrogram. By default, stack_alignv() removes the axis text on the axis used for aligning observations. This is because it’s often unclear which plot should display the axis text, as typically, we want it to appear in only one plot. However, you can easily use the theme() function to control where the axis text appears.\nInternally, align_dendro() will reorder the observations based on the dendrogram, and other plots in the layout will follow this ordering.\n\n1stack_alignv(small_mat) +\n2    align_dendro() +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.names, value), stat = \"identity\") +\n5    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThe data in the underlying ggplot object of ggalign() function contains at least following columns (more details will be introduced in the Section 5.1):\n\n.panel: the group panel for the aligned axis. It means x-axis for vertical stack layout, y-axis for horizontal stack layout.\n.x or .y: the x or y coordinates\n.names and .index: A factor of the names (only applicable when names exists) and an integer of index of the original data.\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\nIt is recommended to use .x/.y, or .names as the x/y mapping.\nalign_dendro() can also split the observations into groups.\n\n1stack_alignv(small_mat) +\n2    align_dendro(k = 3) +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.names, value, fill = .panel), stat = \"identity\") +\n5    scale_fill_brewer(palette = \"Dark2\", name = \"Group\") +\n6    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd fill mapping scale.\n\n6\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nOne common visualization associated with the dendrogram is the heatmap. You can use ggheatmap() to initialize a heatmap layout. When grouping the observations using align_dendro(k = 3), a special column named branch is added, which you can use to color the dendrogram tree.\n\n1ggheatmap(small_mat) +\n2    anno_left() +\n3    align_dendro(aes(color = branch), k = 3) +\n4    scale_fill_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\nWe initialize a heatmap layout.\n\n2\n\nwe initialize an annotation in the left side of the heatmap body, and set it as the active context, in this way, all following addition will be directed to the left annotation.\n\n3\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree, coloring the tree by branch.\n\n4\n\nAdd fill mapping scale.\n\n\n\n\n\n\n\n\n\n\n\nggheatmap() will automatically add axis text in the heatmap body, so you don’t need to manually adjust axis text visibility using theme(axis.text.x = element_text())/theme(axis.text.y = element_text()).\nHaving explored the core principles of ggalign, you should now be familiar with its basic workflow. In the next chapter, we’ll introduce the StackLayout functionality, a powerful tool for arranging multiple plots in a stacked fashion—either horizontally or vertically—while maintaining full control over their alignment. We’ll explore how stack_layout() and its various functions can give you even greater flexibility in creating sophisticated layouts.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "stack-layout.html",
    "href": "stack-layout.html",
    "title": "2  stack layout",
    "section": "",
    "text": "2.1 Input data\nstack_layout() arranges plots either horizontally or vertically, and we can also use the alias ggstack(). Based on whether we want to align the observations, there are two types of stack layouts:\nSeveral aliases are available for convenience:\nWhen aligning observations, we typically use a matrix, as it is easy to melt the matrix into a long-formatted data frame. Additionally, matrices are used to fit the observation concept, as they can be transposed (rows to columns, columns to rows), which is necessary for use in functions like quad_layout() and ggheatmap(), where observations may be aligned in both directions simultaneously.\nBy default, fortify_data_frame() will invoke the ggplot2::fortify() function for conversion. Note, for matrix, it will be converted to a long-formatted data frame.\nstack_align()/stack_free() will set up the layout, but no plot will be drawn until you add a plot element:\n1stack_alignh(small_mat) +\n2    layout_annotation(\n        theme = theme(plot.background = element_rect(color = \"red\"))\n    )\n# the same for `stack_free()`\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nAdd a plot background in for the entire layout.\nIn this example, we use layout_annotation() to insert a plot background in the entire layout, it can be also used to control the theme of title, subtitle, caption (layout_title()), guides, margins, panel.border.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-input-data",
    "href": "stack-layout.html#sec-stack-layout-input-data",
    "title": "2  stack layout",
    "section": "",
    "text": "For stack_free(), a data frame is required, and the input will be automatically converted using fortify_data_frame() if needed.\nFor stack_align(), a matrix is required, and the input will be automatically converted using fortify_matrix() if needed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-layout-customize",
    "href": "stack-layout.html#sec-stack-layout-layout-customize",
    "title": "2  stack layout",
    "section": "2.2 Layout Customize",
    "text": "2.2 Layout Customize\nWhen we use stack_align(), it aligns the observations across multiple plots along the specified direction:\n\nFor stack_alignh(): Alignment occurs along the horizontal direction (y-axis).\nFor stack_alignv(): Alignment occurs along the vertical direction (x-axis).\n\nThe package offers a suite of align_* functions designed to give you precise control over the observations. These functions enable you to reorder the observations or partition the observations into multiple groups. Instead of detailing each align_* function individually, we will focus on the general usage and how to combine them with stack_align().\nHere, we remain take align_dendro() as an example, it can reorder the observations, split them into groups, and can add a plot for visualization.\nWhen used for stack_alignh(), the observations are aligned along the y-axis:\n\n1stack_alignh(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen used for stack_alignv(), the observations are aligned along the x-axis:\n\n1stack_alignv(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen align_dendro() is added to the layout, it performs following actions:\n1. reorder the observations.\n2. set the active plot to the dendrogram.\nThe active plot refers to the plot that subsequent ggplot2 components will target. In this case, the active plot is the dendrogram, and any new layers added will be applied to it. For instance, we can add additional layers to visualize the dendrogram’s structure or data. The default data underlying the ggplot object of align_dendro() consists of the dendrogram node data. It is also possible to use the dendrogram’s edge data for customization, which I will introduce in Section 5.4.\n\n1stack_alignh(small_mat) +\n2    align_dendro() +\n3    geom_point()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n3\n\nadd a point layer to the dendrogram\n\n\n\n\n\n\n\n\n\n\n\nThe active argument controls whether a plot should be set as the active plot. It accepts an active() object with the use argument to specify if the plot should be active when added.\n\n1stack_alignh(small_mat) +\n2    align_dendro(active = active(use = FALSE)) +\n3    geom_point()\n#&gt; Error in `stack_layout_add()`:\n#&gt; ! Cannot add `geom_point()` to `stack_align()`\n#&gt; ℹ No active plot component\n#&gt; ℹ Did you forget to initialize a &lt;ggplot&gt; object with `ggalign()` or\n#&gt;   `ggfree()`?\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, but don’t set the active plot to this plot.\n\n3\n\ntry to add a point layer to the dendrogram, should fail due to no active plot\n\n\n\n\nUsually, you don’t need to set this manually, as the active context is automatically applied only for functions that add plot areas. You can inspect whether a align_* function will add a plot by print it:\n\nalign_dendro()\n#&gt; `align_dendro()` object:\n#&gt;   plot: yes\n#&gt;   reorder: yes\n#&gt;   split: no\n\nYou might find it confusing that we mentioned align_dendro() will split observations into groups, while the print output shows split = \"no\". This happens because we haven’t specified the k/h argument in align_dendro().\n\nalign_dendro(k = 3L)\n#&gt; `align_dendro()` object:\n#&gt;   plot: yes\n#&gt;   reorder: yes\n#&gt;   split: yes\n\nYou don’t need to explicitly provide data to align_dendro(). By default, it inherits data from the layout. However, you can always provide another data source, but note that this package uses the concept of number of observations (NROW()). When aligning the observations, you must ensure the number of observations is consistent across all plots.\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = matrix(rnorm(56), nrow = 8)) +\n3    theme(axis.text.y = element_text())\n#&gt; Error in `align()`:\n#&gt; ! `align_dendro(data = matrix(rnorm(56), nrow = 8))` (nobs: 8) is not\n#&gt;   compatible with the `stack_align()` (nobs: 7)\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on hierarchical clustering, add a dendrogram tree, and set the active plot to this one, using self-provided data. This should fail because the number of observations is inconsistent.\n\n3\n\ntry to add y-axis text to the dendrogram.\n\n\n\n\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = matrix(rnorm(70), nrow = 7)) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot, using self-provided data\n\n3\n\nadd y-axis text to the dendrogram.\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can provide a function (or purrr-lambda) that will be applied to the layout’s matrix. For layouts that align observations, a matrix is always required, so the data input must be in matrix form.\n\nset.seed(123)\nstack_alignh(small_mat) +\n    align_dendro(data = ~ .x[sample(nrow(.x)), ]) +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nWithout adding another plot, it’s difficult to appreciate the benefits. Let’s now explore how to incorporate a plot.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-initialize",
    "href": "stack-layout.html#sec-stack-layout-plot-initialize",
    "title": "2  stack layout",
    "section": "2.3 Plot initialize",
    "text": "2.3 Plot initialize\nThere are two primary functions for adding plots:\n\nalign_gg()/ggalign(): Create a ggplot object and align with the layout.\nfree_gg()/ggfree(): Create a ggplot object without aligning.\n\nBoth functions initialize a ggplot object and, by default, set the active plot when added to the layout.\nFor stack_align(), plots can be added regardless of whether they need to align observations.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can build the plot separately and then add it to the layout:\n\nmy_bar &lt;- ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \nstack_alignh(small_mat) +\n    align_dendro() +\n    my_bar\n\n\n\n\n\n\n\n\nThe active argument can also control the place of the plot area to be added. It accepts an active() object with the order argument to specify the order of the plot area.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums, active = active(order = 1)) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can also stack plots vertically using stack_alignv():\n\nstack_alignv(small_mat) + \n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nstack_align() can also add plot without aligning observations. free_gg() focuses on layout integration without enforcing strict axis alignment. ggfree() is an alias for free_gg.\n\nstack_alignv() +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nThe & operator applies the added element to all plots in the layout, similar to its functionality in the patchwork package.\nFor stack_free(), only free plots (ggfree()) can be added. This layout arranges plots in one row or column without enforcing axis alignment:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nBy default, ggfree() will also inherit data from the layout and call fortify_data_frame() to convert the data to a data frame. So, note that if the layout data is a matrix, it will be converted into a long-formatted data frame.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-size",
    "href": "stack-layout.html#sec-stack-layout-plot-size",
    "title": "2  stack layout",
    "section": "2.4 Plot Size",
    "text": "2.4 Plot Size\nBoth ggalign() and ggfree() functions have a size argument to control the relative width (for horizontal stack layout) or height (for vertical stack layout) of the plot’s panel area.\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 2) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 1) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nAlternatively, you can define an absolute size by using a unit() object:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = unit(1, \"cm\")) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-active-plot",
    "href": "stack-layout.html#sec-stack-layout-active-plot",
    "title": "2  stack layout",
    "section": "2.5 active plot",
    "text": "2.5 active plot\nAs mentioned earlier, the active plot refers to the plot that subsequent ggplot2 components will target. The package provide two functions to work with active plot.\n\nstack_switch(): switch the active context\nstack_active(): An alias for stack_switch(), which sets what = NULL\n\nThe stack_switch() function accepts the what argument, which can either be the index of the plot added (based on its adding order) or the plot name specified via the active() object using the name argument.\nNote that the what argument must be explicitly named, as it is placed second in the function signature. This is because, in most cases, we don’t need to switch the active plot manually—adjusting the order of plot additions typically suffices.\n\n\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    # switch to the `align_dendro()` plot area\n    stack_switch(what = 1) +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by integer\")\n\n\n\n\n\n\n\n\n\n\n\nstack_alignh(small_mat) +\n    align_dendro(active = active(name = \"tree\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    # switch to the `align_dendro()` plot area\n    stack_switch(what = \"tree\") +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by string\")\n\n\n\n\n\n\n\n\n\n\nIn the example, we use layout_title() to insert a title for the entire layout. Alternatively, you can add a title to a single plot with ggtitle().\nBy setting what = NULL (or alias stack_active()), we remove the active plot. This is particularly useful when the active plot is a nested Layout object, as any additions would otherwise be directed to that nested Layout. By removing the active plot, you can continue adding components directly to the StackLayout.\nIn the next chapter, we will dive into the HeatmapLayout, which can take the StackLayout as input. Heatmap layouts offer additional features for aligning observations in both directions. Let’s move ahead and explore how heatmaps can be seamlessly integrated into your layout workflows.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html",
    "href": "heatmap-layout.html",
    "title": "3  heatmap layout",
    "section": "",
    "text": "3.1 input data\nThe heatmap_layout() function provides a powerful way to create customizable heatmaps in R using ggplot2. This chapter will guide you through its usage.\nheatmap_layout() is a specialized version of quad_alignb(), which itself is a specific variant of QuadLayout (quad_layout()) designed to align observations both horizontally and vertically. We introduce heatmap_layout() directly, as it is more familiar to many users, especially those experienced with popular heatmap packages like pheatmap and ComplexHeatmap.\nheatmap_layout() simplifies the creation of heatmap plots by integrating essential elements for a standard heatmap layout, ensuring that the appropriate data mapping and visualization layers are automatically applied. ggheatmap() is an alias for heatmap_layout().\nAs mentioned in Section 2.1, we typically require a matrix for the Layout which need align observations. Internally, fortify_matrix() will be used to process the data. You can provide a numeric or character vector, a data frame, or any other data type that can be converted into a matrix using as.matrix().\nggheatmap(small_mat)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#main-plot-heatmap-body",
    "href": "heatmap-layout.html#main-plot-heatmap-body",
    "title": "3  heatmap layout",
    "section": "3.2 Main plot (heatmap body)",
    "text": "3.2 Main plot (heatmap body)\nThe ggheatmap()/quad_layout() functions arrange plots in the Quad-Side layout of the main plot. When the layout is initialized, a ggplot object is automatically created for the main plot.\nFor ggheatmap(), the matrix input will be converted into a long-format data frame when drawing. The data in the underlying ggplot object includes the following columns:\n\n.xpanel and .ypanel: the column and row panel\n.x and .y: the x and y coordinates\n.row_names and .column_names: A factor of the row and column names of the original matrix (only applicable when names exist).\n.row_index and .column_index: the row and column index of the original matrix.\nvalue: the actual matrix value.\n\nThe default mapping will use aes(.data$.x, .data$.y), but can be customized using mapping argument.\nBy default, the main plot is regarded as the active plot, meaning you can add ggplot2 elements directly to the main plot.\n\nggheatmap(small_mat) + \n    geom_point() + \n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, ggheatmap() adds a heatmap layer. If the matrix has more than 20,000 cells (nrow * ncol &gt; 20000), it uses geom_raster() for performance efficiency; for smaller matrices, geom_tile() is used. You can explicitly choose the layer by providing a single string (\"raster\" or \"tile\") in the filling argument.\n\nggheatmap(small_mat, filling = \"raster\")\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = \"tile\")\n\n\n\n\n\n\n\n\nNote, the filling layer will always use mapping of aes(.data$.x, .data$.y), if you want to customize filling, you can set filling = NULL, which will remove the filling layer and allow you to add custom filling geoms.\n\nggheatmap(small_mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"black\", width = 0.9, height = 0.9)\n\n\n\n\n\n\n\n\nA heatmap pie charts can be easily drawn:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#rasterization",
    "href": "heatmap-layout.html#rasterization",
    "title": "3  heatmap layout",
    "section": "3.3 rasterization",
    "text": "3.3 rasterization\nWhen working with large heatmaps, it’s often beneficial to rasterize the heatmap body layer. You can achieve this by using the raster_magick() function. The res argument controls the resolution of the raster image. By default, the res argument matches the resolution of the current device, but specifying a different value can help reduce the resolution of the rasterized heatmap body.\n\nggheatmap(small_mat, filling = NULL) +\n    raster_magick(geom_tile(aes(fill = value)), res = 50)\n\n\n\n\n\n\n\n\nBy leveraging raster_magick(), you can also perform image post-processing using the magick package. This allows for custom image resizing with filters.\n\nggheatmap(small_mat, filling = NULL) +\n    # Use `magick::filter_types()` to check available `filter` arguments\n    raster_magick(geom_raster(aes(fill = value)),\n        magick = function(image) {\n            magick::image_resize(image,\n                # we resize to the 50% of width\n                geometry = \"50%x\", filter = \"Lanczos\"\n            )\n        }\n    )\n\n\n\n\n\n\n\n\nNote: When using magick::image_resize(), you should specify the geometry argument to resize the image. If only the filter is specified, it will only distort the image data (though subtle). For more information on image resizing, refer to ImageMagick’s resize documentation.\nYou can also rasterize all plots in the layout directly with raster_magick(). This method is defined for both ggheatmap()/quad_layout() and stack_layout() objects.\nAdditionally, You can use external packages like ggrastr or ggfx to rasterize the heatmap body.\n\nggheatmap(small_mat, filling = FALSE) +\n    ggrastr::rasterise(geom_tile(aes(fill = value)), dev = \"ragg\")\n\n\n\n\n\n\n\n\nLikewise, you can also rasterize all plots in the layout directly with ggrastr::rasterise() for both ggheatmap()/quad_layout() and stack_layout().\n\nggrastr::rasterise(ggheatmap(small_mat), dev = \"ragg\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFurthermore, ggfx offers many image filters that can be applied to ggplot2 layers. See the package for the details.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "href": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "title": "3  heatmap layout",
    "section": "3.4 annotations",
    "text": "3.4 annotations\nIn ggheatmap()/quad_layout(), annotations are handled by a stack_layout() object and can be positioned at the top, left, bottom, or right of the main plot (heatmap body).\nBy default, ggheatmap()/quad_layout() do not activate an annotation, You can use quad_anno() to activate an annotation, directing all subsequent additions to the specified annotation position. The quad_anno() function has the following aliases:\n\nanno_top: A special case of quad_anno() with position = \"top\".\nanno_left: A special case of quad_anno() with position = \"left\".\nanno_bottom: A special case of quad_anno() with position = \"bottom\".\nanno_right: A special case of quad_anno() with position = \"right\".\n\nWhen quad_anno() is added to a ggheatmap()/quad_layout(), it will try to automatically create a new stack_layout(). For top and bottom annotations, stack_alignv() or stack_freev() will be used; for left and right annotations, stack_alignh() or stack_freeh() will be applied.\nquad_anno() will always attempt to initialize a stack_layout() with the same alignment as the current direction. This means that if observations need to be aligned horizontally, stack_alignh() will be used for left and right annotations, otherwise, stack_freeh() will be initialized instead. The same logic applies for vertical alignment—stack_alignv() or stack_freev() will be applied for top and bottom annotations, depending on whether alignment is required. However, you can also manually add a stack_free() for directions that require alignment, which I’ll cover in the following section.\nAdditionally, quad_anno() will set the active context to the annotation. This means that subsequent additions will be directed to the annotation rather than the main plot. We use the term active context in contrast to active plot (as described in Section 2.2), since the annotation is a Layout object.\n\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the left annotation\n    anno_left() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, the annotation stack_layout() will try to inherit data from ggheatmap()/quad_layout(). If the observations require alignment vertically, this means the data from ggheatmap()/quad_layout() should be a matrix, the column annotations will also require a matrix and the matrix from ggheatmap()/quad_layout() will be transposed for use in the column annotations.\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can further customize the layout design or add new plots in the annotation stack, as described in ?sec-stack-layout.\n\nggheatmap(small_mat) +\n    # in the heatmap body, we set the axis text theme\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the right annotation\n    anno_right() +\n    # in the right annotation, we add a dendrogram\n    align_dendro(k = 3L) +\n    # in the dendrogram, we add a point layer\n    geom_point(aes(color = factor(branch)))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this example:\n\nanno_right() initialize the right annotation stack, and change the active context to the right of the heatmap.\nalign_dendro(k = 3L) adds a dendrogram to the annotation and sets itself as the active plot in the annotation stack.\ngeom_point(aes(color = factor(branch))) is then added to this active plot within the annotation stack, here, it means the align_dendro() plot.\n\nggheatmap() aligns observations both horizontally and vertically, so it’s safe to always use quad_anno() directly, as all annotations require a matrix, and the layout data is also a matrix. However, for quad_alignh() and quad_alignv() (which I’ll discuss in more detail in a Chapter 6), which only align observations in one direction, the data in the layout may not fit the data for the annotation (when the layout requires alignment of observations, we typically use a matrix, regardless of whether alignment is needed in one or two directions)\n- `quad_alignh()`: aligning observations in horizontal direction, for column\nannotations, we ll need a data frame for `stack_free()`.\n- `quad_alignv()`: aligning observations in vertical direction, for row\nannotations, we ll need a data frame for `stack_free()`.\nIn both cases, quad_anno() won’t initialize the annotation by default, instead, you must provide the annotation stack_layout() manually.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "href": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "title": "3  heatmap layout",
    "section": "3.5 Adding stack layout",
    "text": "3.5 Adding stack layout\nSimilar to adding a plot in stack_layout() (?sec-stack-layout), when the direction requires alignment, you can add both stack_align() and stack_free(). However, if the direction does not require alignment, you can add only stack_free().\nTo add a stack_layout() to the ggheatmap(), we must prevent the automatical creation of annotation by quad_anno() by setting initialize = FALSE\n\n\n\nmy_stack_align &lt;- stack_alignh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_align +\n    layout_title(\"stack_align()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nmy_stack_free &lt;- stack_freeh(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_free +\n    layout_title(\"stack_free()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nNote when aligning the observations, you must ensure the number of observations is consistent in the direction. So for column annotations, you need transpose the data manually.\n\nmy_stack &lt;- stack_alignv(t(small_mat)) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    anno_top(initialize = FALSE) +\n    my_stack\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_active",
    "href": "heatmap-layout.html#quad_active",
    "title": "3  heatmap layout",
    "section": "3.6 quad_active()",
    "text": "3.6 quad_active()\nTo remove the active context and redirect additions back to the heatmap body, you can use quad_active().\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_active() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_switchhmanno",
    "href": "heatmap-layout.html#quad_switchhmanno",
    "title": "3  heatmap layout",
    "section": "3.7 quad_switch()/hmanno()",
    "text": "3.7 quad_switch()/hmanno()\nWe also provide quad_switch()/hmanno() (heatmap annotation) which integrates quad_active() and quad_anno() into one function for ease of use. Feel free to use any of these functions to streamline your annotation process.\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    quad_switch(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_switch() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c() +\n    layout_title(\"quad_switch()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    hmanno(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    hmanno() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()+\n    layout_title(\"hmanno()\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#plot-size",
    "href": "heatmap-layout.html#plot-size",
    "title": "3  heatmap layout",
    "section": "3.8 Plot Size",
    "text": "3.8 Plot Size\n\n3.8.1 Heatmap Body Size\nYou can specify the relative sizes of the heatmap body using the width and height arguments in the ggheatmap() function.\n\nggheatmap(small_mat, height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAlternatively, the quad_active() function allows you to control the heatmap body sizes.\n\nggheatmap(small_mat) +\n    quad_active(height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n3.8.2 Annotation Stack Size\nThe quad_anno() function allows you to control the total annotation stack size. The size argument controls the relative width (for left and right annotations) or height (for top and bottom annotations) of the whole annotation stack.\n\nggheatmap(small_mat) +\n    anno_top(size = 1) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also specify it as an absolute size using unit():\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that the size of an individual plot (?sec-stack-layout_plot_size) does not affect the total annotation stack size. You must adjust the annotation size using the method described above.\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(size = unit(30, \"mm\")) +\n    layout_title(\"plot size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    layout_title(\"annotation size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nIn this chapter, we explored the usage of heatmap layout. These features provide a strong foundation for visualizing matrix-based data in a structured way. However, as your visualization needs grow more complex, the ability to further customize and fine-tune the layout becomes essential.\nIn the next chapter, we will dive into the Layout Customize functionalities, where you can gain full control over your plot’s layout.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "layout-customize.html",
    "href": "layout-customize.html",
    "title": "4  Layout customize",
    "section": "",
    "text": "4.1 align_group()\nFor layouts that can align observations, the package provides a suite of align_* functions designed to give you precise control over the observations. These functions allow you to reorder observations or partition them into multiple groups.\nCurrently, there are four key align_* functions available for layout customization:\nNote that these functions do not add plot areas and set the active context, meaning you cannot incorporate ggplot2 elements directly into these objects. You can inspect the behavior of any align_* function by printing it.\nThe align_group() function allows you to split the observations into groups.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\nNote that all align_* functions which split observations into groups must not break the previous established groups. This means the new groups must nest in the old groups, usually they cannot be used if groups already exist.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE)) +\n    align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n#&gt; Error in `align()`:\n#&gt; ! align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n#&gt;   disrupt the previously established panel groups of the top annotation\n#&gt;   `stack_align()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_order",
    "href": "layout-customize.html#align_order",
    "title": "4  Layout customize",
    "section": "4.2 align_order()",
    "text": "4.2 align_order()\nThe align_order() function reorder the observations based on the summary weights.\nIn this example, we order the rows based on their means. By default, the ordering is in ascending order according to the summary weights. You can reverse the order by setting reverse = TRUE.\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans) +\n    layout_title(title = \"reverse = FALSE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans, reverse = TRUE) +\n    layout_title(title = \"reverse = TRUE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nAdditionally, you can provide the ordering integer index or character index directly:\n\nset.seed(1234)\nmy_order &lt;- sample(nrow(small_mat))\nprint(rownames(small_mat)[my_order])\n#&gt; [1] \"row4\" \"row2\" \"row5\" \"row7\" \"row3\" \"row1\" \"row6\"\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(my_order)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rownames(small_mat)[my_order])\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nSome align_* functions also accept a data argument. It’s important to note that all align_* functions treat rows as the observations. This means NROW(data) must match the number of observations along the axis used for alignment. The data argument can also accept a function (supporting purrr-like lambda syntax), which will be applied to the layout matrix.\nAs mentioned in Section 3.4, for top and bottom annotations, the data matrix of quad_layout()/ggheatmap() is transposed to create the annotation stack_layout(). Therefore, you can use rowMeans() to calculate the mean value across all columns.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSome align_* functions that reorder observations include an argument called strict. This argument is especially useful when previous groups have already been established. If previous groups have been created and strict = FALSE, the function will reorder the observations within each group.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))+\n    align_order(rowMeans, strict = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that we always prevent reordering the observations into two different orderings. If you want to apply two different orderings, you should use cross_layout() instead, which I’ll introduce in a later chapter:\n\nset.seed(1234)\nanother_order &lt;- sample(ncol(small_mat))\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans) +\n    align_order(another_order)\n#&gt; Error in `align()`:\n#&gt; ! align_order(another_order) disrupt the previously established ordering\n#&gt;   index of the top annotation `stack_align()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_kmeans",
    "href": "layout-customize.html#align_kmeans",
    "title": "4  Layout customize",
    "section": "4.3 align_kmeans()",
    "text": "4.3 align_kmeans()\nThe align_kmeans() function split the observations into groups based on k-means clustering.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#sec-align_hclust",
    "href": "layout-customize.html#sec-align_hclust",
    "title": "4  Layout customize",
    "section": "4.4 align_hclust()",
    "text": "4.4 align_hclust()\nThe align_hclust() function is designed to reorder observations and group them based on hierarchical clustering. Unlike align_dendro(), however, align_hclust() does not add a dendrogram tree to the plot. All the arguments intruduced here can also be used by align_dendro().\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nHierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. You can use the distance and method argument to control the builind process.\nThere are two ways to specify distance metric for clustering:\n\nspecify distance as a pre-defined option. The valid values are the supported methods in dist() function and coorelation coefficient \"pearson\", \"spearman\" and \"kendall\". The correlation distance is defined as 1 - cor(x, y, method = distance).\na self-defined function which calculates distance from a matrix. The function should only contain one argument.\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = \"pearson\") +\n    layout_title(\"pre-defined distance method (1 - pearson)\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = function(m) dist(m)) +\n    layout_title(\"a function that calculates distance matrix\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method. Possible methods are those supported in hclust() function. And you can also provide a self-defined function, which accepts the distance object and return a hclust object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(method = \"ward.D2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can specify k or h to split observations into groups, which work similarly to cutree():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can reorder the dendrogram based on the mean values of the observations by setting reorder_dendrogram = TRUE.\n\nh1 &lt;- ggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3, reorder_dendrogram = TRUE) +\n    layout_title(\"reorder_dendrogram = TRUE\")\nh2 &lt;- ggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3) +\n    layout_title(\"reorder_dendrogram = FALSE\")\nalign_plots(h1, h2)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this example, we use align_plots() to arrange the layouts, which functions similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, unlike those, align_plots() can be directly used with quad_layout() and stack_layout(), ensuring proper alignment by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, though they won’t align by panel area in the same way as ggplot2 plots.\nalign_hclust() can also perform clustering between groups, meaning it can be used even if there are existing groups present in the layout, in this way, you cannot specify k or h:\n\nset.seed(3L)\ncolumn_groups &lt;- sample(letters[1:3], ncol(small_mat), replace = TRUE)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can reorder the groups by setting reorder_group = TRUE, which reorders the hierarchical clusters based on the group tree:\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(reorder_group = TRUE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIf you specify k or h, this will always turn off sub-clustering. The same principle applies to align_hclust(), where new groups must be nested within the previously established groups.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(k = 2L)\n#&gt; Error in `align()`:\n#&gt; ! align_hclust(k = 2L) disrupt the previously established panel groups\n#&gt;   of the top annotation `stack_align()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_reorder",
    "href": "layout-customize.html#align_reorder",
    "title": "4  Layout customize",
    "section": "4.5 align_reorder()",
    "text": "4.5 align_reorder()\nThe align_reorder() function enables the reordering of observations based on a specified statistical function. This function accepts a data argument and computes a statistic that determines the new ordering of the observations. The resulting order is extracted using the order2() function.\nFoe example, you can also use hierarchical clustering to reorder the observations like this:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_reorder(hclust2)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nHere, hclust2() is a special function used by align_hclust() to calculate the distance matrix and perform hierarchical clustering.\nIn addition to hierarchical clustering, the align_reorder() function can also handle objects from the seriation package. For example, you can use the seriate() function with a method like \"BEA_TSP\" to reorder the observations based on a specific seriation algorithm:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_reorder(seriation::seriate, method = \"BEA_TSP\", data = abs)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThis approach gives you the flexibility to apply different statistical or algorithmic methods for reordering observations, which can be especially useful for exploring complex patterns in data.\nWith the align_* functions in place, we’ve covered how to reorder and group observations within a heatmap layout. Now, having set the stage for proper observation alignment, we can move on to the next essential step: plot initialize. In the following chapter, we’ll dive deeper into how to set up your plots within the layout.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html",
    "href": "plot-initialize.html",
    "title": "5  Plot initialize",
    "section": "",
    "text": "5.1 align_gg()/ggalign()\nThere are three primary functions for adding plots:\nggalign() and ggfree() are aliases for align_gg() and free_gg(), respectively. All three functions will set the active plot when added to the layout.\nBoth ggalign() and align_dendro() can only be used with a stack_layout() that aligns observations (stack_align()), whereas ggfree() can be added to a stack_layout() that does not align the observations (stack_free()).\nggalign() is similar to ggplot in that it initializes a ggplot data and mapping. ggalign() allowing you to provide data in various formats, including matrices, data frames, or simple vectors. By default, it will inherit from the layout. If a function, it will apply with the layout matrix.\nggalign() always applies a default mapping for the axis of the data index in the layout. This mapping is aes(y = .data$.y) for horizontal stacking (including left and right quad layout annotation) and aes(x = .data$.x) for vertical stacking (including top and bottom quad layout annotation).\nThe data in the underlying ggplot object will contain following columns:\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = rowSums) +\n    geom_point(aes(y = value))\n#&gt; → heatmap built with `geom_tile()`\nIn the case where the input data is already a data frame, following columns (.x/.y, .names, .index, and .panel) will be added to the data frame if applicable. Note, NROW(data) must match the number of observations along the axis used for alignment.\nmy_df &lt;- mtcars[seq_len(ncol(small_mat)), ]\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = my_df) +\n    geom_point(aes(y = cyl))\n#&gt; → heatmap built with `geom_tile()`\nYou may wonder if the strict data requirements will prevent us from preparing the data for plotting. Don’t worry! In the later chapters, I’ll introduce powerful way to prepare data for your plots.\nIf data = NULL, the data in the underlying ggplot object contains following columns:\nYou can use it to integrate additional elements, such as block annotation or customized panel title, into your layout.\nggheatmap(small_mat) +\n    anno_top(size = unit(1, \"cm\")) +\n    align_kmeans(centers = 3L) +\n    ggalign(data = NULL) +\n    geom_tile(aes(y = 1L, fill = .panel, color = .panel))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#sec-ggalign",
    "href": "plot-initialize.html#sec-ggalign",
    "title": "5  Plot initialize",
    "section": "",
    "text": ".panel: the panel for the aligned axis. It means x-axis for vertical stack layout (including top and bottom annotation), y-axis for horizontal stack layout (including left and right annotation).\n.x or .y: the x or y coordinates.\n.names and .index: A factor of the names (only applicable when names exists) and an integer of index of the original data.\n.row_names and .row_index: the row names and an integer of row index of the original matrix (only applicable if data is a matrix).\n.column_names and .column_index: the column names and column index of the original matrix (only applicable if data is a matrix).\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\n\nIt is recommended to use .x/.y, or .names as the x/y mapping.\n\n\n\n\n\n\n\n.panel: the panel for the axis used for alignment.\n.index: the index of the original layout data.\n.x or .y: the x or y coordinates\n\n\n\n\n5.1.1 Cross panel sumamry\nWhen used in a quad_layout(), and the data is inherited from the quad_layout(), a special column .extra_panel will be added if applicable, which is the panel information for column (for left or right annotation) or row (for top or bottom annotation). This is useful if you want to create summary plot using another axis panel groups. In such cases, it’s often necessary to disable the automatic setting of limits (limits = FALSE in ggalign()).\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_right() +\n    align_kmeans(2) +\n    anno_top(size = 0.5) +\n    ggalign(limits = FALSE) +\n    geom_boxplot(aes(.extra_panel, value, fill = .extra_panel)) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"row groups\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThis approach replicates the functionality of ComplexHeatmap::anno_summary(), but is versatile enough to be used with any heatmap, not just single-column or single-row heatmaps.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#free_ggggfree",
    "href": "plot-initialize.html#free_ggggfree",
    "title": "5  Plot initialize",
    "section": "5.2 free_gg()/ggfree()",
    "text": "5.2 free_gg()/ggfree()\nThe ggfree() function allows you to incorporate a ggplot object into your layout. Unlike align_gg(), which aligns every axis value precisely, free_gg() focuses on layout integration without enforcing strict axis alignment.\nInternally, the function uses fortify_data_frame() to transform the input into a data frame. For matrices, it converts them into a long-formatted data frame. Note that ggfree() does not provide a default aesthetic mapping, which contrasts with ggalign(). You will need to manually provide the default mappings.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nAlternatively, you can directly input the ggplot object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(ggplot(mtcars, aes(wt, mpg))) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also add the ggplot object directly without using ggfree(). However, doing so will limit control over the plot (like plot area size, and active components):\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggplot(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#ggwrap-and-inset",
    "href": "plot-initialize.html#ggwrap-and-inset",
    "title": "5  Plot initialize",
    "section": "5.3 ggwrap() and inset()",
    "text": "5.3 ggwrap() and inset()\nThe ggwrap() function allows you to wrap objects that can be converted into a grob, turning them into a ggplot for plotting. Further you can still add ggplot elements like title, subtitle, tag, caption, and geoms using the same approach as with normal ggplots (using ggtitle(), labs(), geom_*()) as well as styling using theme(). This enables you to pass these wrapped objects into ggfree().\n\nlibrary(grid)\nggheatmap(small_mat) +\n    anno_top() +\n    # `ggwrap()` will create a `ggplot` object, we use `ggfree` to add it into the layout\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also integrate base plots, pheatmap, ComplexHeatmap, e.g.\nAdditionally, you can add any graphics as a inset to a ggplot using the inset() function. Like ggwrap(), inset() can accept any object that can be converted to a grob.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\")) +\n    # we can then add any inset grobs (the same as ggwrap, it can take any objects\n    # which can be converted to a `grob`)\n    inset(rectGrob(gp = gpar(fill = \"steelblue\")), align = \"panel\") +\n    inset(textGrob(\"Here are some text\", gp = gpar(color = \"black\")),\n        align = \"panel\"\n    )\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#sec-align-dendro",
    "href": "plot-initialize.html#sec-align-dendro",
    "title": "5  Plot initialize",
    "section": "5.4 align_dendro()",
    "text": "5.4 align_dendro()\nalign_dendro() is an extension of align_hclust() that adds a dendrogram to the layout. All functions of align_hclust() introduced in Section 4.4 can be used with align_dendro(). Here, we focus on the plot-related function.\nalign_dendro() will initialize a ggplot object, the data underlying the ggplot object contains the dendrogram node data with dendrogram edge data attached in a special attribute.\ndendrogram node and edge contains following columns: - index: the original index in the tree for the current node - label: node label text - x and y: x-axis and y-axis coordinates for current node or the start node of the current edge. - xend and yend: the x-axis and y-axis coordinates of the terminal node for current edge. - branch: which branch current node or edge is. You can use this column to color different groups. - leaf: A logical value indicates whether current node is a leaf.\nBy default, plot_dendrogram is set to TRUE, meaning a geom_segment() layer will be added using the dendrogram edge data when drawing. Note that this layer is always added to the first.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can choose between two dendrogram types: \"rectangle\" (default) and \"triangle\". However, if there are any groups in the stack, \"rectangle\" will be used.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(type = \"triangle\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also manually add the dendrogram tree using the edge data by setting plot_dendrogram = FALSE. In this case, you can access the dendrogram edge data with ggalign_attr(). The edge data is stored in the edge field of ggalign_attr():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro() +\n    geom_segment(\n        aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend),\n        data = function(x) ggalign_attr(x, \"edge\")\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen there are multiple groups, a branch column will be available. This can be used to color the nodes or edges based on the group source.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nalign_dendro() will draw dendrogram tree in each group when previous group exists.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can merge the sub-tree by settting merge_dendrogram = TRUE.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch), merge_dendrogram = TRUE)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "plot-initialize.html#plot-titles",
    "href": "plot-initialize.html#plot-titles",
    "title": "5  Plot initialize",
    "section": "5.5 Plot titles",
    "text": "5.5 Plot titles\nggplot2 only allow add titles in the top or add caption in the bottom. we extends this capability, allowing you to place titles around any border of the plot using the patch_titles() function.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe appearance and alignment of these patch titles can be customized using ggplot2::theme(): - plot.patch_title/plot.patch_title.*: Controls the text appearance of patch titles. By default, plot.patch_title inherit from plot.title, and settings for each border will inherit from plot.patch_title, with the exception of the angle property, which is not inherited. - plot.patch_title.position/plot.patch_title.position.*: Determines the alignment of the patch titles. By default, plot.patch_title.position inherit from plot.title.position, and settings for each border will inherit from plot.patch_title. The value \"panel\" aligns the patch titles with the plot panels. Setting this to \"plot\" aligns the patch title with the entire plot (excluding margins and plot tags).\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    ) +\n    theme(\n        plot.patch_title.position = \"plot\",\n        plot.patch_title = element_text(hjust = 0)\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNow, let’s move on to the next chapter, where we will introduce quad_layout() in full. While we’ve already introduced ggheatmap()—a specialized version of quad_layout()—most of the operations discussed in Chapter 3 can also be applied to quad_layout(). In the next section, we’ll delve into quad_layout() and explore its full functionality.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plot initialize</span>"
    ]
  },
  {
    "objectID": "quad-layout.html",
    "href": "quad-layout.html",
    "title": "6  quad-layout",
    "section": "",
    "text": "6.1 introduction\nquad_layout() arranges plots in the Quad-Side of a main plot.\nDepending on whether you want to align observations in the horizontal or vertical direction, there are four main types of quad_layout():\nWhen the layout requires alignment of observations, we typically use a matrix, regardless of whether alignment is needed in one or two directions.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#introduction",
    "href": "quad-layout.html#introduction",
    "title": "6  quad-layout",
    "section": "",
    "text": "Alignment of Observations\nhorizontal\nvertical\nData Format\n\n\n\n\nquad_free()/ggside()\n❌\n❌\ndata frame\n\n\nquad_alignh()\n✅\n❌\nmatrix\n\n\nquad_alignv()\n❌\n✅\nmatrix\n\n\nquad_alignb()/ggheatmap()\n✅\n✅\nmatrix\n\n\n\n\n\nFor data frame, the input will be automatically converted using fortify_data_frame() if needed.\nFor matrix, the input will be automatically converted using fortify_matrix() if required.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#annotations",
    "href": "quad-layout.html#annotations",
    "title": "6  quad-layout",
    "section": "6.2 Annotations",
    "text": "6.2 Annotations\nAnnotation is typically handled using a stack_layout(). Depending on whether you want to align observations in the specified direction, different stack_layout() are compatible (Section 3.5). Below is a table outlining the compatibility of various layout types for annotations:\n\n\n\n\n\n\n\n\nAnnotations\nleft and right\ntop and bottom\n\n\n\n\nquad_free()/ggside()\nstack_freeh()\nstack_freev()\n\n\nquad_alignh()\nstack_freeh()/stack_alignh()\nstack_freev()\n\n\nquad_alignv()\nstack_freeh()\nstack_freev()/stack_alignv()\n\n\nquad_alignb()/ggheatmap()\nstack_freeh()/stack_alignh()\nstack_freev()/stack_alignv()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_alignb",
    "href": "quad-layout.html#quad_alignb",
    "title": "6  quad-layout",
    "section": "6.3 quad_alignb()",
    "text": "6.3 quad_alignb()\nquad_alignb() aligns observations in both horizontal and vertical directions. It serves as the base version of ggheatmap()/heatmap_layout() and does not automatically add default layers or mappings.\nThe underlying ggplot data of the main plot is the same with ggheatmap()/heatmap_layout(), it is recommended to use .y, or .row_names as the y mapping and use .x or .column_names as the x mapping in the main plot.\n\nquad_alignb(small_mat, aes(.x, .y)) +\n    geom_tile(aes(fill = value)) +\n    scale_fill_viridis_c()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_alignhquad_alignv",
    "href": "quad-layout.html#quad_alignhquad_alignv",
    "title": "6  quad-layout",
    "section": "6.4 quad_alignh()/quad_alignv()",
    "text": "6.4 quad_alignh()/quad_alignv()\nquad_alignh() aligns observations horizontally, while quad_alignv() aligns observations vertically.\nThe underlying ggplot data is the same with ggheatmap()/heatmap_layout(), it is recommended to use .y, or .row_names as the y mapping in the main plot for quad_alignh() but use .x or .column_names as the x mapping in the main plot for quad_alignv().\n\n\n\nquad_alignh(small_mat) +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquad_alignv(small_mat) +\n    geom_boxplot(aes(.column_names, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\n\nAs discussed in Section 3.4, quad_anno() will always attempt to initialize a stack_layout() with the same alignment as the current direction. For top and bottom annotations in quad_alignh(), and left and right annotations in quad_alignv(), quad_anno() will not initialize the annotation due to inconsistent data types.\n\nquadh &lt;- quad_alignh(small_mat) +\n    anno_top()\n#&gt; Warning: `data` in `quad_alignh()` is a double matrix, but the top annotation stack need\n#&gt; a &lt;data.frame&gt;, won't initialize the top annotation stack\nquadv &lt;- quad_alignv(small_mat) +\n    anno_left()\n#&gt; Warning: `data` in `quad_alignv()` is a double matrix, but the left annotation stack\n#&gt; need a &lt;data.frame&gt;, won't initialize the left annotation stack\n\nManual adding of a stack_layout() is required in such cases, you can set initialize = FALSE to prevent the warning message.\n\nquadh &lt;- quad_alignh(small_mat) +\n    anno_top(initialize = FALSE)\nquadv &lt;- quad_alignv(small_mat) +\n    anno_left(initialize = FALSE)\n\n\n\n\nquadh +\n    stack_freev(mpg) +\n    # add a plot in the top annotation\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquadv +\n    stack_freeh(data = mpg) +\n    # add a plot in the top annotation\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(.column_names, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can set initialize = TRUE, which will initialize the annotation stack layout with no data. In this case, you must provide data in each plot within the annotation.\n\n\n\nquad_alignh(small_mat) +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_top(initialize = TRUE) +\n    ggfree(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\n\nquad_alignv(small_mat) +\n    geom_boxplot(aes(.column_names, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_left(initialize = TRUE) +\n    ggfree(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignv()\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_free",
    "href": "quad-layout.html#quad_free",
    "title": "6  quad-layout",
    "section": "6.5 quad_free()",
    "text": "6.5 quad_free()\nquad_free() does not align observations and is functionally equivalent to the ggside package. For convenience, ggside() is provided as an alias for quad_free(). This layout is particularly useful for adding metadata or summary graphics along a continuous axis.\n\nggside(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    # initialize top annotation\n    anno_top(size = 0.3) +\n    # add a plot in the top annotation\n    ggfree() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    # initialize right annotation\n    anno_right(size = 0.3) +\n    # add a plot in the right annotation\n    ggfree() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    ) &\n    theme_bw()\n\n\n\n\n\n\n\n\nggside() allows facetting for the main plot, which should also be applied to the annotations for proper alignment.\n\ni2 &lt;- iris\ni2$Species2 &lt;- rep(c(\"A\", \"B\"), 75)\nggside(i2, aes(Sepal.Width, Sepal.Length, color = Species)) +\n    geom_point(size = 2) +\n    facet_grid(Species ~ Species2) +\n    anno_top(size = 0.3) +\n    ggfree() +\n    geom_density(aes(Sepal.Width, y = after_stat(density), colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(cols = vars(Species2)) +\n    anno_right(size = 0.3) +\n    ggfree() +\n    geom_density(aes(x = after_stat(density), Sepal.Length, colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(rows = vars(Species)) &\n    theme_bw()\n\n\n\n\n\n\n\n\nIf an annotation contains multiple plots, it can be tedious to add the same element to each one individually. One way to simplify this is by creating an external stack_layout() and adding the desired elements using the & operator. Then, you can add this stack_layout() to the quad_layout(). In a later chapter, I will introduce another operator that seamlessly combines with the + operator, allowing you to add elements to multiple plots at once.\nIn the next chapter, we will explore even more advanced techniques for combining multiple quad_layout()s. These methods will provide you with the tools to manage more complex plot arrangements and make your visualizations even more flexible and powerful.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>quad-layout</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html",
    "href": "multiple-quad-layouts.html",
    "title": "7  A list of quad_layout()",
    "section": "",
    "text": "7.1 stack_align()\nSimilarly, stack_layout() can be added to a quad_layout(), and a quad_layout() can also be added to a stack_layout().\nAs discussed in Section 2.3, stack_align() can accept plots regardless of whether alignment of observations is required.\nstack_alignh(small_mat) +\n    ggheatmap() +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nWhen ggheatmap()/quad_layout() is added to a stack_layout(), it will also set the active context to itself, which means subsequent addition will be directed to ggheatmap()/quad_layout(). One exception is the ggheatmap()/quad_layout() itself, which cannot be added to another quad_layout(). In this case, they will be added directly to the stack_layout().\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nThe data of ggheatmap()/quad_layout() can inherit from the stack_layout(), but the data format must match. Otherwise, you will need to manually provide the data. For stack_align(), the data is always expected to be a matrix, if you try to add a ggside() (which uses a data frame), it will result in an error.\nstack_alignh(small_mat) +\n    ggside()\n#&gt; Error in `stack_layout_add()`:\n#&gt; ! Cannot add `quad_free()` to `stack_align()`\n#&gt; ℹ `data` in `stack_align()` is a double matrix, but `quad_free()` need a\n#&gt;   &lt;data.frame&gt;.\n#&gt; ℹ Try provide `data` in `quad_free()`\nWhen ggheatmap()/quad_layout() is added to a vertical stack_align(), the inherited matrix is transposed before use. This is because the columns of ggheatmap()/quad_layout() must match the number of observations in stack_align().\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nstack_align() ensures that all plots aligned along the stack have the same ordering index or groups for the observations. Here’s a table summarizing which quad_layout() will be aligned in stack_align().\nWe can customize the layout in the stack_align() directly, or in quad_layout(). As introduced in Section 2.5, you can easily switch from the ggheatmap()/quad_layout() to the stack_layout() using stack_active().\nWhen applied to a stack_layout(), the orientation of the dendrogram may need to be manually adjusted.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#stack_align",
    "href": "multiple-quad-layouts.html#stack_align",
    "title": "7  A list of quad_layout()",
    "section": "",
    "text": "stack_alignh()\nstack_alignv()\n\n\n\n\nquad_free()/ggside()\n❌\n❌\n\n\nquad_alignh()\n✅\n❌\n\n\nquad_alignv()\n❌\n✅\n\n\nquad_alignb()/ggheatmap()\n✅\n✅\n\n\n\n\n\n\n\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3)+\n    layout_title(\"dendrogram in ggheatmap()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nstack_alignv(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    stack_active() +\n    align_dendro(aes(color = branch), k = 3, size = 0.2) +\n    scale_y_reverse() +\n    layout_title(\"dendrogram in stack_layout()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#stack_free",
    "href": "multiple-quad-layouts.html#stack_free",
    "title": "7  A list of quad_layout()",
    "section": "7.2 stack_free()",
    "text": "7.2 stack_free()\nHowever, stack_free() is designed to only accept plots that are not aligned along the axis (Section 2.3). Below is a table summarizing which quad_layout() are compatible with stack_free():\n\n\n\n\nstack_freeh()\nstack_freev()\n\n\n\n\nquad_free()/ggside()\n✅\n✅\n\n\nquad_alignh()\n❌\n✅\n\n\nquad_alignv()\n✅\n❌\n\n\nquad_alignb()/ggheatmap()\n❌\n❌\n\n\n\n\nalignh_quad_plot &lt;- quad_alignh(small_mat) +\n    geom_boxplot(aes(value, .row_names, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")\nstack_freev() +\n    alignh_quad_plot +\n    alignh_quad_plot",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#control-sizes",
    "href": "multiple-quad-layouts.html#control-sizes",
    "title": "7  A list of quad_layout()",
    "section": "7.3 Control sizes",
    "text": "7.3 Control sizes\nA numeric or a unit object of length 3 should be provided in stack_align()/stack_free() when placing a quad_layout(). For vertical stack_layout(), this means quad_layout() with left or right annotations; for horizontal stack_layout(), this means quad_layout() with top or bottom annotations. The first size controls the relative width/height of the left or top annotation, the second controls the relative width/height of the main plot, and the third controls the relative width/height of the right or bottom annotation.\nBy default the three rows/columns will have equal sizes.\n\nstack_alignv(small_mat) +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nheat1 &lt;- ggheatmap(t(small_mat)) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\")\n\nstack_alignv(small_mat, sizes = c(1, 2, 1)) +\n    heat1 +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this way, the width/height of main plot specified in quad_active() or quad_layout()/ggheatmap() won’t work.\n\nstack_alignv(small_mat) +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNext, we will build on these concepts and explore even more advanced strategies for integrating elements across multiple plots or annotations in a layout.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A list of `quad_layout()`</span>"
    ]
  },
  {
    "objectID": "operator.html",
    "href": "operator.html",
    "title": "8  Operators",
    "section": "",
    "text": "8.1 Addition operator\nIn ggalign, operators are used to manage and manipulate the plot elements in various layouts. These operators help you build complex visualizations by adding, modifying, or removing elements across multiple plots or annotations in a layout. You may be familiar with the + and & operators, this section will expand on their usage, as well as introduce the subtraction operator (-) and how to apply it in different contexts.\nThe + operator is straightforward and should be used as needed.\nIn stack_layout(), a nested layout will only occur if you pass a quad_layout() into stack_layout() (Chapter 7). If the active context in the stack_layout() is quad_layout(), this quad_layout() is treated as the active layout, and the + operator will add elements to it, following the same principles as in quad_layout(). Otherwise, the stack_layout() itself is treated as the active layout, and the + operator will add elements directly to this plot.\nstack_alignh(small_mat) +\n    align_dendro() +\n    geom_point() +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\nIn quad_layout(), four nested layouts are available for annotations: top, left, bottom, and right. If no active annotation is set, quad_layout() treat itself as the active layout. Since there is only one main plot in the quad_layout(), the main plot is always treated as the active plot in this context. Otherwise, the active annotation is treated as the active layout, and the + operator will add elements to it, following the same principles as in stack_layout().\nggheatmap(small_mat) +\n    scale_fill_viridis_c() +\n    anno_left(size = 0.2) +\n    align_dendro() +\n    anno_right(size = 0.2) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#addition-operator",
    "href": "operator.html#addition-operator",
    "title": "8  Operators",
    "section": "",
    "text": "+: adds elements to the active plot in the active layout.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#logical-and-operator",
    "href": "operator.html#logical-and-operator",
    "title": "8  Operators",
    "section": "8.2 logical AND operator",
    "text": "8.2 logical AND operator\n\n&: applies elements to all plots in the layout.\n\nThe & operator works similarly to patchwork, applying an element across all plots in a layout. Since & has lower precedence than +, it’s generally best to use it at the end of an expression or you should wrap it in parentheses when needed.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    # Add a dendrogram in the left annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    # Add a dendrogram in the right annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) &\n    # Set color scale for all plots\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#subtraction-operator",
    "href": "operator.html#subtraction-operator",
    "title": "8  Operators",
    "section": "8.3 Subtraction operator",
    "text": "8.3 Subtraction operator\nThe - operator is more powerful than the & operator, enabling flexible addition of elements to multiple plots. While its use might initially seem unintuitive, the reason behind this is that - shares the same precedence group as +, which allows it to seamlessly combine with +.\n\n8.3.1 quad_layout()\nIf the active context is the ggheatmap()/quad_layout() itself, the - operator behaves similarly to &. It applies the specified elements to all plots within the layout.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Remove any active annotation\n    quad_active() -\n    # Set color scale for all plots, since the active layout is the `ggheatmap()`/`quad_layout()`\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIf the active layout is the annotation stack, the - operator will only add the elements to all plots in the active annotation stack:\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the the color scales of all plots in the left annotation\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n8.3.2 stack_layout()\nIf the active layout is the stack_layout() itself, - applies the elements to all plots in the layout except the nested ggheatmap()/quad_layout().\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout except the heatmap layout\n    theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWhen the active layout is the nested ggheatmap()/quad_layout(), the - operator applies the elements to this nested layout, following the same principles as in the ggheatmap()/quad_layout().\nWant apply elements for plots in both stack_layout() and the nested ggheatmap()/quad_layout() at the same time? refer to the following section.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#with_quad",
    "href": "operator.html#with_quad",
    "title": "8  Operators",
    "section": "8.4 with_quad()",
    "text": "8.4 with_quad()\nThe with_quad() function adjusts the context in which elements are applied in ggheatmap()/quad_layout(). It allows you to control how objects such as themes, scales, and other plot modifications are applied to specific annotation stacks or the main plot, without changing the currently active layout or plot.\nThis function accepts three arguments:\n\nx: An object which can be added to the plot.\nposition: A string containing one or more of \"t\", \"l\", \"b\", and \"r\" specifies the context for applying x.\nmain: A single boolean value indicates whether x should also apply to the main plot within ggheatmap()/quad_layout(). Only used when position is not NULL.\n\n\n8.4.1 quad_layout()\nDefault Behavior by wrapping object with with_quad():\n\nWhen ggheatmap()/quad_layout() has no active annotation stack, objects added via + or - operate normally without with_quad().\nWhen the active annotation stack is set, with_quad() ensures the applied object also modifies:\n\nThe main plot (by default).\nOpposite annotation stacks when using -.\n\n\nBy wrapping object with with_quad(), the + operator will apply the object not only to the active plot in the annotation stack, but also to the main plot unless specified by main argument otherwise.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # apply the object not only to the active plot in the annotation stack, but\n    # also to the main plot\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy wrapping object with with_quad(), the - operator will apply the object not only to that annotation stack but also to the opposite one (i.e., bottom if top is active, and vice versa). In these cases, the object will also be applied to the main plot by default unless specified by main argument otherwise.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Change the active layout to the left annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the theme of all plots in the bottom and the opposite annotation\n    # in this way, the `main` argument by default would be `TRUE`\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe position argument can be a string containing one or more of \"t\", \"l\", \"b\", and \"r\", indicating which annotation stack should be used as the context. When the position argument is manually set, the default value of the main argument will be FALSE.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots in the left and top annotation\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), \"tl\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nSetting position to NULL change the context to the ggheatmap()/quad_layout() itself.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # we apply the theme to the main plot only\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots\n    with_quad(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n8.4.2 stack_layout()\nWhen the active layout is the stack_layout() itself, by default, by wrapping object with with_quad(), - operator will apply changes to all plots along the stack_layout(), which means if the stack layout is in horizontal, - operator will also add the element to the left and right annotation, if the stack layout is in vertical, - operator will also add element to the top and bottom annotation. In these cases, the object will also be applied to the main plot by default unless specified by main argument otherwise.\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    anno_top() +\n    align_dendro() +\n    ggtitle(\"I'm from the nested heatmap\") +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout (including plots in the heatmap layout)\n    with_quad(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n+ operator won’t do anything special when the active layout is the stack_layout() itself.\nWhen the active layout is the nested ggheatmap()/quad_layout(), the +/- operator applies the elements to this nested layout, following the same principles as for ggheatmap()/quad_layout().",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Operators</span>"
    ]
  }
]