[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggalign: Bridging the Grammar of Graphics and Complex layout",
    "section": "",
    "text": "Preface\nWelcome to ggalign documents. Examples in the book are generated under version 0.0.5.9000.\nIn the world of data visualization, aligning multiple plots in a coherent and organized layout is often a challenging task, especially when dealing with complex datasets that require precise alignment across rows, columns, and even within plot elements. While existing tools provide some solutions, they often fall short in offering the flexibility, control, and simplicity that users need to create intricate and beautiful plots. This is where ggalign comes in.\nThe ggalign package, built on top of the powerful ggplot2 framework, is designed to solve this very problem. It offers a suite of functions specifically crafted for aligning and organizing plots with minimal effort. Whether you need to align observations based on statistical measures, group plots by categorical factors, or fine-tune the layout to match the precise needs of your data, ggalign gives you the tools you need to create polished, publication-ready visualizations.\nThis book serves as both an introduction to the ggalign package and a comprehensive guide to mastering its features. Whether you’re a beginner or an experienced user of ggplot2, you’ll find detailed explanations, step-by-step tutorials, and real-world examples to help you leverage the full potential of ggalign in your work.\nThroughout this book, we will cover everything from basic concepts to advanced layout customizations, focusing on key functions like stack_layout(), align_* series (including align_group(), align_order(), and align_hclust()), and how to combine them with other ggplot2 layers to create aligned plots. Additionally, you’ll learn how to adapt ggalign for different data types and scenarios, allowing you to develop flexible, dynamic visualizations tailored to your specific needs.\nBy the end of this book, you will be equipped to use ggalign effectively in your own projects, whether for scientific research, data analysis, or any other field where data visualization is key. Our goal is to provide you with the knowledge and confidence to tackle complex visualization challenges and transform your datasets into clear, impactful, and visually appealing plots.\nThank you for choosing ggalign. We hope this book will inspire you to explore the endless possibilities that come with aligned data visualization.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Installation\nggalign extends ggplot2 by providing advanced tools for aligning and organizing multiple plots, particularly those that automatically reorder observations, such as dendrogram. It offers fine control over layout adjustment and plot annotations, enabling you to create complex visualizations while leveraging the familiar grammar of ggplot2.\nYou can install ggalign from CRAN using:\ninstall.packages(\"ggalign\")\nAlternatively, install the development version from r-universe with:\ninstall.packages(\"ggalign\",\n    repos = c(\"https://yunuuuu.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nor from GitHub with:\n# install.packages(\"remotes\")\nremotes::install_github(\"Yunuuuu/ggalign\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#general-design",
    "href": "introduction.html#general-design",
    "title": "1  Introduction",
    "section": "1.2 General design",
    "text": "1.2 General design\nThe core feature of ggalign lies in its integration of the grammar of graphics into advanced visualization through its object-oriented Layout system. The package provides two main Layout classes:\n\nthe StackLayout class: Put plots horizontally or vertically.\nthe QuadLayout class: Arranges plots in the four quadrants (top, left, bottom, right) around a main plot. This layout is ideal for designs that require supplementary plots or annotations surrounding a central figure.\n\nBoth Layout classes support the alignment of observations (ordinal variable). Observations refer to data points or samples, allowing for consistent alignment of corresponding data across multiple plots when using the same axis values. Depending on whether you want to align observations across multiple plots within the layout, the following variants are available:\nFor StackLayout:\n\nstack_align(): Align the observations along the stack.\nstack_free(): Does not align the observations.\n\nFor QuadLayout:\n\nquad_free/ggside: Never align observations.\nquad_alignh: Align observations in the horizontal direction.\nquad_alignv: Align observations in the vertical direction.\nquad_alignb: Align observations in both horizontal and vertical directions.\n\n\n\n\nGeneral design of ggalign",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#getting-started",
    "href": "introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.3 Getting Started",
    "text": "1.3 Getting Started\n\nlibrary(ggalign)\n\nLoading required package: ggplot2\n\n\nThe usage of ggalign is simple if you’re familiar with ggplot2 syntax, the typical workflow includes:\n\nInitialize the layout using:\n\n\nstack_layout(): Arrange Plots Horizontally or Vertically\n\ncross_align: Arrange Plots Crosswise Horizontally or Vertically\n\nquad_layout(): Arrange Plots in the Quad-Side of a main plot\n\nggheatmap(): Create a Complex Heatmap.\nggoncoplot(): Create OncoPrint Visualizations from Genetic Alteration Data\n\n\n\nCustomize the layout with:\n\n\nalign_group(): Group observations into panel with a group variable.\nalign_kmeans(): Group observations into panel by kmeans.\nalign_order(): Reorder layout observations based on statistical weights or by manually specifying the observation index.\nalign_hclust(): Reorder or group observations based on hierarchical clustering.\n\n\nAdding plots with align_dendro(), ggalign() or ggfree(), and then layer additional ggplot2 elements such as geoms, stats, or scales.\n\n\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(56), nrow = 7)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\n\nEvery *_layout() function accepts default data, which will be inherited by all plots within the layout.\nHere’s a simple example:\n\n1stack_alignv(small_mat) +\n2    align_dendro() +\n3    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThis produces a simple dendrogram. By default, stack_alignv() removes the axis text on the axis used for aligning observations. This is because it’s often unclear which plot should display the axis text, as typically, we want it to appear in only one plot. However, you can easily use the theme() function to control where the axis text appears.\nInternally, align_dendro() will reorder the observations based on the dendrogram, and other plots in the layout will follow this ordering.\n\n1stack_alignv(small_mat) +\n2    align_dendro() +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.names, value), stat = \"identity\") +\n5    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder the observations based on hierarchical clustering and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nThe data in the underlying ggplot object of ggalign() function contains at least following columns (more details will be introduced in the later chapter):\n\n.panel: the group panel for the aligned axis. It means x-axis for vertical stack layout (including top and bottom annotation), y-axis for horizontal stack layout (including left and right annotation).\n.x or .y: the x or y coordinates\n.names and .index: A factor of the names (only applicable when names exists) and an integer of index of the original data.\nvalue: the actual value (only applicable if data is a matrix or atomic vector).\n\nIt is recommended to use .x/.y, or .names as the x/y mapping.\nalign_dendro() can also split the observations into groups.\n\n1stack_alignv(small_mat) +\n2    align_dendro(k = 3) +\n3    ggalign(data = rowSums) +\n4    geom_bar(aes(.names, value, fill = .panel), stat = \"identity\") +\n5    scale_fill_brewer(palette = \"Dark2\", name = \"Group\") +\n6    theme(axis.text.y = element_text())\n\n\n1\n\nWe initialize a vertical stack.\n\n2\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree.\n\n3\n\nCreate a new ggplot in the layout, and use data based on the sum of the layout data.\n\n4\n\nAdd a bar layer.\n\n5\n\nAdd fill mapping scale.\n\n6\n\nAdd y-axis text.\n\n\n\n\n\n\n\n\n\n\n\nOne common visualization associated with the dendrogram is the heatmap. You can use ggheatmap() to initialize a heatmap layout. When grouping the observations using align_dendro(k = 3), a special column named branch is added, which you can use to color the dendrogram tree.\n\n1ggheatmap(small_mat) +\n2    anno_left() +\n3    align_dendro(aes(color = branch), k = 3) +\n4    scale_fill_brewer(palette = \"Dark2\")\n\n\n1\n\nWe initialize a heatmap layout.\n\n2\n\nwe initialize an annotation in the left side of the heatmap body, and set it as the active context, in this way, all following addition will be directed to the left annotation.\n\n3\n\nReorder and group the observations based on hierarchical clustering, and add a dendrogram tree, coloring the tree by branch.\n\n4\n\nAdd fill mapping scale.\n\n\n\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nggheatmap() will automatically add axis text in the heatmap body, so you don’t need to manually adjust axis text visibility using theme(axis.text.x = element_text())/theme(axis.text.y = element_text()).\nHaving explored the core principles of ggalign, you should now be familiar with its basic workflow. In the next chapter, we’ll introduce the StackLayout functionality, a powerful tool for arranging multiple plots in a stacked fashion—either horizontally or vertically—while maintaining full control over their alignment. We’ll explore how stack_layout() and its various functions can give you even greater flexibility in creating sophisticated layouts.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "stack-layout.html",
    "href": "stack-layout.html",
    "title": "2  stack layout",
    "section": "",
    "text": "2.1 Input data\nstack_layout() arranges plots either horizontally or vertically, and we can also use the alias ggstack(). Based on whether we want to align the observations, there are two types of stack layouts:\nSeveral aliases are available for convenience:\nWhen aligning observations, we typically use a matrix, as it is easy to melt the matrix into a long-formatted data frame. Additionally, matrices are used to fit the observation concept, as they can be transposed (rows to columns, columns to rows), which is necessary for use in functions like quad_layout() and ggheatmap(), where observations may be aligned in both directions simultaneously.\nBy default, fortify_data_frame() will invoke the ggplot2::fortify() function for conversion. Note, for matrix, it will be converted to a long-formatted data frame.\nstack_align()/stack_free() will set up the layout, but no plot will be drawn until you add a plot element:\n1stack_alignh(small_mat) +\n2    layout_annotation(\n        theme = theme(plot.background = element_rect(color = \"red\"))\n    )\n# the same for `stack_free()`\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nAdd a plot background in for the entire layout.\nIn this example, we use layout_annotation() to insert a plot background in the entire layout, it can be also used to control the theme of title, subtitle, caption (layout_title()), guides, margins, panel.border.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack_layout_input_data",
    "href": "stack-layout.html#sec-stack_layout_input_data",
    "title": "2  stack layout",
    "section": "",
    "text": "For stack_free(), a data frame is required, and the input will be automatically converted using fortify_data_frame() if needed.\nFor stack_align(), a matrix is required, and the input will be automatically converted using fortify_matrix() if needed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#layout-customization",
    "href": "stack-layout.html#layout-customization",
    "title": "2  stack layout",
    "section": "2.2 Layout Customization",
    "text": "2.2 Layout Customization\nWhen we use stack_align(), it aligns the observations across multiple plots along the specified direction:\n\nFor stack_alignh(): Alignment occurs along the horizontal direction (y-axis).\nFor stack_alignv(): Alignment occurs along the vertical direction (x-axis).\n\nThe package offers a suite of align_* functions designed to give you precise control over the observations. These functions enable you to reorder the observations or partition the observations into multiple groups. Instead of detailing each align_* function individually, we will focus on the general usage and how to combine them with stack_align().\nHere, we remain take align_dendro() as a example, it can reorder the observations, split them into groups, and can add a plot for visualization.\nWhen used for stack_alignh(), the observations are aligned along the y-axis:\n\n1stack_alignh(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen used for stack_alignv(), the observations are aligned along the x-axis:\n\n1stack_alignv(small_mat) +\n2    align_dendro()\n\n\n1\n\ninitialize a vertical stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen align_dendro() is added to the layout, it performs following actions:\n1. reorder the observations.\n2. set the active plot to the dendrogram.\nThe active plot refers to the plot that subsequent ggplot2 components will target. In this case, the active plot is the dendrogram, and any new layers added will be applied to it. For instance, we can add additional layers to visualize the dendrogram’s structure or data. The default data underlying the ggplot object of align_dendro() consists of the dendrogram node data. It is also possible to use the dendrogram’s edge data for customization, which I will introduce in a later chapter.\n\n1stack_alignh(small_mat) +\n2    align_dendro() +\n3    geom_point()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot.\n\n3\n\nadd a point layer to the dendrogram\n\n\n\n\n\n\n\n\n\n\n\nThe active argument controls whether a plot should be set as the active plot. It accepts an active() object with the use argument to specify if the plot should be active when added.\n\n1stack_alignh(small_mat) +\n2    align_dendro(active = active(use = FALSE)) +\n3    geom_point()\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, but don’t set the active plot to this plot.\n\n3\n\ntry to add a point layer to the dendrogram, should fail due to no active plot\n\n\n\n\nError in `stack_layout_add()`:\n! Cannot add `geom_point()` to `stack_align()`\nℹ No active plot component\nℹ Did you forget to initialize a &lt;ggplot&gt; object with `ggalign()` or\n  `ggfree()`?\n\n\nUsually, you don’t need to set this manually, as the active context is automatically applied only for functions that add plot areas. You can inspect whether a align_* function will add a plot by print it:\n\nalign_dendro()\n\n`align_dendro()` object:\n  plot: yes\n  reorder: yes\n  split: no\n\n\nYou might find it confusing that we mentioned align_dendro() will split observations into groups, while the print output shows split = \"no\". This happens because we haven’t specified the k/h argument in align_dendro().\n\nalign_dendro(k = 3L)\n\n`align_dendro()` object:\n  plot: yes\n  reorder: yes\n  split: yes\n\n\nYou don’t need to explicitly provide data to align_dendro(). By default, it inherits data from the layout. However, you can always provide another data source, but note that this package uses the concept of number of observations (NROW()). When aligning the observations, you must ensure the number of observations is consistent across all plots.\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = matrix(rnorm(56), nrow = 8)) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on hierarchical clustering, add a dendrogram tree, and set the active plot to this one, using self-provided data. This should fail because the number of observations is inconsistent.\n\n3\n\ntry to add y-axis text to the dendrogram.\n\n\n\n\nError in `align()`:\n! `align_dendro(data = matrix(rnorm(56), nrow = 8))` (nobs: 8) is not\n  compatible with the `stack_align()` (nobs: 7)\n\n\n\nset.seed(123)\n1stack_alignh(small_mat) +\n2    align_dendro(data = matrix(rnorm(70), nrow = 7)) +\n3    theme(axis.text.y = element_text())\n\n\n1\n\ninitialize a horizontal stack layout.\n\n2\n\nreorder the observations based on the hierarchical clustering, add a dendrogram tree, and set the active plot to this plot, using self-provided data\n\n3\n\nadd y-axis text to the dendrogram.\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can provide a function (or purrr-lambda) that will be applied to the layout’s matrix. For layouts that align observations, a matrix is always required, so the data input must be in matrix form.\n\nset.seed(123)\nstack_alignh(small_mat) +\n    align_dendro(data = ~ .x[sample(nrow(.x)), ]) +\n    theme(axis.text.y = element_text())\n\n\n\n\n\n\n\n\nWithout adding another plot, it’s difficult to appreciate the benefits. Let’s now explore how to incorporate a plot.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#plot-initialize",
    "href": "stack-layout.html#plot-initialize",
    "title": "2  stack layout",
    "section": "2.3 Plot initialize",
    "text": "2.3 Plot initialize\nThere are two primary functions for adding plots:\n\nalign_gg()/ggalign(): Create a ggplot object and align with the layout.\nfree_gg()/ggfree(): Create a ggplot object without aligning.\n\nBoth functions initialize a ggplot object and, by default, set the active plot when added to the layout.\nFor stack_align(), plots can be added regardless of whether they need to align observations.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can build the plot separately and then add it to the layout:\n\nmy_bar &lt;- ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \nstack_alignh(small_mat) +\n    align_dendro() +\n    my_bar\n\n\n\n\n\n\n\n\nThe active argument can also control the place of the plot area to be added. It accepts an active() object with the order argument to specify the order of the plot area.\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums, active = active(order = 1)) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nYou can also stack plots vertically using stack_alignv():\n\nstack_alignv(small_mat) + \n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    theme(axis.text.y = element_text()) \n\n\n\n\n\n\n\n\nstack_align() can also add plot without aligning observations. free_gg() focuses on layout integration without enforcing strict axis alignment. ggfree() is an alias for free_gg.\n\nstack_alignv() +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nThe & operator applies the added element to all plots in the layout, similar to its functionality in the patchwork package.\nFor stack_free(), only free plots (ggfree()) can be added. This layout arranges plots in one row or column without enforcing axis alignment:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nBy default, ggfree() will also inherit data from the layout and call fortify_data_frame() to convert the data to a data frame. So, note that if the layout data is a matrix, it will be converted into a long-formatted data frame.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack_layout_plot_size",
    "href": "stack-layout.html#sec-stack_layout_plot_size",
    "title": "2  stack layout",
    "section": "2.4 Plot Size",
    "text": "2.4 Plot Size\nBoth ggalign() and ggfree() functions have a size argument to control the relative width (for horizontal stack layout) or height (for vertical stack layout) of the plot’s panel area.\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 2) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = 1) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()\n\n\n\n\n\n\n\n\nAlternatively, you can define an absolute size by using a unit() object:\n\nstack_freev(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class), size = unit(1, \"cm\")) +\n    geom_point(size = 2) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) &\n    scale_color_brewer(palette = \"Dark2\") &\n    theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#active-plot",
    "href": "stack-layout.html#active-plot",
    "title": "2  stack layout",
    "section": "2.5 active plot",
    "text": "2.5 active plot\nAs mentioned earlier, the active plot refers to the plot that subsequent ggplot2 components will target. The package provide two functions to work with active plot.\n\nstack_switch(): switch the active context\nstack_active: An alias for stack_switch(), which sets what = NULL\n\nThe stack_switch() function accepts the what argument, which can either be the index of the plot added (based on its adding order) or the plot name specified via the active() object using the name argument.\nNote that the what argument must be explicitly named, as it is placed second in the function signature. This is because, in most cases, we don’t need to switch the active plot manually—adjusting the order of plot additions typically suffices.\n\n\n\nstack_alignh(small_mat) +\n    align_dendro() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    # switch to the `align_dendro()` plot area\n    stack_switch(what = 1) +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by integer\")\n\n\n\n\n\n\n\n\n\n\n\nstack_alignh(small_mat) +\n    align_dendro(active = active(name = \"tree\")) +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, .names), stat = \"identity\") +\n    # switch to the `align_dendro()` plot area\n    stack_switch(what = \"tree\") +\n    geom_point() +\n    theme(axis.text.y = element_text()) +\n    layout_title(title = \"switch by string\")\n\n\n\n\n\n\n\n\n\n\nIn the example, we use layout_title() to insert a title for the entire layout. Alternatively, you can add a title to a single plot with ggtitle().\nBy setting what = NULL (or alias stack_active()), we remove the active plot. This is particularly useful when the active plot is a nested Layout object, as any additions would otherwise be directed to that nested Layout. By removing the active plot, you can continue adding components directly to the StackLayout.\nIn the next chapter, we will dive into the HeatmapLayout, which can take the StackLayout as input. Heatmap layouts offer additional features for aligning observations in both directions. Let’s move ahead and explore how heatmaps can be seamlessly integrated into your layout workflows.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>stack layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html",
    "href": "heatmap-layout.html",
    "title": "3  heatmap layout",
    "section": "",
    "text": "3.1 input data\nThe heatmap_layout() function provides a powerful way to create customizable heatmaps in R using ggplot2. This chapter will guide you through its usage.\nheatmap_layout() is a specialized version of quad_alignb(), which itself is a specific variant of QuadLayout (quad_layout()) designed to align observations both horizontally and vertically. We introduce heatmap_layout() directly, as it is more familiar to many users, especially those experienced with popular heatmap packages like pheatmap and ComplexHeatmap.\nheatmap_layout() simplifies the creation of heatmap plots by integrating essential elements for a standard heatmap layout, ensuring that the appropriate data mapping and visualization layers are automatically applied. ggheatmap() is an alias for heatmap_layout().\nAs mentioned in Section 2.1, we typically require a matrix for the Layout which need align observations. Internally, fortify_matrix() will be used to process the data. You can provide a numeric or character vector, a data frame, or any other data type that can be converted into a matrix using as.matrix().\nggheatmap(small_mat)\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#heatmap-body",
    "href": "heatmap-layout.html#heatmap-body",
    "title": "3  heatmap layout",
    "section": "3.2 heatmap body",
    "text": "3.2 heatmap body\nA ggplot object will be automatically created for the heatmap body, the matrix input will be converted into a long formated data frame when drawing. The data in the underlying ggplot object contains following columns:\n\n.xpanel and .ypanel: the column and row panel\n.x and .y: the x and y coordinates\n.row_names and .column_names: A factor of the row and column names of the original matrix (only applicable when names exist).\n.row_index and .column_index: the row and column index of the original matrix.\nvalue: the actual matrix value.\n\nThe default mapping will use aes(.data$.x, .data$.y), but can be customized using mapping argument.\nBy default, the heatmap body is regarded as the active plot, meaning you can add ggplot2 elements directly to the heatmap body.\n\nggheatmap(small_mat) + \n    geom_point() + \n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nBy default, ggheatmap()/heatmap_layout() adds a heatmap layer. If the matrix has more than 20,000 cells (nrow * ncol &gt; 20000), it uses geom_raster() for performance efficiency; for smaller matrices, geom_tile() is used. You can explicitly choose the layer by providing a single string (\"raster\" or \"tile\") in the filling argument.\n\nggheatmap(small_mat, filling = \"raster\")\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = \"tile\")\n\n\n\n\n\n\n\n\nNote, the filling layer will always use mapping of aes(.data$.x, .data$.y), if you want to customize filling, you can set filling = NULL, which will remove the filling layer and allow you to add custom filling geoms.\n\nggheatmap(small_mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"black\", width = 0.9, height = 0.9)\n\n\n\n\n\n\n\n\nA heatmap pie charts can be easily drawn:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#rasterization",
    "href": "heatmap-layout.html#rasterization",
    "title": "3  heatmap layout",
    "section": "3.3 rasterization",
    "text": "3.3 rasterization\nWhen working with large heatmaps, it’s often beneficial to rasterize the heatmap body layer. You can achieve this by using the raster_magick() function. The res argument controls the resolution of the raster image. By default, the res argument matches the resolution of the current device, but specifying a different value can help reduce the resolution of the rasterized heatmap body.\n\nggheatmap(small_mat, filling = NULL) +\n    raster_magick(geom_tile(aes(fill = value)), res = 50)\n\n\n\n\n\n\n\n\nBy leveraging raster_magick(), you can also perform image post-processing using the magick package. This allows for custom image resizing with filters.\n\nggheatmap(small_mat, filling = NULL) +\n    # Use `magick::filter_types()` to check available `filter` arguments\n    raster_magick(geom_raster(aes(fill = value)),\n        magick = function(image) {\n            magick::image_resize(image,\n                # we resize to the 50% of width\n                geometry = \"50%x\", filter = \"Lanczos\"\n            )\n        }\n    )\n\n\n\n\n\n\n\n\nNote: When using magick::image_resize(), you should specify the geometry argument to resize the image. If only the filter is specified, it will only distort the image data (though subtle). For more information on image resizing, refer to ImageMagick’s resize documentation.\nYou can also rasterize all plots in the layout directly with raster_magick(). This method is defined for both ggheatmap()/quad_layout() and stack_layout() objects.\nAdditionally, You can use external packages like ggrastr or ggfx to rasterize the heatmap body.\n\nggheatmap(small_mat, filling = FALSE) +\n    ggrastr::rasterise(geom_tile(aes(fill = value)), dev = \"ragg\")\n\n\n\n\n\n\n\n\nLikewise, you can also rasterize all plots in the layout directly with ggrastr::rasterise() for both ggheatmap()/quad_layout() and stack_layout().\n\nggrastr::rasterise(ggheatmap(small_mat), dev = \"ragg\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nFurthermore, ggfx offers many image filters that can be applied to ggplot2 layers. See the package for the details.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#annotations",
    "href": "heatmap-layout.html#annotations",
    "title": "3  heatmap layout",
    "section": "3.4 annotations",
    "text": "3.4 annotations\nIn ggheatmap()/quad_layout(), annotations are handled by a stack_layout() object and can be positioned at the top, left, bottom, or right of the main plot (heatmap body).\nBy default, ggheatmap()/quad_layout() do not activate an annotation, You can use quad_anno() to activate an annotation, directing all subsequent additions to the specified annotation position. The quad_anno() function has the following aliases:\n\nanno_top: A special case of quad_anno() with position = \"top\".\nanno_left: A special case of quad_anno() with position = \"left\".\nanno_bottom: A special case of quad_anno() with position = \"bottom\".\nanno_right: A special case of quad_anno() with position = \"right\".\n\nWhen quad_anno() is added to a ggheatmap()/quad_layout(), it will try to automatically create a new stack_layout() (either stack_align() or stack_free()) depending on whether you want to align observations in the specified direction. For top and bottom annotations, stack_alignv() or stack_freev() will be used; for left and right annotations, stack_alignh() or stack_freeh() will be applied.\nAdditionally, quad_anno() will set the active context to the annotation. This means that subsequent additions will be directed to the annotation rather than the main plot. We use the term active context in contrast to active plot (as described in Chapter 2), since the annotation is a Layout object.\n\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the left annotation\n    anno_left() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nBy default, the annotation stack_layout() will inherit data from ggheatmap()/quad_layout(). If the observations require alignment vertically, this means the data from ggheatmap()/quad_layout() should be a matrix, the column annotations will also require a matrix and the matrix from ggheatmap()/quad_layout() will be transposed for use in the column annotations.\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can further customize the layout design or add new plots in the annotation stack, as described in Chapter 2.\n\nggheatmap(small_mat) +\n    # in the heatmap body, we set the axis text theme\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the right annotation\n    anno_right() +\n    # in the right annotation, we add a dendrogram\n    align_dendro(k = 3L) +\n    # in the dendrogram, we add a point layer\n    geom_point(aes(color = factor(branch)))\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nIn this example:\n\nanno_right() initialize the right annotation stack, and change the active context to the right of the heatmap.\nalign_dendro(k = 3L) adds a dendrogram to the annotation and sets itself as the active plot in the annotation stack.\ngeom_point(aes(color = factor(branch))) is then added to this active plot within the annotation stack, here, it means the align_dendro() plot.\n\nggheatmap() aligns observations both horizontally and vertically, so it’s safe to always use quad_anno() directly, as all annotations require a matrix, and the layout data is also a matrix. However, for quad_alignh() and quad_alignv(), which only align observations in one direction, the data in the layout may not fit the data for the annotation (when the layout requires alignment of observations, we typically use a matrix, regardless of whether alignment is needed in one or two directions) - quad_alignh(): aligning observations in horizontal direction, for column annotations, we ll need a data frame for stack_free(). - quad_alignv(): aligning observations in vertical direction, for row annotations, we ll need a data frame for stack_free().\nIn both conditions, quad_anno() won’t initialize the annotation by default, instead, you must provide the annotation stack_layout() manually.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#adding-stack-layout",
    "href": "heatmap-layout.html#adding-stack-layout",
    "title": "3  heatmap layout",
    "section": "3.5 Adding stack layout",
    "text": "3.5 Adding stack layout\nLike adding plot in stack_layout() (Chapter 2), when the direction neeed alignment, you can add a stack_layout() regardless of whether it need to align observations.\nTo add a stack_layout() to the ggheatmap(), we must prevent the automatical creation of annotation by quad_anno() by setting initialize = FALSE\n\n\n\nmy_stack_align &lt;- stack_alignh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_align +\n    layout_title(\"stack_align()\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nmy_stack_free &lt;- stack_freeh(mpg) +\n    ggfree(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(size = 2)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack_free +\n    layout_title(\"stack_free()\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nNote when aligning the observations, you must ensure the number of observations is consistent in the direction. So for column annotations, you need transpose the data manually.\n\nmy_stack &lt;- stack_alignv(t(small_mat)) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    anno_top(initialize = FALSE) +\n    my_stack\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_active",
    "href": "heatmap-layout.html#quad_active",
    "title": "3  heatmap layout",
    "section": "3.6 quad_active()",
    "text": "3.6 quad_active()\nTo remove the active context and redirect additions back to the heatmap body, you can use quad_active().\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_active() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_switchhmanno",
    "href": "heatmap-layout.html#quad_switchhmanno",
    "title": "3  heatmap layout",
    "section": "3.7 quad_switch()/hmanno()",
    "text": "3.7 quad_switch()/hmanno()\nWe also provide quad_switch()/hmanno() (heatmap annotation) which integrates quad_active() and quad_anno() into one function for ease of use. Feel free to use any of these functions to streamline your annotation process.\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    quad_switch(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_switch() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    hmanno(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    hmanno() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#plot-size",
    "href": "heatmap-layout.html#plot-size",
    "title": "3  heatmap layout",
    "section": "3.8 Plot Size",
    "text": "3.8 Plot Size\n\n3.8.1 Heatmap Body Size\nYou can specify the relative sizes of the heatmap body using the width and height arguments in the ggheatmap() function.\n\nggheatmap(small_mat, height = 2) +\n    anno_top() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nAlternatively, the quad_active() function allows you to control the heatmap body sizes.\n\nggheatmap(small_mat) +\n    quad_active(height = 2) +\n    anno_top() +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n3.8.2 Annotation Stack Size\nThe quad_anno() function allows you to control the total annotation stack size. The size argument controls the relative width (for left and right annotations) or height (for top and bottom annotations) of the whole annotation stack.\n\nggheatmap(small_mat) +\n    anno_top(size = 1) +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can also specify it as an absolute size using unit():\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nNote that the size of an individual plot (Section 2.4) does not affect the total annotation stack size. You must adjust the annotation size using the method described above.\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(size = unit(30, \"mm\")) +\n    layout_title(\"plot size\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    layout_title(\"annotation size\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nIn this chapter, we explored the usage of heatmap layouts. These features provide a strong foundation for visualizing matrix-based data in a structured way. However, as your visualization needs grow more complex, the ability to further customize and fine-tune the layout becomes essential.\nIn the next chapter, we will dive into the Layout Customize functionalities, where you can gain full control over your plot’s layout.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>heatmap layout</span>"
    ]
  },
  {
    "objectID": "layout-customize.html",
    "href": "layout-customize.html",
    "title": "4  Layout customize",
    "section": "",
    "text": "4.1 align_group()\nFor layouts that can align observations, the package provides a suite of align_* functions designed to give you precise control over the observations. These functions allow you to reorder observations or partition them into multiple groups.\nCurrently, there are four key align_* functions available for layout customization:\nYou can inspect the behavior of any align_* function by printing it. Note that these functions do not add plot areas and set the active context, meaning you cannot incorporate ggplot2 elements directly into these objects.\nThe align_group() function allows you to split the observations into groups.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n\n→ heatmap built with `geom_tile()`\nNote that all align_* functions which split observations into groups must not break the previous established groups. This means the new groups must nest in the old groups, usually they cannot be used if groups already exist.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE)) +\n    align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n\nError in `align()`:\n! align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n  disrupt the previously established panel groups of the top annotation\n  `stack_align()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_order",
    "href": "layout-customize.html#align_order",
    "title": "4  Layout customize",
    "section": "4.2 align_order()",
    "text": "4.2 align_order()\nThe align_order() function reorder the observations based on the summary weights.\nIn this example, we order the rows based on their means. By default, the ordering is in ascending order according to the summary weights. You can reverse the order by setting reverse = TRUE.\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans) +\n    layout_title(title = \"reverse = FALSE\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans, reverse = TRUE) +\n    layout_title(title = \"reverse = TRUE\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nAdditionally, you can provide the ordering integer index or character index directly:\n\nmy_order &lt;- sample(nrow(small_mat))\nprint(rownames(small_mat)[my_order])\n\n[1] \"row4\" \"row3\" \"row7\" \"row6\" \"row5\" \"row1\" \"row2\"\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(my_order)\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rownames(small_mat)[my_order])\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nSome align_* functions also accept a data argument. It’s important to note that all align_* functions treat rows as the observations. This means NROW(data) must match the number of observations along the axis used for alignment. The data argument can also accept a function (supporting purrr-like lambda syntax), which will be applied to the layout matrix.\nAs mentioned in Chapter 3, for top and bottom annotations, the data matrix of quad_layout()/ggheatmap() is transposed to create the annotation stack_layout(). Therefore, you can use rowMeans() to calculate the mean value across all columns.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans)\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nSome align_* functions that reorder observations include an argument called strict. This argument is especially useful when previous groups have already been established. If previous groups have been created and strict = FALSE, the function will reorder the observations within each group.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))+\n    align_order(rowMeans, strict = FALSE)\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_kmeans",
    "href": "layout-customize.html#align_kmeans",
    "title": "4  Layout customize",
    "section": "4.3 align_kmeans()",
    "text": "4.3 align_kmeans()\nThe align_kmeans() function split the observations into groups based on k-means clustering.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n\n→ heatmap built with `geom_tile()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_hclust",
    "href": "layout-customize.html#align_hclust",
    "title": "4  Layout customize",
    "section": "4.4 align_hclust()",
    "text": "4.4 align_hclust()\nThe align_hclust() function is a specialized version of align_dendro(), designed to reorder observations and group them based on hierarchical clustering. Unlike align_dendro(), however, align_hclust() does not add a dendrogram tree to the plot. All the arguments intruduced here can also be used by align_dendro().\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nHierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. You can use the distance and method argument to control the builind process.\nThere are two ways to specify distance metric for clustering:\n\nspecify distance as a pre-defined option. The valid values are the supported methods in dist() function and coorelation coefficient \"pearson\", \"spearman\" and \"kendall\". The correlation distance is defined as 1 - cor(x, y, method = distance).\na self-defined function which calculates distance from a matrix. The function should only contain one argument.\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = \"pearson\") +\n    layout_title(\"pre-defined distance method (1 - pearson)\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = function(m) dist(m)) +\n    layout_title(\"a function that calculates distance matrix\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method. Possible methods are those supported in hclust() function. And you can also provide a self-defined function, which accepts the distance object and return a hclust object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(method = \"ward.D2\")\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can specify k or h to split observations into groups, which work similarly to cutree():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3L)\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can reorder the dendrogram based on the mean values of the observations by setting reorder_dendrogram = TRUE.\n\nh1 &lt;- ggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3, reorder_dendrogram = TRUE) +\n    layout_title(\"reorder_dendrogram = TRUE\")\nh2 &lt;- ggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3) +\n    layout_title(\"reorder_dendrogram = FALSE\")\nalign_plots(h1, h2)\n\n→ heatmap built with `geom_tile()`\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nIn this example, we use align_plots() to arrange the plots, which functions similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, unlike those, align_plots() can be directly used with quad_layout() and stack_layout(), ensuring proper alignment by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, although they won’t align by panel area in the same way as ggplot2 plots.\nalign_hclust() can also perform clustering between groups, meaning it can be used even if there are existing groups present in the layout, in this way, you cannot specify k or h:\n\nset.seed(3L)\ncolumn_groups &lt;- sample(letters[1:3], ncol(small_mat), replace = TRUE)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust()\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nYou can reorder the groups by setting reorder_group = TRUE.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(reorder_group = TRUE)\n\n→ heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nIf you specify k or h, this will always turn off sub-clustering. The same principle applies to align_hclust(), where new groups must be nested within the previously established groups.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(k = 2L)\n\nError in `align()`:\n! align_hclust(k = 2L) disrupt the previously established panel groups\n  of the top annotation `stack_align()`",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Layout customize</span>"
    ]
  }
]