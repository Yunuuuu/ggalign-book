[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ggalign: Bridging the Grammar of Graphics and Complex layout",
    "section": "",
    "text": "Preface\nWelcome to ggalign documents. Examples in the book are generated under version 1.0.2.9000.\nAs biomedical and multi-omics research generate increasingly complex and layered datasets, effective data visualization becomes essential for interpretation, communication, and discovery. Researchers often need to compare groups, track trends across samples, or highlight structures across various biological hierarchies — all of which demand precisely aligned plots.\nHowever, arranging multiple plots in a consistent and interpretable layout remains a tedious task. Existing tools offer partial solutions but often lack the flexibility needed for nuanced biological visualizations.\nggalign is built to address these challenges. Based on the grammar of graphics from ggplot2, it simplifies the alignment of plots across samples, features, conditions, or clusters — helping you produce clean, publication-ready figures.\nThis guide introduces the key concepts and functions of ggalign through practical examples. Whether you’re visualizing gene expression patterns, comparing cell clusters, or organizing panels across experiments, ggalign helps you build structured and reproducible visual narratives from your data.\nThank you for choosing ggalign. We hope this book will inspire you to explore the endless possibilities that come with aligned data visualization.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Installation\nThe ggalign package provides a flexible and powerful framework for composable visualization, making it easy to build complex multi-plot layouts—such as insets, multi-panel views, and circular compositions.\nBuilt on top of the grammar of graphics, ggalign introduces intuitive tools to align, stack, and nest plots in a way that preserves relationships between data sources—ideal for visualizing shared patterns, clustering results, or coordinated subplots.\nDesigned for high-dimensional data common in fields like genomics, transcriptomics, and microbiome research, ggalign helps you create publication-ready figures by composing diverse plots into cohesive, structured layouts.\nYou can install ggalign from CRAN using:\ninstall.packages(\"ggalign\")\nAlternatively, install the development version from r-universe with:\ninstall.packages(\"ggalign\",\n    repos = c(\"https://yunuuuu.r-universe.dev\", \"https://cloud.r-project.org\")\n)\nor from GitHub with:\n# install.packages(\"remotes\")\nremotes::install_github(\"Yunuuuu/ggalign\")",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "introduction.html#plot-composition",
    "href": "introduction.html#plot-composition",
    "title": "1  Introduction",
    "section": "\n1.2 Plot Composition",
    "text": "1.2 Plot Composition\nThe ggalign package supports two primary modes of composing plots:\n\nData-Free Composition – for visually arranging independent plots.\nData-Aware Composition – for aligning plots based on shared data structure.\n\nEach mode serves different purposes and offers tools tailored for its use case.\n\n1.2.1 Data-Free Composition: Simple Plot Arrangement\nData-free composition represents traditional plot arrangement where independent plots are spatially arranged without data relationships. This paradigm is conceptually aligned with tools like patchwork or cowplot, but ggalign provides finer control over alignment, spacing, and legend management, enabling more precise and expressive layout designs.\n\n1.2.1.1 What Is Data-Free Composition for?\nUse data-free composition when you want to:\n\nVisually compare results from different models or datasets.\nCombine summary, diagnostic, and metadata plots in figure panels.\nAnnotate plots with separate diagrams, legends, or auxiliary views.\nCreate layout templates that work across a variety of inputs.\n\nThis approach gives you full spatial control while preserving each plot’s independence. Because there’s no need to reconcile axes, or scales, it’s straightforward and versatile for many common multi-plot needs.\n\n1.2.1.2 What Will You Learn?\nThis part is divided into chapters, each addressing a specific graphical challenge. This is not an exhaustive or exclusive categorization but rather a practical guide to help you navigate common tasks in data-free plot composition.\n\n1.2.2 Data-Aware Composition: Integrated Data Visualization\nThis part introduces another core feature of the ggalign package: data-aware composition. Unlike data-free composition, which focuses solely on the visual arrangement of plots without considering shared data values, data-aware composition aligns plots based on common data characteristics—such as shared axis scales or categorical factors. This enables precise alignment of related plots where data correspondence matters.\n\n1.2.2.1 When to Use Data-Aware Composition\nChoose this mode when the alignment of plots must reflect relationships in the data—for example:\n\nAligning a heatmap with a bar plot showing row-wise summaries.\nLinking boxplots to clustered groups in an ordination plot.\nDisplaying annotations or tree structures beside data panels\n\n1.2.2.2 What Will You Learn?\nThis part is divided into sections that will guide you through:\n\nExploring the Layout system and its core types.\nUnderstanding key concepts of data-aware composition.\nLearning how to align plots based on shared data features.\nManaging discrete and continuous data for alignment.\nUsing grouping, ordering, and clustering to organize observations.\nAdding supporting visual elements like dendrograms and annotations.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "2  Get Started",
    "section": "",
    "text": "2.1 Data-Free Composition\nThis chapter shows simple usage examples of ggalign.\nThe usage of data-free composition is simple: just create plots first then arrange plots together!\n# Create individual plots\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp)) +\n    ggtitle(\"Scatter Plot\")\n\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(factor(cyl), mpg)) +\n    ggtitle(\"Box Plot\")\n\np3 &lt;- ggplot(mtcars) +\n    geom_histogram(aes(mpg), bins = 15) +\n    ggtitle(\"Histogram\")\n\n# Arrange plots in a grid\nalign_plots(p1, p2, p3, ncol = 2)\nThe align_plots() function offers flexible control over grid dimensions, sizing, and layout specifications. You can control the arrangement with parameters like ncol, nrow, widths, heights, and even use area() specifications for complex layouts.\nggalign provides various options to control layout specifications, including whether to collect legend guides, align axes, and more. For more, see Part Data-Free Composition.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Get Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#data-aware-composition",
    "href": "getting-started.html#data-aware-composition",
    "title": "2  Get Started",
    "section": "2.2 Data-Aware Composition",
    "text": "2.2 Data-Aware Composition\nA common use case for data-aware composition is combining a heatmap with a dendrogram. The dendrogram reveals hierarchical relationships among the data (e.g., samples or genes), and the heatmap is reordered to align with the dendrogram structure—ensuring consistent interpretation.\n\nset.seed(123)\n# Prepare heatmap matrix\nmat &lt;- matrix(\n    rnorm(200, mean = 5, sd = 2),\n    nrow = 20, ncol = 10,\n    dimnames = list(paste0(\"G\", 1:20), paste0(\"S\", 1:10))\n)\n\nCreate a basic heatmap:\n\nggheatmap(mat)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nWith ggalign, you can add elements using the same + syntax as in ggplot2. For example, to add a dendrogram above the heatmap:\n\n1ggheatmap(mat) +\n2    anno_top() +\n3    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\nWe initialize a heatmap layout.\n\n2\n\nwe initialize an annotation in the top side of the heatmap body.\n\n3\n\nAdd a dendrogram tree in the top annotation, and Reorder and group the observations based on hierarchical clustering.\n\n\n\n\n\n\n\n\n\n\n\nThis automatically reorders the heatmap rows or columns to reflect the hierarchical structure in the dendrogram.\nWhile data-aware composition is the core strength of ggalign, its full capabilities go beyond a single example. For more advanced features and finer control, see Part Data-Aware Composition.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Get Started</span>"
    ]
  },
  {
    "objectID": "getting-started.html#when-to-use-each-approach",
    "href": "getting-started.html#when-to-use-each-approach",
    "title": "2  Get Started",
    "section": "2.3 When to Use Each Approach",
    "text": "2.3 When to Use Each Approach\nUse data-free composition when: - Combining unrelated plots for publication figures - Creating dashboard-style layouts - Arranging plots with different data sources - Simple spatial arrangement is sufficient\nUse data-aware composition when: - Analyzing the same dataset from multiple perspectives - Creating heatmaps with annotations - Ensuring observation consistency across plots - Working with genomic, transcriptomic, or other omics data\nThis foundational understanding of ggalign’s two composition modes will guide you through the more advanced features covered in subsequent chapters.",
    "crumbs": [
      "Welcome",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Get Started</span>"
    ]
  },
  {
    "objectID": "plot-composer.html",
    "href": "plot-composer.html",
    "title": "3  Plot Composer",
    "section": "",
    "text": "3.1 Plots Arrangement\nThe align_plots() function is the core engine for data-free composition in the ggalign package. It enables users to arrange multiple plots and graphical objects into a structured layout, with fine control over spacing, alignment, size, and guide collection — all independent of the underlying data or coordinate systems.\nThis section provides a comprehensive breakdown of its key arguments, along with how they affect the final layout.\nWe’ll start with a few well-known example plots:\nYou can pass plots as individual arguments:\nalign_plots(p1, p2, p3, p4, p5)\nOr use bang-bang-bang to add a list of plots\nalign_plots(!!!list(p1, p2, p3), p4, p5)",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#grid-layout",
    "href": "plot-composer.html#grid-layout",
    "title": "3  Plot Composer",
    "section": "\n3.2 Grid Layout",
    "text": "3.2 Grid Layout\nLike patchwork, if no specific layout is provided, align_plots() will attempt to create a grid that is as square as possible, with each column and row taking up equal space:\n\nalign_plots(p1, p2, p3, p4, ncol = 3)\n\n\n\n\n\n\n\nUse byrow = FALSE to fill the grid column-wise (top to bottom, then left to right) instead of the default row-wise layout:\n\nalign_plots(p1, p2, p3, p4, p5, ncol = 3, byrow = FALSE)\n\n\n\n\n\n\n\nAlternatively, use named layout strings for complex control over placement:\n\nalign_plots(\n    A = p1, B = p2, C = p3,\n    area = \"\n    AABB\n    CCDD\n  \"\n)\n\n\n\n\n\n\n\nFor even more control, you can use area() to define a layout manually:\n\nalign_plots(p1, p2, p3, p4, area = c(\n    area(1, 1, 1, 2), # p1: spans columns 1–2\n    area(2, 1, 3, 1), # p2: spans rows 2–3, column 1\n    area(2, 2, 3, 2), # p3: same shape as p2, column 2\n    area(4, 1, 4, 2) # p4: same shape as p1, row 4\n))",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#plot-panel-size",
    "href": "plot-composer.html#plot-panel-size",
    "title": "3  Plot Composer",
    "section": "\n3.3 Plot Panel Size",
    "text": "3.3 Plot Panel Size\nUse widths and heights to control how much space each panel column or panel row should take, respectively. These can be:\n\nRelative values (e.g., widths = c(2, 1) means the first column is twice as wide)\nunit() values from the grid package, if you want fixed sizing.\n\n\nalign_plots(p1, p2, p3, p4, widths = c(2, 1))",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#leaving-empty-spaces",
    "href": "plot-composer.html#leaving-empty-spaces",
    "title": "3  Plot Composer",
    "section": "\n3.4 Leaving Empty Spaces",
    "text": "3.4 Leaving Empty Spaces\nTo create gaps in your layout, insert NULL where a plot would go:\n\nalign_plots(p1, NULL, p2, NULL, p3, NULL)\n\n\n\n\n\n\n\nEmpty cells will still take up layout space unless you explicitly adjust sizes.",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "plot-composer.html#guide-legends",
    "href": "plot-composer.html#guide-legends",
    "title": "3  Plot Composer",
    "section": "\n3.5 Guide Legends",
    "text": "3.5 Guide Legends\nBy default, each plot keeps its own guides. Use the guides argument to collect and consolidate them to specific sides, which should be of a single string with following elements:\n\n\"t\" — collect top guide legends\n\"r\" — collect right guide legends\n\"b\" — collect bottom guide legends\n\"l\" — collect left guide legends\n\"i\" - Collect guide legends inside the plot panel area (plot panel guides)\n\n\np_right &lt;- ggplot(mtcars) +\n    geom_point(aes(hp, wt, colour = mpg)) +\n    scale_color_continuous(guide = guide_colorbar(position = \"right\")) +\n    labs(color = \"From\\nP1\") +\n    ggtitle(\"P1\")\n\np_left &lt;- ggplot(mtcars) +\n    geom_point(aes(hp, wt, colour = factor(cyl))) +\n    scale_color_brewer(\n        palette = \"Dark2\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    labs(color = \"From\\nP2\") +\n    ggtitle(\"P2\")\n\n\n\n\nalign_plots(p_right, p_left)\n\n\n\n\n\n\n\n\n\n\nalign_plots(p_right, p_left, guides = \"lr\")\n\n\n\n\n\n\n\n\n\nIf align_plots() is nested in another align_plots(), the nested align_plots() will inherit the guides argument from the upper-level align_plots(). And the top-level align_plots() won’t collect guide legends from plots within the nested align_plots() unless the nested align_plots() collects them first.",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Plot Composer</span>"
    ]
  },
  {
    "objectID": "free.html",
    "href": "free.html",
    "title": "4  Fine-Grained Alignment Control",
    "section": "",
    "text": "4.1 Position String Notation\nThe ggalign package provides six free_ functions that give you precise control over plot alignment behavior by selectively disabling alignment constraints for specific plot elements in align_plots().\nMost free_ functions use a consistent \"tlbr\" notation system where each letter represents a side of the plot:\nFirst, let’s create some example plots:\n# A simple scatter plot\np_simple &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp))\n\n# Create a plot with long axis labels that causes alignment issues\np_wide_labels &lt;- ggplot(mtcars) +\n    geom_bar(aes(y = factor(gear), fill = factor(gear))) +\n    scale_y_discrete(\n        name = NULL,\n        labels = c(\n            \"3 gears are often enough\",\n            \"But, you know, 4 is a nice number\",\n            \"I would def go with 5 gears in a modern car\"\n        )\n    )",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#position-string-notation",
    "href": "free.html#position-string-notation",
    "title": "4  Fine-Grained Alignment Control",
    "section": "",
    "text": "t: top\n\nl: left\n\n\nb: bottom\n\nr: right",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#free_align",
    "href": "free.html#free_align",
    "title": "4  Fine-Grained Alignment Control",
    "section": "\n4.2 free_align()\n",
    "text": "4.2 free_align()\n\nBy default, align_plots() aligns plot panels so axes match. This can cause excessive spacing when plots differ in axis label lengths. free_align() disables panel alignment on specified sides.\n\n# Problem: When combined, it looks bad due to forced alignment\nalign_plots(p_simple, p_wide_labels, ncol = 1L)\n\n\n\n\n\n\n\n\n# Solution: Use free_align to prevent panel alignment\nalign_plots(p_simple, free_align(p_wide_labels), ncol = 1L)\n\n\n\n\n\n\n\n\n# Partial solution: Free only the left side to maintain right alignment\nalign_plots(p_simple, free_align(p_wide_labels, axes = \"l\"), ncol = 1L)",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#free_space---space-constraint-removal",
    "href": "free.html#free_space---space-constraint-removal",
    "title": "4  Fine-Grained Alignment Control",
    "section": "\n4.3 free_space() - Space Constraint Removal",
    "text": "4.3 free_space() - Space Constraint Removal\nfree_space() removes the allocated space for plot elements when aligning. This is particularly useful for removing padding introduced by long axis labels or titles.\n\nalign_plots(p_simple, free_space(p_wide_labels, spaces = \"l\"), ncol = 1L)\n\n\n\n\n\n\n\nWhile it may not appear impactful on its own, free_space() is often essential when used together with free_border().",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#free_border",
    "href": "free.html#free_border",
    "title": "4  Fine-Grained Alignment Control",
    "section": "\n4.4 free_border()\n",
    "text": "4.4 free_border()\n\nfree_border() attaches borders (e.g., axis titles, tick marks) directly to the plot panel. This keeps them visually close to the panel during alignment.\n\nalign_plots(free_border(p_simple, borders = \"l\"), p_wide_labels, ncol = 1L)\n\n\n\n\n\n\n\nHowever, free_border() does not remove the space these components occupy. This means that, although the border (e.g., axis title) follows the plot panel more tightly in p_simple, the space reserved for it still exists. During alignment, this space is added to p_wide_labels, potentially adding unnecessary spaces.\nTo fully eliminate the size contribution of the border, we often combine free_border() with free_space():\n\nalign_plots(\n    free_space(free_border(p_simple, borders = \"l\"), spaces = \"l\"),\n    p_wide_labels,\n    ncol = 1L\n)\n\n\n\n\n\n\n\nThis removes the reserved size on the left side (spaces = “l”), ensuring clean, panel-based alignment without extra padding.",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#free_lab",
    "href": "free.html#free_lab",
    "title": "4  Fine-Grained Alignment Control",
    "section": "\n4.5 free_lab()\n",
    "text": "4.5 free_lab()\n\nfree_lab() is similar to free_border(), but only attaches axis titles and tick labels, not full borders. It’s mainly included for completeness; in most cases, combining free_border() and free_space() is sufficient.",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#free_vp",
    "href": "free.html#free_vp",
    "title": "4  Fine-Grained Alignment Control",
    "section": "\n4.6 free_vp()\n",
    "text": "4.6 free_vp()\n\nThe free_vp() function allows you to customize the grid viewport when aligning plots, giving you precise control over plot positioning and sizing. This is useful for precisely placing plots when alignment alone is insufficient.\n\np1 &lt;- ggplot(mtcars) +\n    geom_point(aes(mpg, disp))\np2 &lt;- ggplot(mtcars) +\n    geom_boxplot(aes(gear, disp, group = gear))\n\n\n\n\n# Blank line at the beginning to keep height consistent\n\n\nalign_plots(p1, p2, ncol = 2L)\n\n\n\n\n\n\n\n\n\n\nalign_plots(p1, \n    free_vp(p2, height = unit(0.8, \"npc\"), just = \"bottom\", y = 0), \n    ncol = 2L\n)",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "free.html#free_guide",
    "href": "free.html#free_guide",
    "title": "4  Fine-Grained Alignment Control",
    "section": "\n4.7 free_guide()\n",
    "text": "4.7 free_guide()\n\nThe free_guide() function allows you to override the guides argument for a single plot.\n\np_right &lt;- ggplot(mtcars) +\n    geom_point(aes(hp, wt, colour = mpg)) +\n    patch_titles(\"right\") +\n    labs(color = \"right\")\np_top &lt;- p_right +\n    patch_titles(\"top\") +\n    scale_color_continuous(\n        name = \"top\",\n        guide = guide_colorbar(position = \"top\")\n    )\np_left &lt;- p_right +\n    patch_titles(\"left\") +\n    scale_color_continuous(\n        name = \"left\",\n        guide = guide_colorbar(position = \"left\")\n    )\np_bottom &lt;- p_right +\n    patch_titles(\"bottom\") +\n    scale_color_continuous(\n        name = \"bottom\",\n        guide = guide_colorbar(position = \"bottom\")\n    )\nalign_plots(\n    free_guide(p_right, NULL),\n    free_guide(p_bottom, NULL),\n    free_guide(p_top, NULL),\n    free_guide(p_left, NULL),\n    guides = \"tlbr\"\n)\n\n\n\n\n\n\n\nYou can also specify which guide positions to be collected for individual plots.\n\nalign_plots(\n    free_guide(p_right, \"r\"),\n    free_guide(p_bottom, \"b\"),\n    free_guide(p_top, \"t\"),\n    free_guide(p_left, \"l\")\n)",
    "crumbs": [
      "Data-free composition",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Fine-Grained Alignment Control</span>"
    ]
  },
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "5  Overview",
    "section": "",
    "text": "5.1 Layout System\nggalign simplifies data-aware alignment in ggplot2, handling common tasks such as sorting, grouping, or clustering observations before composition. It introduces the concept of observation alignment, which ensures that identical data points maintain consistent positions across multiple interconnected plots.\nAt the heart of ggalign data-aware composition is an object-oriented Layout system that integrates seamlessly with ggplot2. It provides three core layout types:\nEach layout supports both discrete (e.g., categories) and continuous (e.g., numerical) data, and includes specialized alignment functions:\nFor StackLayout:\nFor QuadLayout:\nFor CircleLayout:",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "overview.html#layout-system",
    "href": "overview.html#layout-system",
    "title": "5  Overview",
    "section": "",
    "text": "StackLayout: Stacks plots horizontally or vertically.\nQuadLayout: Arranges plots in four quadrants (top, left, bottom, right) around a central plot.\nCircleLayout: Positions plots in a circular pattern.\n\n\n\n\nstack_discrete(): Align discrete variable along the stack.\nstack_continuous(): Align continuous variable along the stack.\nstack_layout(): A unified interface that handles both discrete and continuous data.\n\n\n\nquad_continuous()/ggside(): Align continuous variables in both horizontal and vertical directions.\nquad_discrete(): Align discrete variables in both horizontal and vertical directions.\nquad_layout(): A general function that adapts to both data types and directions.\n\n\n\ncircle_discrete(): Align discrete variable in the circle.\ncircle_continuous(): Align continuous variable in the circle.\ncircle_layout(): A unified interface for both cases.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "overview.html#supporting-systems",
    "href": "overview.html#supporting-systems",
    "title": "5  Overview",
    "section": "5.2 Overview of Supporting Systems",
    "text": "5.2 Overview of Supporting Systems\nIn addition to the core Layout system, ggalign provides several helper systems that enhance data-aware composition by managing how observations are grouped, ordered, and supplemented with additional plot elements. These systems work together with layouts to create flexible and insightful multi-plot arrangements:\n\nLayout customization:\n\nalign_group(): Group observations into panel with a group variable.\nalign_kmeans(): Group observations into panel by kmeans.\nalign_order(): Reorder layout observations based on statistical weights or by manually specifying the observation index.\nalign_order2: Reorder observations using an arbitrary statistical function\nalign_hclust(): Reorder or group observations based on hierarchical clustering.\n\nPlot adding:\n\nalign_dendro(): Add a dendrogram to the plot, and reorder or group observations based on hierarchical clustering.\nggalign(): Initialize a ggplot object and align the axes.\nggmark(): Add a plot to annotate selected observations.\nggcross(): Initialize a ggplot object to connect two different layout crosswise\nggfree(): Initialize a ggplot object without aligning the axes.\n\n\n\n\n\nOverview of Data-Aware Composition",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "overview.html#sec-input-data",
    "href": "overview.html#sec-input-data",
    "title": "5  Overview",
    "section": "5.3 Input data",
    "text": "5.3 Input data\nBefore exploring data-aware compostion, it’s important to understand how axis alignment works in ggplot2.\n\nFor continuous axes, alignment is straightforward: simply ensure the axis limits are consistent across plots.\nFor discrete axes, alignment is more challenging. You must have the same set of unique values and maintain a consistent ordering across all plots. In ggplot2, this can be difficult when working with long-format data frames because the factor levels or ordering may differ.\n\nggalign addresses this challenge by using matrix inputs for layouts that align discrete axes (e.g., the *_discrete() functions). In this approach:\n\nEach row of the matrix represents a unique discrete value (called an “observation”).\nThe total number of rows defines the complete set of unique discrete values.\nReordering rows in the matrix controls the ordering of observations consistently across all linked plots.\n\nThis design is especially useful for layouts that align axes in both directions (horizontal and vertical), such as heatmap, since matrices can be easily transposed to switch row and column alignment.\nThe matrix is only used for positioning. Before rendering, ggalign will reorder the matrix rows based on the layout, and automatically converts it into a long-format data frame — the standard input for ggplot2.\nThe main difference between discrete and continuous variable alignment in ggalign lies in the input data:\n\nDiscrete variables require a matrix as input.\nContinuous variables require a data frame, just like in standard ggplot2.\n\nWhen a data frame is required, the input will be automatically converted using fortify_data_frame() if needed. When a matrix is required, the input will be automatically converted using fortify_matrix().\nBy default, fortify_data_frame() calls ggplot2::fortify() for conversion.\n\nNote: When applied to a matrix, fortify_data_frame() will convert it into a long-formatted data frame, which differs from the behavior of ggplot2::fortify().",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Overview</span>"
    ]
  },
  {
    "objectID": "stack-layout.html",
    "href": "stack-layout.html",
    "title": "6  Stack Layout",
    "section": "",
    "text": "6.1 Default data\nstack_layout() arranges plots either horizontally or vertically. Based on whether we want to align the discrete or continuous variables, there are two types of stack layouts:\nstack_layout() integrates the functionalities of stack_discrete() and stack_continuous() into a single interface. The first argument for these three functions is direction which should be a single string indicating the direction of the stack layout, either \"h\"(horizontal) or \"v\"(vertical).\nSeveral aliases are available for convenience:\nAs discussed in Section 5.3, when aligning discrete variables, we typically use a matrix. For continuous axes, we can still use the long-formatted data frame, which is the same as in ggplot2.\nset.seed(123)\nsmall_mat &lt;- matrix(rnorm(56), nrow = 7)\nrownames(small_mat) &lt;- paste0(\"row\", seq_len(nrow(small_mat)))\ncolnames(small_mat) &lt;- paste0(\"column\", seq_len(ncol(small_mat)))\nstack_discrete()/stack_continuous() will set up the layout, but no plot will be drawn until you add a plot element:\n1stack_discretev(small_mat)\n# the same for `stack_continuous()`\n\n\n1\n\ninitialize a vertical stack layout.\nThe data input when initializing the layout will be regarded as the default data, which can be inherited by all plots added to the layout.\nFor stack_discrete(), when default data is provided, the number of observations (nobs) is determined by the number of rows in the input matrix (i.e., NROW()). All plots added to the layout must use data with the same nobs. If you do not provide default data when initializing the layout, the first element you add—if it includes data—will determine the layout’s nobs.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stack Layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#default-data",
    "href": "stack-layout.html#default-data",
    "title": "6  Stack Layout",
    "section": "",
    "text": "For stack_continuous(), a data frame is required, and the input will be automatically converted using fortify_data_frame() if needed.\nFor stack_discrete(), a matrix is required, and the input will be automatically converted using fortify_matrix() if needed.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stack Layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#how-alignment-works",
    "href": "stack-layout.html#how-alignment-works",
    "title": "6  Stack Layout",
    "section": "6.2 How alignment works?",
    "text": "6.2 How alignment works?\n\n6.2.1 Discrete variables\nWithout any plots, it’s difficult to see how each layout system works in practice. Here, we introduce the most common plot adding function-ggalign(). This function plays a role similar to ggplot2::ggplot() function-it initialize a ggplot object-but is designed specifically for use within the the Layout system of Data-Aware Composition.\nWhen ggalign() is added to the layout, it inherits the layout data and sets itself as the active plot. This means any subsequent + operations will apply to that plot. You can add standard ggplot2 components like geoms, stats, scales, etc.\nWhen aligning discrete variables, the underlying data passed to ggplot through ggalign() will include the following columns (more details will be introduced in Section 9.1):\n\n.x/.y and .discrete_x/.discrete_y: an integer index of x/y coordinates and a factor of the data labels (only applicable when names/rownames exists).\n.names and .index: A character names (only applicable when names/rownames exists) and an integer of index of the original data.\n\nFor horizontal stack, the y-axis is aligned-the rows correspond to the y-axis.\nFor vertical stack, the x-axis is aligned-the rows correspond to the x-axis.\n\nYou must use .x/.y, or .discrete_x/.discrete_y as the x/y aesthetic mapping in order to enable axis alignment.\n\nWhen rendering, the input data is matched to the layout data by row index.\nAs mentioned in Section 5.3, if the input is a matrix, it will be automatically converted into a long-formatted data frame (the meanings of the resulting columns match their names; see ?fortify_data_frame.matrix for details):\n\nhead(fortify_data_frame(small_mat))\n#&gt;   .row_index .column_index       value .row_names .column_names\n#&gt; 1          1             1 -0.56047565       row1       column1\n#&gt; 2          2             1 -0.23017749       row2       column1\n#&gt; 3          3             1  1.55870831       row3       column1\n#&gt; 4          4             1  0.07050839       row4       column1\n#&gt; 5          5             1  0.12928774       row5       column1\n#&gt; 6          6             1  1.71506499       row6       column1\n\nNote the first argument of ggalign() is the data, so you must explicitly name the mapping argument.\n\nstack_discretev(small_mat) +\n    ggalign(mapping = aes(.x, value, fill = .discrete_x)) +\n    geom_boxplot() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\nBy default, axis text on the aligned axis (for vertical stack, x-axis) is removed to prevent duplicate labels. You can re-enable it using theme().\nOne major benefit of this system is that it supports algorithmic ordering of observations (note: rows are considered as observations, Section 9.1) and grouping observations into panels.\nI’ll now introduce the most common algorithm — hierarchical clustering, which can also generate dendrograms: align_dendro() (more details will be introduced in Section 9.4). When you add align_dendro(), it can inherit the layout data, computes the dendrogram, and sets the global row ordering of the layout. It also creates a new ggplot object to draw the dendrogram.\n\nstack_discretev(small_mat) +\n    align_dendro() +\n    ggalign(mapping = aes(.x, value, fill = .discrete_x)) +\n    geom_boxplot() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\n\n\n6.2.2 Continuous variables\nThe main strength of ggalign is the alignment of discrete variables; continuous variable support is provided mainly for completeness. Here we show basic usage for aligning continuous variables.\n\nstack_continuousv(mtcars) +\n    ggalign(mapping = aes(mpg, disp, color = factor(cyl))) +\n    geom_point() +\n    theme(axis.text.x = element_text()) +\n    ggalign(mapping = aes(mpg, hp, color = factor(cyl))) +\n    geom_point() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\nSimilar to stack_discretev(), by default, axis text on the aligned axis (for vertical stacks, the x-axis) is removed to prevent duplicate labels. You can explicitly control visibility using theme().\nIn this example, no special alignment occurs because both ggalign() calls inherit the same default data, resulting in identical axis limits.\nTo demonstrate differences, here we filter the data to make the plot x-axis limits different. By default, stack_continuous() does not set axis limits:\n\nstack_continuousv(mtcars) +\n    ggalign(mapping = aes(mpg, disp, color = factor(cyl))) +\n    geom_point() +\n    theme(axis.text.x = element_text()) +\n    ggalign(\n        ~ dplyr::filter(.x, mpg &lt; 20), \n        mapping = aes(mpg, hp, color = factor(cyl))\n    ) +\n    geom_point() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\nTo align the x-axis limits, you must manually set them using the limits argument, which accepts a continuous_limits() object. continuous_limits() takes a numeric vector of length 2, defining the axis limits for each panel along the aligned axis.\nThe data argument in ggalign can be a purrr-style function that transforms the default data and returns new data.\n\nstack_continuousv(mtcars, limits = continuous_limits(c(NA, 20))) +\n    ggalign(mapping = aes(mpg, disp, color = factor(cyl))) +\n    geom_point() +\n    theme(axis.text.x = element_text()) +\n    ggalign(~ dplyr::filter(.x, mpg &lt; 20), mapping = aes(mpg, hp, color = factor(cyl))) +\n    geom_point() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\nAside from differences in input data, most operations in stack_discrete() also apply to stack_continuous(). The key distinction lies in how alignment is handled, as discussed in Section 5.3: stack_continuous() does not support the Layout customization system used for discrete variables.\nBecause of this, we will focus on stack_discrete(). Nearly all techniques shown can also be used with stack_continuous(), except for Layout customization.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stack Layout</span>"
    ]
  },
  {
    "objectID": "stack-layout.html#sec-stack-layout-plot-size",
    "href": "stack-layout.html#sec-stack-layout-plot-size",
    "title": "6  Stack Layout",
    "section": "6.3 Plot Size",
    "text": "6.3 Plot Size\nAll plot adding functions have a size argument to control the relative width (for horizontal stack layout) or height (for vertical stack layout) of the plot’s panel area.\n\nstack_discretev(small_mat) +\n    align_dendro(size = 1) +\n    ggalign(mapping = aes(.x, value, fill = .discrete_x), size = 2) +\n    geom_boxplot() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\nAlternatively, you can define an absolute size by using a unit() object:\n\nstack_discretev(small_mat) +\n    align_dendro(size = unit(1, \"cm\")) +\n    ggalign(mapping = aes(.x, value, fill = .discrete_x), size = 2) +\n    geom_boxplot() +\n    theme(axis.text.x = element_text())\n\n\n\n\n\n\n\n\nIn the next chapter, we will dive into the HeatmapLayout, which can take the StackLayout as input. Heatmap layouts offer additional features for aligning observations in both directions. Let’s move ahead and explore how heatmaps can be seamlessly integrated into your layout workflows.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Stack Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html",
    "href": "heatmap-layout.html",
    "title": "7  Heatmap Layout",
    "section": "",
    "text": "7.1 Input Data\nThe heatmap_layout() function provides a powerful way to create customizable heatmaps using ggplot2. This chapter will guide you through its usage.\nheatmap_layout() is a specialized version of quad_discrete(), designed to align discrete variables both horizontally and vertically. We introduce heatmap_layout() directly, as it is more familiar to many users, especially those experienced with popular heatmap packages like pheatmap and ComplexHeatmap.\nheatmap_layout() simplifies the creation of heatmap plots by integrating essential elements for a standard heatmap layout, ensuring that the appropriate data mapping and visualization layers are automatically applied. ggheatmap() is an alias for heatmap_layout().\nAs mentioned in Section 5.3, we typically require a matrix for the Layout which need align discrete variables. Internally, fortify_matrix() will be used to process the data. You can provide a numeric or character vector, a data frame, or any other data type that can be converted into a matrix using as.matrix().\nggheatmap(small_mat)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-main-plot",
    "href": "heatmap-layout.html#sec-heatmap-layout-main-plot",
    "title": "7  Heatmap Layout",
    "section": "\n7.2 Main Plot (Heatmap Body)",
    "text": "7.2 Main Plot (Heatmap Body)\nThe ggheatmap()/quad_layout() functions arrange plots in the Quad-Side layout of the main plot. When the layout is initialized, a ggplot object is automatically created for the main plot.\nFor ggheatmap(), the matrix input will be converted into a long-format data frame when drawing. The data in the underlying ggplot object includes the following columns:\n\n.xpanel and .ypanel: the column and row panel\n.x and .y: the x and y coordinates\n.row_names and .column_names: A factor of the row and column names of the original matrix (only applicable when names exist).\n.row_index and .column_index: the row and column index of the original matrix.\nvalue: the actual matrix value.\n\nThe default mapping will use aes(.data$.x, .data$.y), but can be customized using mapping argument.\nBy default, the main plot is regarded as the active plot, meaning you can add ggplot2 elements directly to the main plot.\n\nggheatmap(small_mat) + \n    geom_point() + \n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nBy default, ggheatmap() adds a heatmap layer. If the matrix has more than 20,000 cells (nrow * ncol &gt; 20000), it uses geom_raster() for performance efficiency; for smaller matrices, geom_tile() is used. You can explicitly choose the layer by providing a single string (\"raster\" or \"tile\") in the filling argument.\n\nggheatmap(small_mat, filling = \"raster\")\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = \"tile\")\n\n\n\n\n\n\n\nNote, the filling layer will always use mapping of aes(.data$.x, .data$.y), if you want to customize filling, you can set filling = NULL, which will remove the filling layer and allow you to add custom filling geoms.\n\nggheatmap(small_mat, filling = NULL) +\n    geom_tile(aes(fill = value), color = \"black\", width = 0.9, height = 0.9)\n\n\n\n\n\n\n\nA heatmap pie charts can be easily drawn:\n\nset.seed(123)\nggheatmap(matrix(runif(360L), nrow = 20L), filling = NULL) +\n    geom_pie(aes(angle = value * 360, fill = value))\n\n\n\n\n\n\n\nFor more complex customizations of pie charts, you can try using ggforce::geom_arc_bar() instead.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#rasterization",
    "href": "heatmap-layout.html#rasterization",
    "title": "7  Heatmap Layout",
    "section": "\n7.3 Rasterization",
    "text": "7.3 Rasterization\nWhen working with large heatmaps, it’s often beneficial to rasterize the heatmap body layer. You can achieve this by using the raster_magick() function. The res argument controls the resolution of the raster image. By default, the res argument matches the resolution of the current device, but specifying a different value can help reduce the resolution of the rasterized heatmap body.\n\nggheatmap(small_mat, aes(.x, .y), filling = NULL) +\n    raster_magick(geom_tile(aes(fill = value)), res = 50)\n\n\n\n\n\n\n\nBy leveraging raster_magick(), you can also perform image post-processing using the magick package. This allows for custom image resizing with filters.\n\nggheatmap(small_mat, filling = NULL) +\n    # Use `magick::filter_types()` to check available `filter` arguments\n    raster_magick(geom_raster(aes(fill = value)),\n        magick = function(image) {\n            magick::image_resize(image,\n                # we resize to the 50% of width\n                geometry = \"50%x\", filter = \"Lanczos\"\n            )\n        }\n    )\n\n\n\n\n\n\n\nNote: When using magick::image_resize(), you should specify the geometry argument to resize the image. If only the filter is specified, it will only distort the image data (though subtle). For more information on image resizing, refer to ImageMagick’s resize documentation.\nYou can also rasterize all plots in the layout directly with raster_magick(). This method is defined for both ggheatmap()/quad_layout() and stack_layout() objects.\nAdditionally, You can use external packages like ggrastr or ggfx to rasterize the heatmap body.\n\nggheatmap(small_mat, filling = FALSE) +\n    ggrastr::rasterise(geom_tile(aes(fill = value)), dev = \"ragg\")\n\n\n\n\n\n\n\nLikewise, you can also rasterize all plots in the layout directly with ggrastr::rasterise() for both ggheatmap()/quad_layout() and stack_layout().\n\nggrastr::rasterise(ggheatmap(small_mat), dev = \"ragg\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nFurthermore, ggfx offers many image filters that can be applied to ggplot2 layers. See the package for the details.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "href": "heatmap-layout.html#sec-heatmap-layout-annotations",
    "title": "7  Heatmap Layout",
    "section": "\n7.4 Annotations",
    "text": "7.4 Annotations\nIn ggheatmap()/quad_layout(), annotations are handled by a stack_layout() object and can be positioned at the top, left, bottom, or right of the main plot (heatmap body). quad_layout() can align discrete or continuous variables either horizontally or vertically. Since the annotation handling is the same for both ggheatmap() and quad_layout(), we introduce the annotation functionality for both together.\nThe annotations will always follow the alignment of the ggheatmap()/quad_layout() in the current direction. For horizontal alignment of discrete variables, stack_discreteh() will be used for left and right annotations, while stack_continuoush() will be used for continuous variables. The same logic applies to vertical alignment—stack_discretev() or stack_continuousv() will be used for top and bottom annotations, depending on whether the variables being aligned are discrete or continuous.\nBy default, ggheatmap()/quad_layout() do not activate an annotation, You can use quad_anno() to activate an annotation, directing all subsequent additions to the specified annotation position. The quad_anno() function has the following aliases:\n\n\nanno_top: A special case of quad_anno() with position = \"top\".\n\nanno_left: A special case of quad_anno() with position = \"left\".\n\nanno_bottom: A special case of quad_anno() with position = \"bottom\".\n\nanno_right: A special case of quad_anno() with position = \"right\".\n\nWhen quad_anno() is added to a ggheatmap()/quad_layout(), it will try to create a new stack_layout(). For top and bottom annotations, stack_discretev() or stack_continuousv() will be used; for left and right annotations, stack_discreteh() or stack_continuoush() will be applied.\nAdditionally, quad_anno() will set the active context to the annotation. This means that subsequent additions will be directed to the annotation rather than the main plot. We use the term active context in contrast to active plot (as discussed in Chapter 6), since the annotation is a Layout object but not a single plot.\n\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nBy default, the annotation stack_layout() attempts to inherit data from ggheatmap() or quad_layout(). When aligning discrete variables vertically, the data provided to ggheatmap() or quad_layout() must be a matrix. In this case, column annotations must also be based on a matrix. Internally, the matrix from ggheatmap() or quad_layout() will be transposed for use in column annotations, since rows are always treated as observations and alignment is performed along matrix rows.\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can further customize the layout design or add new plots in the annotation stack, as described in Chapter 6.\n\nggheatmap(small_mat) +\n    # in the heatmap body, we set the axis text theme\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we set the active context to the right annotation\n    anno_right() +\n    # in the right annotation, we add a dendrogram\n    align_dendro(k = 3L) +\n    # in the dendrogram, we add a point layer\n    geom_point(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nIn this example:\n\n\nanno_right() initialize the right annotation stack, and change the active context to the right annotation of the heatmap.\n\nalign_dendro(k = 3L) adds a dendrogram to the annotation and sets itself as the active plot in the annotation stack.\n\ngeom_point(aes(color = branch)) is then added to this active plot within the annotation stack, here, it means the align_dendro() plot.\n\n\nNote: I’ll cover align_dendro() in more detail in a later chapter. For now, just know that when you specify the k argument, the resulting internal data will include a branch column representing cluster assignments.\n\nggheatmap() aligns discrete variable both horizontally and vertically, so it’s safe to always use quad_anno() directly, as all annotations require a matrix, and the layout data is also a matrix. However, for quad_layout(xlim = NULL) and quad_layout(ylim = NULL) (which I’ll discuss in more detail in a Chapter 11), which only align discrete variable in one direction, the data in the layout may not fit the data for the annotation.\n- `quad_layout(xlim = NULL)`: aligning discrete variable in horizontal\ndirection, for column annotations, we ll need a data frame for\n`stack_continuous()`.\n- `quad_layout(ylim = NULL)`: aligning discrete variable in vertical\ndirection, for row annotations, we ll need a data frame for\n`stack_continuous()`.\nIn both cases, quad_anno() won’t initialize the annotation by default, instead, you must provide the annotation manually.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "href": "heatmap-layout.html#sec-heatmap-layout-add-stack-layout",
    "title": "7  Heatmap Layout",
    "section": "\n7.5 Adding Stack Layout",
    "text": "7.5 Adding Stack Layout\nTo add a stack_layout() to the ggheatmap(), we must prevent the automatic creation of annotations by quad_anno() by setting initialize = FALSE.\n\nmy_stack &lt;- stack_discreteh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right(initialize = FALSE) +\n    my_stack\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nNote when aligning the discrete variable, you must ensure the number of observations is consistent in the direction. So for column annotations, you need transpose the data manually.\n\nmy_stack &lt;- stack_discretev(t(small_mat)) +\n    align_dendro(aes(color = branch), k = 3L)\nggheatmap(small_mat) +\n    anno_top(initialize = FALSE) +\n    my_stack\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_active",
    "href": "heatmap-layout.html#quad_active",
    "title": "7  Heatmap Layout",
    "section": "\n7.6 quad_active()\n",
    "text": "7.6 quad_active()\n\nWhen you want to resume adding layers (using the \"+\" operator) to the main heatmap body—after previously adding to an annotation—you need to remove the active context. You can do this using quad_active().\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    anno_top() +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_active() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#quad_switchhmanno",
    "href": "heatmap-layout.html#quad_switchhmanno",
    "title": "7  Heatmap Layout",
    "section": "\n7.7 quad_switch()/hmanno()\n",
    "text": "7.7 quad_switch()/hmanno()\n\nWe also provide quad_switch()/hmanno() (heatmap annotation) which integrates quad_active() and quad_anno() into one function for ease of use. Feel free to use any of these functions to streamline your annotation process.\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    quad_switch(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    quad_switch() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c() +\n    layout_title(\"quad_switch()\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    # we set the active context to the top annotation\n    hmanno(\"t\") +\n    # we split the observations into 3 groups by hierarchical clustering\n    align_dendro(k = 3L) +\n    # remove any active annotation\n    hmanno() +\n    # set fill color scale for the heatmap body\n    scale_fill_viridis_c()+\n    layout_title(\"hmanno()\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "heatmap-layout.html#plot-size",
    "href": "heatmap-layout.html#plot-size",
    "title": "7  Heatmap Layout",
    "section": "\n7.8 Plot Size",
    "text": "7.8 Plot Size\n\n7.8.1 Heatmap Body Size\nYou can specify the relative sizes of the heatmap body using the width and height arguments in the ggheatmap() function.\n\nggheatmap(small_mat, height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nAlternatively, the quad_active() function allows you to control the heatmap body sizes.\n\nggheatmap(small_mat) +\n    quad_active(height = 2) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n7.8.2 Annotation Stack Size\nThe quad_anno() function allows you to control the total annotation stack size. The size argument controls the relative width (for left and right annotations) or height (for top and bottom annotations) of the whole annotation stack.\nBy default, the annotation stack has the same relative size as the heatmap body (height/width). However, if your annotations contain multiple plots, you may need to increase this value to prevent overcrowding:\n\nggheatmap(small_mat) +\n    anno_top(size = 1) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can also specify it as an absolute size using unit():\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote that the size of an individual plot (Section 6.3) does not affect the total annotation stack size. You must adjust the annotation size using the method described above.\n\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(size = unit(30, \"mm\")) +\n    layout_title(\"plot size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    layout_title(\"annotation size\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nIn this chapter, we explored the fundamentals of heatmap layout. These features provide a solid foundation for organizing and visualizing matrix-based data in a structured and interpretable way. As your visualization tasks become more complex—such as requiring precise control over observation ordering or grouping—the need for flexible layout customization becomes increasingly important.\nIn the next chapter, we’ll introduce layout customization tools that give you full control over the structure and arrangement of your heatmap and annotation components.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Heatmap Layout</span>"
    ]
  },
  {
    "objectID": "layout-customize.html",
    "href": "layout-customize.html",
    "title": "8  Layout customization",
    "section": "",
    "text": "8.1 align_group()\nFor layouts that can align observations (discrete variables), the package provides a suite of align_* functions designed to give you precise control over the observations. These functions allow you to reorder observations or partition them into multiple groups.\nCurrently, there are four key align_* functions available for layout customization:\nNote that these functions do not add plot areas and set the active context, meaning you cannot incorporate ggplot2 elements directly into these objects. You can inspect the behavior of any align_* function by printing it.\nThe align_group() function allows you to split the observations into groups.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))\n#&gt; → heatmap built with `geom_tile()`\nNote that all align_* functions which split observations into groups must not break the previous established groups. This means the new groups must nest in the old groups, usually they cannot be used if groups already exist.\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE)) +\n    align_group(sample(letters[1:5], ncol(small_mat), replace = TRUE))\n#&gt; Error in `setup_domain()`:\n#&gt; ! `align_group()` disrupt the previously established panel groups of the\n#&gt;   top annotation `stack_discrete()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Layout customization</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_kmeans",
    "href": "layout-customize.html#align_kmeans",
    "title": "8  Layout customization",
    "section": "\n8.2 align_kmeans()\n",
    "text": "8.2 align_kmeans()\n\nThe align_kmeans() function split the observations into groups based on k-means clustering.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Layout customization</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_order",
    "href": "layout-customize.html#align_order",
    "title": "8  Layout customization",
    "section": "\n8.3 align_order()\n",
    "text": "8.3 align_order()\n\nThe align_order() function reorder the observations based on the summary weights.\nIn this example, we order the rows based on their means. By default, the ordering is in ascending order according to the summary weights. You can reverse the order by setting reverse = TRUE.\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans) +\n    layout_title(title = \"reverse = FALSE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rowMeans, reverse = TRUE) +\n    layout_title(title = \"reverse = TRUE\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nAdditionally, you can provide the ordering integer index or character index directly:\n\nset.seed(1234)\nmy_order &lt;- sample(nrow(small_mat))\nprint(rownames(small_mat)[my_order])\n#&gt; [1] \"row4\" \"row2\" \"row5\" \"row7\" \"row3\" \"row1\" \"row6\"\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(my_order)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order(rownames(small_mat)[my_order])\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nSome align_* functions also accept a data argument. It’s important to note that all align_* functions treat rows as the observations. This means NROW(data) must match the number of observations along the axis used for alignment. The data argument can also accept a function (supporting purrr-like lambda syntax), which will be applied to the layout matrix.\nAs mentioned in Section 7.4, for top and bottom annotations, the data matrix of quad_layout()/ggheatmap() is transposed to create the annotation stack_layout(). Therefore, you can use rowMeans() to calculate the mean value across all columns in the heatmap body matrix.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nSome align_* functions that reorder observations include an argument called strict. This argument is especially useful when previous groups have already been established. If previous groups have been created and strict = FALSE, the function will reorder the observations within each group.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(sample(letters[1:4], ncol(small_mat), replace = TRUE))+\n    align_order(rowMeans, strict = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nNote that we always prevent reordering the observations into two different orderings. If you want to apply two different orderings, you should use cross_layout() instead, which I’ll introduce in a later chapter:\n\nset.seed(1234)\nanother_order &lt;- sample(ncol(small_mat))\nggheatmap(small_mat) +\n    anno_top() +\n    align_order(rowMeans) +\n    align_order(another_order)\n#&gt; Error in `setup_domain()`:\n#&gt; ! `align_order()` disrupt the previously established ordering index of\n#&gt;   the top annotation `stack_discrete()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Layout customization</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#sec-align_hclust",
    "href": "layout-customize.html#sec-align_hclust",
    "title": "8  Layout customization",
    "section": "\n8.4 align_hclust()\n",
    "text": "8.4 align_hclust()\n\nThe align_hclust() function is designed to reorder observations and group them based on hierarchical clustering. Unlike align_dendro(), align_hclust() does not add a dendrogram tree to the plot. All the arguments intruduced here can also be used by align_dendro().\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nHierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. You can use the distance and method argument to control the builind process.\nThere are two ways to specify distance metric for clustering:\n\nspecify distance as a pre-defined option. The valid values are the supported methods in dist() function and coorelation coefficient \"pearson\", \"spearman\" and \"kendall\". The correlation distance is defined as 1 - cor(x, y, method = distance).\na self-defined function which calculates distance from a matrix.\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = \"pearson\") +\n    layout_title(\"pre-defined distance method (1 - pearson)\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(distance = function(m) dist(m)) +\n    layout_title(\"a function that calculates distance matrix\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nMethod to perform hierarchical clustering can be specified by method. Possible methods are those supported in hclust() function. And you can also provide a self-defined function, which accepts the distance object and return a hclust object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(method = \"ward.D2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can specify k or h to split observations into groups, which work similarly to cutree():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_hclust(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can reorder the dendrogram based on the mean values of the observations by setting reorder_dendrogram = TRUE.\n\nh1 &lt;- ggheatmap(small_mat) +\n    ggtitle(\"reorder_dendrogram = TRUE\") +\n    anno_top() +\n    align_hclust(k = 3, reorder_dendrogram = TRUE)\nh2 &lt;- ggheatmap(small_mat) +\n    ggtitle(\"reorder_dendrogram = FALSE\") +\n    anno_top() +\n    align_hclust(k = 3)\nalign_plots(h1, h2)\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nIn this example, we use align_plots() to arrange the layouts, which functions similarly to cowplot::align_plots() and patchwork::wrap_plots(). However, unlike those, align_plots() can be directly used with quad_layout() and stack_layout(), ensuring proper alignment by plot panel. Additionally, align_plots() can align pheatmap and ComplexHeatmap objects, though they won’t align by panel area in the same way as ggplot2 plots.\nalign_hclust() can also perform clustering between groups, meaning it can be used even if there are existing groups present in the layout, in this way, you cannot specify k or h:\n\nset.seed(3L)\ncolumn_groups &lt;- sample(letters[1:3], ncol(small_mat), replace = TRUE)\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can reorder the groups by setting reorder_group = TRUE, which reorders the hierarchical clusters based on the group tree:\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(reorder_group = TRUE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nIf you specify k or h, this will always turn off sub-clustering. The same principle applies to align_hclust(), where new groups must be nested within the previously established groups.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_group(column_groups) +\n    align_hclust(k = 2L)\n#&gt; Error in `setup_domain()`:\n#&gt; ! `align_hclust()` disrupt the previously established panel groups of\n#&gt;   the top annotation `stack_discrete()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Layout customization</span>"
    ]
  },
  {
    "objectID": "layout-customize.html#align_order2",
    "href": "layout-customize.html#align_order2",
    "title": "8  Layout customization",
    "section": "\n8.5 align_order2()\n",
    "text": "8.5 align_order2()\n\nThe align_order2() function enables the reordering of observations based on a specified statistical function. This function accepts a data argument and computes a statistic that determines the new ordering of the observations. The resulting order is extracted using the order2() function.\nFoe example, you can also use hierarchical clustering to reorder the observations like this:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order2(hclust2)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nHere, hclust2() is a special function used by align_hclust() to calculate the distance matrix and perform hierarchical clustering.\nIn addition to hierarchical clustering, the align_order2() function can also handle objects from the seriation package. For example, you can use the seriate() function with a method like \"BEA_TSP\" to reorder the observations based on a specific seriation algorithm:\n\nggheatmap(small_mat) +\n    anno_left() +\n    align_order2(seriation::seriate, method = \"BEA_TSP\", data = abs)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThis approach gives you the flexibility to apply different statistical or algorithmic methods for reordering observations, which can be especially useful for exploring complex patterns in data.\n\nDevelopers can extend this functionality by implementing a custom order2() method for their object classes.\n\nWith the align_* functions in place, we’ve covered how to reorder and group observations within a layout. Now, having set the stage for proper observation alignment, we can move on to the next essential step: plot initialization. In the following chapter, we’ll dive deeper into how to set up your plots within the layout.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Layout customization</span>"
    ]
  },
  {
    "objectID": "initialize-plot.html",
    "href": "initialize-plot.html",
    "title": "9  Integrate Plots",
    "section": "",
    "text": "9.1 ggalign()\nThere are following primary functions for adding plots:\nAll these functions will set the active plot when added to the layout.\nggalign is the package name but it’s also a function in the package. ggalign() is similar to ggplot in that it initializes a ggplot data and mapping. ggalign() allowing you to provide data in various formats, including matrices, data frames, or simple vectors. By default, it will inherit from the layout. If a function, it will apply with the layout data.\nThe underlying plot data will be created using fortify_data_frame(), which, By default, calls ggplot2::fortify() to build the data frame. Additional methods have been added for atomic vector and matrix. For atomic vector, it will convert it to a data frame with following columns:\nWhen data is a matrix, it will automatically be transformed into a long-form data frame, where each row represents a unique combination of matrix indices and their corresponding values. The resulting data frame will contain the following columns:\nWhen alignning continuous variables, ggalign() will apply the limits set by the layout when drawing.\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = rowSums) +\n    geom_point(aes(y = value))\n#&gt; → heatmap built with `geom_tile()`\nWhen aligning discrete variables, ggalign() always applies a default mapping for the axis of the data index in the layout. Specifically, This mapping is aes(y = .data$.y) for horizontal stack (including left and right annotation) and aes(x = .data$.x) for vertical stack (including top and bottom annotation).\nThe following columns will be added to the data frame to align discrete variables:\nWhen aligning discrete variables, almost all functions that add plots will generate data containing two key columns:\nAdditionally, if names exist, the .names column will also be created.\nstack_continuous(\"v\", mtcars, limits = continuous_limits(c(2, 4))) +\n    ggalign(mapping = aes(wt, mpg)) +\n    geom_point() +\n    ggalign(mapping = aes(wt, mpg)) +\n    geom_point() +\n    theme(axis.text.x = element_text())\nWhen aligning discrete variables, ensure that the number of rows in the data matches the number of observations along the axis used for alignment:\nmy_df &lt;- mtcars[seq_len(ncol(small_mat)), ]\nggheatmap(small_mat) +\n    anno_top() +\n    ggalign(data = my_df) +\n    geom_point(aes(y = cyl))\n#&gt; → heatmap built with `geom_tile()`\nIf data = NULL, the data in the underlying ggplot object only contains following columns: .panel, .index, .names, .x/.y, .discrete_x/.discrete_y. You can use it to integrate additional elements, such as block annotation or customized panel title, into your layout.\nggheatmap(small_mat) +\n    anno_top(size = unit(1, \"cm\")) +\n    align_kmeans(centers = 3L) +\n    ggalign(data = NULL) +\n    geom_tile(aes(y = 1L, fill = .panel, color = .panel)) +\n    theme_no_axes(\"y\")\n#&gt; → heatmap built with `geom_tile()`\nThe function theme_no_axes() can be used to quickly remove axis text and titles from the plot.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Integrate Plots</span>"
    ]
  },
  {
    "objectID": "initialize-plot.html#sec-ggalign",
    "href": "initialize-plot.html#sec-ggalign",
    "title": "9  Integrate Plots",
    "section": "",
    "text": ".names: the names for the vector (only applicable if names exist).\n\nvalue: the actual value of the vector.\n\n\n\n\n.row_names and .row_index: the row names (only applicable when names exist) and an integer representing the row index of the original matrix.\n\n.column_names and .column_index: the column names (only applicable when names exist) and column index of the original matrix.\n\nvalue: the actual value.\n\n\n\n\n\n\n\n.panel: The panel for the aligned axis. Refers to the x-axis for vertical stack_layout() (including top and bottom annotations), and the y-axis for horizontal stack_layout() (including left and right annotations).\n\n.names ([vec_names()][vctrs::vec_names]) and .index ([vec_size()][vctrs::vec_size()]/[NROW()]): Character names (if available) and the integer index of the original data.\n\n.x/.y and .discrete_x/.discrete_y: Integer indices for x/y coordinates, and a factor of the data labels (only applicable when names exist).\n\n\nIt is recommended to use .x/.y, or .discrete_x/.discrete_y as the x/y mapping.\n\n\n\n\n.panel: used to create ggplot2 facets.\n\n.index: serves to match the data. It is useful for aligning observations or linking different data sources. You can use .index to merge data and create a new data frame, using method provided in Section 14.2.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Integrate Plots</span>"
    ]
  },
  {
    "objectID": "initialize-plot.html#ggfree",
    "href": "initialize-plot.html#ggfree",
    "title": "9  Integrate Plots",
    "section": "\n9.2 ggfree()\n",
    "text": "9.2 ggfree()\n\nThe ggfree() function allows you to incorporate a ggplot object into your layout. Unlike ggalign(), which aligns every axis value precisely, ggfree() focuses on layout integration without enforcing strict axis alignment.\nInternally, the function also uses fortify_data_frame() to transform the input into a data frame.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nSince ggfree() may use axes that are not aligned with the primary plot’s axes, the axis titles will not be removed automatically. If you want to remove the axis titles, you must do so manually.\nAlternatively, you can directly input the ggplot object.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(ggplot(mtcars, aes(wt, mpg))) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can also add the ggplot object directly without using ggfree(). However, doing so will limit control over the plot (like plot area size, and active components):\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggplot(mtcars, aes(wt, mpg)) +\n    geom_point()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n9.2.1 Cross panel sumamry\nWhen used in quad_layout()/ggheatmap(), if the data is inherited from the quad_layout() and the other direction aligns discrete variables, following columns will be added:\n\n\n.extra_panel: Provides the panel information for the column (left or right annotation) or row (top or bottom annotation).\n\n.extra_index: The index information for the column (left or right annotation) or row (top or bottom annotation).\n\nThis is useful if you want to create summary plot using another axis panel groups.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n\n    # in the right annotation\n    anno_right() +\n    align_kmeans(2) +\n\n    # in the top annotation\n    anno_top(size = 0.5) +\n    ggfree() +\n    geom_boxplot(aes(.extra_panel, value, fill = .extra_panel)) +\n    scale_fill_brewer(palette = \"Dark2\", name = \"row groups\") +\n    theme_no_axes(\"x\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThis approach replicates the functionality of ComplexHeatmap::anno_summary(), but is versatile enough to be used with any heatmap, not just single-column or single-row heatmaps.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Integrate Plots</span>"
    ]
  },
  {
    "objectID": "initialize-plot.html#ggwrap-and-inset",
    "href": "initialize-plot.html#ggwrap-and-inset",
    "title": "9  Integrate Plots",
    "section": "\n9.3 ggwrap() and inset()\n",
    "text": "9.3 ggwrap() and inset()\n\nThe ggwrap() function allows you to wrap objects that can be converted into a grob, turning them into a ggplot for plotting. Further you can still add ggplot elements like title, subtitle, tag, caption, and geoms using the same approach as with normal ggplots (using ggtitle(), labs(), geom_*()) as well as styling using theme(). This enables you to pass these wrapped objects into ggfree().\n\nlibrary(grid)\nggheatmap(small_mat) +\n    anno_top() +\n    # `ggwrap()` will create a `ggplot` object, we use `ggfree` to add it into the layout\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can also integrate base plots, pheatmap, ComplexHeatmap, e.g.\nAdditionally, you can add any graphics as a inset to a ggplot using the inset() function. Like ggwrap(), inset() can accept any object that can be converted to a grob.\n\nggheatmap(small_mat) +\n    anno_top() +\n    ggfree(data = ggwrap(rectGrob(gp = gpar(fill = \"goldenrod\")), align = \"full\")) +\n    # we can then add any inset grobs (the same as ggwrap, it can take any objects\n    # which can be converted to a `grob`)\n    inset(rectGrob(gp = gpar(fill = \"steelblue\")), align = \"panel\") +\n    inset(textGrob(\"Here are some text\", gp = gpar(color = \"black\")),\n        align = \"panel\"\n    )\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Integrate Plots</span>"
    ]
  },
  {
    "objectID": "initialize-plot.html#sec-align-dendro",
    "href": "initialize-plot.html#sec-align-dendro",
    "title": "9  Integrate Plots",
    "section": "\n9.4 align_dendro()\n",
    "text": "9.4 align_dendro()\n\nalign_dendro() is an extension of align_hclust() that adds a dendrogram to the layout. All functions of align_hclust() introduced in Section 8.4 can be used with align_dendro(). Here, we focus on the plot-related function.\nalign_dendro() will initialize a ggplot object, the data underlying the ggplot object contains the dendrogram node data with dendrogram edge data attached in a special attribute.\ndendrogram node and edge contains following columns:\n\n\n.panel: Tree branch groups, used to create ggplot2 facet.\n\n.names and .index: a character names (only applicable when names exists) and an integer index of the original data.\n\nlabel: node label text\n\nx and y: x-axis and y-axis coordinates for current node or the start node of the current edge.\n\nxend and yend: the x-axis and y-axis coordinates of the terminal node for current edge.\n\nbranch: which branch current node or edge is. You can use this column to color different groups.\n\nleaf: A logical value indicates whether current node is a leaf.\n\nBy default, plot_dendrogram is set to TRUE, meaning a geom_segment() layer will be added to draw the dendrogram with edge data. Note that this layer is always added to the first.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can choose between two dendrogram types: \"rectangle\" (default) and \"triangle\". However, if there are any groups in the stack, \"rectangle\" will be used.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(type = \"triangle\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can also manually add the dendrogram tree using the edge data by setting plot_dendrogram = FALSE. In this case, you can access the dendrogram edge data with ggalign_attr(). The edge data is stored in the edge field of ggalign_attr():\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(plot_dendrogram = FALSE) +\n    geom_segment(\n        aes(x = .data$x, y = .data$y, xend = .data$xend, yend = .data$yend),\n        data = function(x) ggalign_attr(x, \"edge\")\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nWhen there are multiple groups, a branch column will be available. This can be used to color the nodes or edges based on the group source.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    geom_point(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nalign_dendro() will draw dendrogram tree in each group when previous group exists.\n\nset.seed(1234)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nYou can merge the sub-tree by settting merge_dendrogram = TRUE.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(2) +\n    align_dendro(aes(color = branch), merge_dendrogram = TRUE)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Integrate Plots</span>"
    ]
  },
  {
    "objectID": "initialize-plot.html#plot-titles",
    "href": "initialize-plot.html#plot-titles",
    "title": "9  Integrate Plots",
    "section": "\n9.5 Plot Titles",
    "text": "9.5 Plot Titles\nggplot2 only allow add titles in the top or add caption in the bottom. we extends this capability, allowing you to place titles around any border of the plot using the patch_titles() function.\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe appearance and alignment of these patch titles can be customized using ggplot2::theme():\n\n\nplot.patch_title/plot.patch_title.*: Controls the text appearance of patch titles. By default, plot.patch_title inherit from plot.title, and settings for each border will inherit from plot.patch_title, with the exception of the angle property, which is not inherited.\n\nplot.patch_title.position/plot.patch_title.position.*: Determines the alignment of the patch titles. By default, plot.patch_title.position inherit from plot.title.position, and settings for each border will inherit from plot.patch_title. The value \"panel\" aligns the patch titles with the plot panels. Setting this to \"plot\" aligns the patch title with the entire plot (excluding margins and plot tags).\n\n\nggheatmap(small_mat) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3) +\n    patch_titles(\n        top = \"top patch title\",\n        left = \"left patch title\", \n        bottom = \"bottom patch title\",\n        right = \"right patch title\"\n    ) +\n    theme(\n        plot.patch_title.position = \"plot\",\n        plot.patch_title = element_text(hjust = 0)\n    )\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nNow that you’re familiar with the general principles of adding plots and aligning observations, it’s time to explore the two layout systems provided by the package: the circle layout and the quad layout. These layouts offer distinct structural approaches to organizing your plots, and each is suited to different visualization goals. Let’s dive into how they work and how to make the most of them.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Integrate Plots</span>"
    ]
  },
  {
    "objectID": "circle-layout.html",
    "href": "circle-layout.html",
    "title": "10  Circle Layout",
    "section": "",
    "text": "10.1 Radial\ncircle_layout() arranges plots in a circular, each plot will occupy one circle track. Based on whether we want to align the discrete or continuous variables, there are two types of circle layouts:\nthe core argument of circle_layout() is radial, which should be a coord_radial() object that defines the global parameters for coord_radial() across all plots in the layout. The parameters start, end, direction, and expand will be inherited and applied uniformly to all plots within the layout. The parameters theta and r.axis.inside will always be ignored and will be set to “x” and TRUE, respectively, for all plots.\ncircle_discrete(small_mat, radial = coord_radial(end = pi / 2, expand = FALSE)) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c()\nIn essence, you can think of circle_layout() as a radial version of stack_vertical(). When rendered, circle_layout() uses coord_radial() to arrange each plot along a circular track. The radial argument in circle_layout() controls the overall inner radius. Plots are added from the outermost to the innermost position.\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n    align_dendro() +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c()\nThe size of each plot within the circle can be adjusted using the size argument (Section 6.3). However, it’s important to note that circle_layout() only supports relative size adjustments, meaning all size values are interpreted relative to one another, even for unit objects. By default, all plots have a relative size of 1.\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n    align_dendro(size = 0.5) +\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c()\nAlthough circle_layout() does not currently support splitting observations into different facets, you can still indicate different groups visually. For instance, you can add a tile to represent each group. If you’re using a dendrogram, you can color the branches to indicate different groups.\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n\n    # add a dendrogram\n    align_dendro(aes(color = branch), k = 3L, size = 0.5) +\n    scale_color_brewer(palette = \"Dark2\") +\n\n    # add a heatmap\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n\n    # add a single tile for each group\n    ggalign(NULL, size = 0.1) +\n    geom_tile(aes(y = 1L, fill = .panel)) +\n    theme_no_axes(\"y\") +\n    scale_fill_brewer(palette = \"Dark2\", guide = \"none\")",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Circle Layout</span>"
    ]
  },
  {
    "objectID": "circle-layout.html#spacing",
    "href": "circle-layout.html#spacing",
    "title": "10  Circle Layout",
    "section": "\n10.2 Spacing",
    "text": "10.2 Spacing\nThe spacing between plot tracks in circle_layout() is controlled panel.spacing.r parameter. The panel.spacing.r parameter sets the spacing between the individual plot panels (tracks) within the circle layout. Increasing this value will add more space between the tracks. Specifically, the panel.spacing.r of the outer plot determines the spacing between it and the inner plot. By modifying this value, you can control the overall visual separation between tracks. Note, you should also remove the scale expansion if you remove all spaces.\n\ncircle_discrete(small_mat, radial = coord_radial(inner.radius = 0.1)) +\n\n    # add a dendrogram\n    align_dendro(aes(color = branch), k = 3L, size = 0.5) +\n    no_expansion(\"y\") +\n    scale_color_brewer(palette = \"Dark2\") +\n\n    # add a heatmap\n    ggalign() +\n    geom_tile(aes(y = .column_index, fill = value)) +\n    scale_fill_viridis_c() +\n    no_expansion(\"y\") +\n    theme(panel.spacing.r = unit(0, \"mm\")) +\n\n    # add a single tile for each group\n    ggalign(NULL, size = 0.1) +\n    geom_tile(aes(y = 1L, fill = .panel)) +\n    scale_fill_brewer(palette = \"Dark2\", guide = \"none\") +\n    no_expansion(\"y\") +\n    theme(panel.spacing.r = unit(0, \"mm\"))\n\n\n\n\n\n\n\nThe no_expansion() function is used to remove expansion around specific borders. It accepts a string with one or more of the following values: \"t\" (top), \"l\" (left), \"b\" (bottom), \"r\" (right), \"x\" (both left and right), and \"y\" (both bottom and top).",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Circle Layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html",
    "href": "quad-layout.html",
    "title": "11  Quad-side Layout",
    "section": "",
    "text": "11.1 Introduction\nquad_layout() arranges plots around the quad-sides of a main plot, aligning both horizontal and vertical axes, and can handle either discrete or continuous variables.\nDepending on whether you want to align discrete or continuous variables in the horizontal and vertical direction, there are four main types of quad_layout():",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Quad-side Layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#introduction",
    "href": "quad-layout.html#introduction",
    "title": "11  Quad-side Layout",
    "section": "",
    "text": "Alignment of Observations\nhorizontal\nvertical\nData Format\n\n\n\n\nquad_continuous()/ggside()\n\ncontinuous\ncontinuous\ndata frame\n\n\nquad_layout(xlim = ...)\ndiscrete\ncontinuous\nmatrix\n\n\nquad_layout(ylim = ...)\ncontinuous\ndiscrete\nmatrix\n\n\n\nquad_discrete()/ggheatmap()\n\ndiscrete\ndiscrete\nmatrix",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Quad-side Layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#annotations",
    "href": "quad-layout.html#annotations",
    "title": "11  Quad-side Layout",
    "section": "\n11.2 Annotations",
    "text": "11.2 Annotations\nAnnotation is typically handled using a stack_layout(). Depending on whether you want to align observations in the specified direction, different stack_layout() are compatible (Section 7.5). Below is a table outlining the compatibility of various layout types for annotations:\n\n\n\n\n\n\n\nAnnotations\nleft and right\ntop and bottom\n\n\n\n\nquad_continuous()/ggside()\n\nstack_continuous()\nstack_continuous()\n\n\nquad_layout(xlim = ...)\nstack_discrete()\nstack_continuous()\n\n\nquad_layout(ylim = ...)\nstack_continuous()\nstack_discrete()\n\n\n\nquad_discrete()/ggheatmap()\n\nstack_discrete()\nstack_discrete()",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Quad-side Layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_discrete",
    "href": "quad-layout.html#quad_discrete",
    "title": "11  Quad-side Layout",
    "section": "\n11.3 quad_discrete()\n",
    "text": "11.3 quad_discrete()\n\nquad_discrete() aligns discrete variables in both horizontal and vertical directions. It serves as the base version of ggheatmap()/heatmap_layout() and does not automatically add default layers or mappings.\nThe underlying ggplot data of the main plot is the same with ggheatmap()/heatmap_layout() (Section 7.2), it is recommended to use .y/.discrete_yas theymapping and use.x/.discrete_xas thex` mapping in the main plot.\n\nquad_discrete(small_mat, aes(.x, .y)) +\n    geom_tile(aes(fill = value)) +\n    scale_fill_viridis_c()",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Quad-side Layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#quad_continuous",
    "href": "quad-layout.html#quad_continuous",
    "title": "11  Quad-side Layout",
    "section": "\n11.4 quad_continuous()\n",
    "text": "11.4 quad_continuous()\n\nquad_continuous() align continuous variables and is functionally equivalent to the ggside package. For convenience, ggside() is provided as an alias for quad_continuous(). This layout is particularly useful for adding metadata or summary graphics along a continuous axis.\n\nggside(mpg, aes(displ, hwy, colour = class)) +\n    geom_point(size = 2) +\n    # initialize top annotation\n    anno_top(size = 0.3) +\n    # add a plot in the top annotation\n    ggalign() +\n    geom_density(aes(displ, y = after_stat(density), colour = class), position = \"stack\") +\n    # initialize right annotation\n    anno_right(size = 0.3) +\n    # add a plot in the right annotation\n    ggalign() +\n    geom_density(aes(x = after_stat(density), hwy, colour = class),\n        position = \"stack\"\n    ) +\n    quad_scope(theme_bw(), \"tri\")\n\n\n\n\n\n\n\n\nThe quad_scope() function controls the active adding context. The \"tri\" argument means adding to the top annotation, right annotation, and the main plot. More details will be introduced in the Chapter 13 chapter.\n\nggside() allows facetting for the main plot, which should also be applied to the annotations for proper alignment.\n\ni2 &lt;- iris\ni2$Species2 &lt;- rep(c(\"A\", \"B\"), 75)\nggside(i2, aes(Sepal.Width, Sepal.Length, color = Species)) +\n    geom_point(size = 2) +\n    facet_grid(Species ~ Species2) +\n    anno_top(size = 0.3) +\n    ggalign() +\n    geom_density(aes(Sepal.Width, y = after_stat(density), colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(cols = vars(Species2)) +\n    anno_right(size = 0.3) +\n    ggalign() +\n    geom_density(aes(x = after_stat(density), Sepal.Length, colour = Species),\n        position = \"stack\"\n    ) +\n    facet_grid(rows = vars(Species)) +\n    quad_scope(theme_bw(), \"tri\")",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Quad-side Layout</span>"
    ]
  },
  {
    "objectID": "quad-layout.html#sec-quad-layout-quad-layout",
    "href": "quad-layout.html#sec-quad-layout-quad-layout",
    "title": "11  Quad-side Layout",
    "section": "\n11.5 quad_layout()\n",
    "text": "11.5 quad_layout()\n\nThis function arranges plots around the quad-sides of a main plot, aligning both horizontal and vertical axes, and can handle either discrete or continuous variables.\n\nIf xlim is provided, a continuous variable will be required and aligned in the vertical direction. Otherwise, a discrete variable will be required and aligned.\nIf ylim is provided, a continuous variable will be required and aligned in the horizontal direction. Otherwise, a discrete variable will be required and aligned.\n\n\n\n\nquad_layout(small_mat, xlim = NULL) +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_layout(xlim = ...)\")\n\n\n\n\n\n\n\n\n\n\nquad_layout(small_mat, ylim = NULL) +\n    geom_boxplot(aes(.discrete_x, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_layout(ylim = ...)\")\n\n\n\n\n\n\n\n\n\nAs discussed in Section 7.4, quad_anno() will always attempt to initialize a stack_layout() with the same alignment as the current direction. For top and bottom annotations in quad_layout(xlim = ...), and left and right annotations in quad_layout(ylim = NULL), quad_anno() will not initialize the annotation due to inconsistent data types.\n\nquadh &lt;- quad_layout(small_mat, xlim = NULL) +\n    anno_top()\n#&gt; Warning: `data` in `quad_layout()` is a double matrix, but the top annotation stack need\n#&gt; a &lt;data.frame&gt;, won't initialize the top annotation stack\nquadv &lt;- quad_layout(small_mat, ylim = NULL) +\n    anno_left()\n#&gt; Warning: `data` in `quad_layout()` is a double matrix, but the left annotation stack\n#&gt; need a &lt;data.frame&gt;, won't initialize the left annotation stack\n\nManual adding of a stack_layout() is required in such cases, you can set initialize = FALSE to prevent the warning message.\n\nquadh &lt;- quad_layout(small_mat, xlim = NULL) +\n    anno_top(initialize = FALSE)\nquadv &lt;- quad_layout(small_mat, ylim = NULL) +\n    anno_left(initialize = FALSE)\n\n\n\n\nquadh +\n    stack_continuous(\"v\", mpg) +\n    # add a plot in the top annotation\n    ggalign(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\nquadv +\n    stack_continuous(\"h\", mpg) +\n    # add a plot in the left annotation\n    ggalign(mapping = aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class)) +\n    quad_active() +\n    geom_boxplot(aes(.discrete_x, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\nAlternatively, you can set initialize = TRUE, which will initialize the annotation stack layout with no data. In this case, you must provide data in each plot within the annotation.\n\n\n\nquad_layout(small_mat, xlim = NULL) +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_top(initialize = TRUE) +\n    ggalign(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignh()\")\n\n\n\n\n\n\n\n\n\n\nquad_layout(small_mat, ylim = NULL) +\n    geom_boxplot(aes(.discrete_x, value, fill = .column_names)) +\n    scale_fill_brewer(palette = \"Dark2\") +\n    anno_left(initialize = TRUE) +\n    ggalign(data = mpg, aes(displ, hwy, colour = class)) +\n    geom_point(aes(displ, hwy, colour = class))+\n    layout_title(\"quad_alignv()\")\n\n\n\n\n\n\n\n\n\nNow we have explored all the Layout defined in the package, there are something special for stack_layout() and quad_layout(), as you should already know quad_layout() can take stack_layout() as the input (Section 7.5), Similarly, stack_layout() can also accept a quad_layout() as input, which is particularly useful for arranging multiple quad_layout()/ggheatmap() objects together.\nIn the next chapter, we will explore even more advanced techniques for combining multiple quad_layout()s. These methods will provide you with the tools to manage more complex plot arrangements and make your visualizations even more flexible and powerful.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Quad-side Layout</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html",
    "href": "multiple-quad-layouts.html",
    "title": "12  Nested Layouts",
    "section": "",
    "text": "12.1 Add quad_layout() to stack_layout()\nBoth stack_layout() and quad_layout() support nesting: you can add a stack_layout() inside a quad_layout(), and vice versa.\nThe following table summarizes which quad_layout() types are compatible with each stack_layout() variant:\nAs long as the alignment mode is consistent across both stack_layout() and quad_layout(), you can directly add quad_layout().\nstack_discreteh(small_mat) +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\nWhen ggheatmap()/quad_layout() is added to a stack_layout(), it will also set the active context to itself, which means subsequent addition will be directed to ggheatmap()/quad_layout(). One exception is the ggheatmap()/quad_layout() itself, which cannot be added to another quad_layout(). In this case, they will be added directly to the stack_layout(), ignoring the active context.\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    scale_fill_viridis_c()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nThe data of ggheatmap()/quad_layout() can inherit from the parent stack_layout(), but the data format must match. Otherwise, you will need to manually provide the data.\nquad_continuousv_plot &lt;- quad_layout(small_mat, xlim = NULL) +\n    geom_boxplot(aes(value, .discrete_y, fill = .row_names)) +\n    scale_fill_brewer(palette = \"Dark2\")\n# Note: `stack_continuousv()` requires a data frame\n# but `quad_layout(xlim = NULL)` requires a matrix\nstack_continuousv() +\n    quad_continuousv_plot +\n    quad_continuousv_plot\nWhen adding ggheatmap()/quad_layout() to a vertical stack_layout(), the inherited matrix is automatically transposed. This ensures the columns of the nested plot align with the observations of the stack.\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap()\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\nstack_discrete() ensures that all plots aligned along the stack share the same ordering index or groups.\nYou can customize the layout either inside stack_discrete() or within nested quad_layout(). Use stack_active() to switch the active context back to the stack_layout() from a nested plot.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Nested Layouts</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#add-quad_layout-to-stack_layout",
    "href": "multiple-quad-layouts.html#add-quad_layout-to-stack_layout",
    "title": "12  Nested Layouts",
    "section": "",
    "text": "stack_discreteh()\nstack_discretev()\nstack_continuoush()\nstack_continuousv()\n\n\n\n\nquad_continuous()/ggside()\n\n❌\n❌\n✅\n✅\n\n\nquad_layout(xlim = ...)\n✅\n❌\n❌\n✅\n\n\nquad_layout(ylim = ...)\n❌\n✅\n✅\n❌\n\n\n\nquad_discrete()/ggheatmap()\n\n✅\n✅\n❌\n❌\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3)+\n    layout_title(\"dendrogram in ggheatmap()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nstack_discretev(small_mat) +\n    ggheatmap() +\n    ggheatmap() +\n    stack_active() +\n    align_dendro(aes(color = branch), k = 3, size = 0.2) +\n    scale_y_reverse() +\n    layout_title(\"dendrogram in stack_layout()\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Nested Layouts</span>"
    ]
  },
  {
    "objectID": "multiple-quad-layouts.html#control-sizes",
    "href": "multiple-quad-layouts.html#control-sizes",
    "title": "12  Nested Layouts",
    "section": "\n12.2 Control sizes",
    "text": "12.2 Control sizes\nA numeric or a unit object of length 3 should be provided in stack_discrete()/stack_continuous() when placing a quad_layout(). For vertical stack_layout(), this means quad_layout() with left or right annotations; for horizontal stack_layout(), this means quad_layout() with top or bottom annotations. The first size controls the relative width/height of the left or top annotation, the second controls the relative width/height of the main plot, and the third controls the relative width/height of the right or bottom annotation.\nBy default the three rows/columns will have equal sizes.\n\nstack_discretev(small_mat) +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nheat1 &lt;- ggheatmap(t(small_mat)) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\")\n\nstack_discretev(small_mat, sizes = c(1, 2, 1)) +\n    heat1 +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nIn these cases, specifying width/height within quad_active(), quad_layout(), or ggheatmap() will not affect the size, as the stack layout size settings take precedence:\n\nstack_discretev(small_mat) +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_left() +\n    align_dendro(aes(color = .panel), k = 3L) +\n    anno_right() +\n    ggalign(data = rowSums) +\n    geom_bar(aes(value, fill = .panel), orientation = \"y\", stat = \"identity\") +\n    ggheatmap(width = unit(2, \"null\")) + # not work\n    theme(axis.text.x = element_text(angle = -60, hjust = 0))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nNow that we have covered all the Layout usage in the package, we will build upon these concepts to explore more advanced strategies for integrating elements across multiple plots and annotations within a layout.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Nested Layouts</span>"
    ]
  },
  {
    "objectID": "operator.html",
    "href": "operator.html",
    "title": "13  Operators",
    "section": "",
    "text": "13.1 Addition Operator\nIn ggalign, operators are used to manage and manipulate plot elements within various layouts. These operators enable you to build complex visualizations by adding or modifying components across multiple plots in a layout. You are likely familiar with the addition operator (+); this section expands on its usage and introduces two additional operators: logical AND (&) and subtraction (-), explaining how to apply them in different contexts.\nThe + operator is straightforward and should be used as needed.\nIn stack_layout(), a nested layout will only occur if you pass a quad_layout() into stack_layout() (?sec-multiple-quad-layouts). If the active context in the stack_layout() is quad_layout(), this quad_layout() is treated as the active layout, and the + operator will add elements to it, following the same principles as in quad_layout(). Otherwise, the stack_layout() itself is treated as the active layout, and the + operator will add elements directly to this plot.\ncircle_layout() works similarly to stack_layout(), but it does not support nested layouts. Therefore, the active layout in circle_layout() will always be the circle_layout() itself.\nstack_alignh(small_mat) +\n    align_dendro() +\n    geom_point() +\n    ggheatmap() +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    anno_right() +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\nIn quad_layout(), four nested layouts are available for annotations: top, left, bottom, and right. If no active annotation is set, quad_layout() treat itself as the active layout. Since there is only one main plot in the quad_layout(), the main plot is always treated as the active plot in this context. Otherwise, the active annotation is treated as the active layout, and the + operator will add elements to it, following the same principles as in stack_layout().\nggheatmap(small_mat) +\n    scale_fill_viridis_c() +\n    anno_left(size = 0.2) +\n    align_dendro() +\n    anno_right(size = 0.2) +\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#addition-operator",
    "href": "operator.html#addition-operator",
    "title": "13  Operators",
    "section": "",
    "text": "+: adds elements to the active plot in the active layout.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#logical-and-operator",
    "href": "operator.html#logical-and-operator",
    "title": "13  Operators",
    "section": "\n13.2 Logical AND Operator",
    "text": "13.2 Logical AND Operator\n\n&: applies elements to all plots in the layout including plots in the nested layout.\n\nThe & operator works similarly to patchwork, applying an element across all plots in a layout. Since & has lower precedence than +, it’s generally best to use it at the end of an expression or you should wrap it in parentheses when needed.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    # Add a dendrogram in the left annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    # Add a dendrogram in the right annotation and split the dendrogram into 3 groups\n    align_dendro(aes(color = branch), k = 3L) &\n    # Set color scale for all plots\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#subtraction-operator",
    "href": "operator.html#subtraction-operator",
    "title": "13  Operators",
    "section": "\n13.3 Subtraction Operator",
    "text": "13.3 Subtraction Operator\nThe - operator is more powerful than the & operator, enabling flexible addition of elements to multiple plots, especially when working with Chapter 14. While its use might initially seem unintuitive, the reason behind this is that - shares the same precedence group as +, which allows it to seamlessly combine with +.\n\n13.3.1 quad_layout()\n\nFor ggheatmap()/quad_layout(), if the active context is the ggheatmap()/quad_layout() itself (no active annotation), the - operator behaves similarly to &. It applies the specified elements to all plots within the layout.\n\n# Initialize the heatmap\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_right(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Remove any active annotation\n    quad_active() -\n    # Set color scale for all plots, since the active layout is the `ggheatmap()`/`quad_layout()`\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nIf the active layout is an annotation stack, the - operator will only add the elements to all plots in the active annotation stack:\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the the color scales of all plots in the left annotation\n    scale_color_brewer(palette = \"Dark2\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n13.3.2 stack_layout()\n\nFor stack_layout(), if the active layout is the stack_layout() itself, - applies the elements to all plots in the layout except the nested ggheatmap()/quad_layout().\n\nstack_alignv(small_mat) +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") +\n    ggheatmap() +\n    # remove any active context\n    stack_active() +\n    align_dendro() +\n    ggtitle(\"I'm from the parent stack\") -\n    # Modify the the color scales of all plots in the stack layout except the heatmap layout\n    scale_color_brewer(palette = \"Dark2\") -\n    # set the background of all plots in the stack layout except the heatmap layout\n    theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nWhen the active layout is the nested ggheatmap()/quad_layout(), the - operator applies the elements to this nested layout, following the same principles as in the Section 13.3.1.\nWant apply elements for plots in both stack_layout() and the nested ggheatmap()/quad_layout() at the same time? refer to the following section.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "operator.html#quad_scope",
    "href": "operator.html#quad_scope",
    "title": "13  Operators",
    "section": "\n13.4 quad_scope()\n",
    "text": "13.4 quad_scope()\n\nThe quad_scope() function adjusts the context in which elements are applied in ggheatmap()/quad_layout(). It allows you to control how objects such as themes, scales, and other plot elements are applied to specific annotation stacks or the main plot, without changing the currently active context.\nThis function accepts two arguments:\n\n\nx: An object which can be added to the plot.\n\nposition: A string containing one or more of \"t\", \"l\", \"b\", \"r\", and \"i\" specifies the context for applying x.\n\n\n13.4.1 quad_layout()\n\nDefault Behavior by wrapping object with quad_scope():\n\nWhen ggheatmap()/quad_layout() has no active annotation stack, objects added via + or - operate normally without quad_scope().\nWhen the active annotation stack is set, quad_scope() ensures the applied object also modifies:\n\nThe active annotation stack.\nThe main plot.\n\n\n\nBy wrapping object with quad_scope(), the + operator will apply the object not only to the active plot in the annotation stack, but also to the main plot.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro() +\n    # apply the object not only to the active plot in the annotation stack, but\n    # also to the main plot\n    quad_scope(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nBy wrapping object with quad_scope(), the - operator will apply the object not only to the active annotation stack, but also to the main plot.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # Change the active layout to the left annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the theme of all plots in the bottom annotation in this way, and\n    # the main plot\n    quad_scope(theme(plot.background = element_rect(fill = \"red\")))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe position argument can be a string containing one or more of \"t\", \"l\", \"b\", \"r\", and \"i\", indicating which annotation stack should be used as the context or if it should be applied to the main plot.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots in the left and top annotation\n    quad_scope(theme(plot.background = element_rect(fill = \"red\")), \"tl\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nThe position argument can also be NULL, which behaves as if no annotation is active.\n\nggheatmap(small_mat) +\n    # initialize the left annotation\n    anno_left(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the top annotation\n    anno_top(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) +\n    # initialize the bottom annotation\n    anno_bottom(size = 0.2) +\n    align_dendro(aes(color = branch), k = 3L) -\n    # Modify the background of all plots\n    quad_scope(theme(plot.background = element_rect(fill = \"red\")), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n13.4.2 stack_layout()\n\nFor stack_layout(), if the active layout is the stack_layout() itself, - applies the elements to all plots in the layout and will apply it to the nested ggheatmap()/quad_layout() following the same principles as in quad_layout(). + won’t work.\nWhen the active layout is the nested ggheatmap()/quad_layout(), the -/+ operator applies the elements to this nested layout, following the same principles of the nested layout.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Operators</span>"
    ]
  },
  {
    "objectID": "schemes.html",
    "href": "schemes.html",
    "title": "14  Schemes",
    "section": "",
    "text": "14.1 scheme_theme()\nSchemes control the actions of plots within the layout and can be applied either globally to the layout or individually to specific plots.\nThe package currently provides three schemes, each prefixed with scheme_:\nThe scheme_theme() function extends theme() to set a default theme for plots, allowing you to input theme() elements directly or add the theme elements.\nTo set a scheme for a single plot, simply use the + operator:\n1ggheatmap(small_mat) +\n2    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n1\n\ninitialize a heatmap layout\n\n2\n\nset the default theme, change the plot background for the main plot\nYou can use a theme() object directly in scheme_theme().\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(fill = value), width = 0.9, height = 0.9) +\n    scheme_theme(theme_bw(), plot.background = element_rect(fill = \"red\"))\nNote that scheme_theme() serves as the default theme and will always be overridden by any theme() settings applied directly to the plot. The default theme (scheme_theme()) is applied first, followed by any specific theme() settings, even if theme() is added before scheme_theme().\nggheatmap(small_mat) +\n    # change the plot theme of the heatmap body\n    theme(plot.background = element_rect(fill = \"blue\")) +\n    # change the default theme of the heatmap body\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\nBy using the - operator with schemes, we apply the scheme directly to the active layout.\nggheatmap(small_mat) +\n    # Change the active layout to the top annotation\n    anno_top() +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # add a bar plot to the top annotation\n    ggalign(aes(.discrete_x, value, fill = factor(.names)), data = rowSums) +\n    geom_bar(stat = \"identity\") -\n    # Change the default theme of the top annotation\n    # All plots in the top annotation will inherit this default theme\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`\nUnlike individual ggplot2 elements, which will be added directly to each plot by - operator, layout-level schemes set by - operator are inherited by all plots in the layout when rendered. Any plot-specific schemes will override these layout-level schemes, regardless of the order in which they are added.\nggheatmap(small_mat) +\n    # Change the active layout to the top annotation\n    anno_top() +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # change the scheme_theme for the dendrogram plot\n    scheme_theme(plot.background = element_rect(fill = \"blue\")) +\n    # add a bar plot to the top annotation\n    ggalign(aes(.discrete_x, value, fill = factor(.names)), data = rowSums) +\n    geom_bar(stat = \"identity\") -\n    # Change the default theme of the top annotation\n    # All plots in the top annotation will inherit this default theme\n    # But the plot-specific options will override these\n    scheme_theme(plot.background = element_rect(fill = \"red\"))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Schemes</span>"
    ]
  },
  {
    "objectID": "schemes.html#sec-scheme-data",
    "href": "schemes.html#sec-scheme-data",
    "title": "14  Schemes",
    "section": "14.2 scheme_data()",
    "text": "14.2 scheme_data()\nggalign() requires the specific data format for its operations. If you need to transform or filter data for individual geoms, you can use the data argument within each geom. However, if you have multiple geoms and want a consistent transformation applied across all, you can utilize the scheme_data() function. This allows you to transform the default data for the entire plot.\nThe scheme_data() accepts a function that takes a data frame as input and returns a modified data frame. By default, scheme_data() will attempt to inherit from the parent layout if the data is inherited from it. However, there is one exception: align_dendro() will not inherit scheme_data() transformations by default.\n\nset.seed(1234L)\nggheatmap(small_mat) +\n    anno_top() +\n    align_kmeans(3L) +\n    # we add a bar plot\n    ggalign() +\n    # we subest the plot data\n    scheme_data(~ subset(.x, .panel == 1L)) +\n    geom_bar(aes(y = value, fill = .row_names), stat = \"identity\")\n#&gt; → heatmap built with `geom_tile()`\n#&gt; Warning in min(x): no non-missing arguments to min; returning Inf\n#&gt; Warning in max(x): no non-missing arguments to max; returning -Inf\n#&gt; Warning in min(d[d &gt; tolerance]): no non-missing arguments to min; returning\n#&gt; Inf\n#&gt; Warning in min(x): no non-missing arguments to min; returning Inf\n#&gt; Warning in max(x): no non-missing arguments to max; returning -Inf\n#&gt; Warning in min(d[d &gt; tolerance]): no non-missing arguments to min; returning\n#&gt; Inf",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Schemes</span>"
    ]
  },
  {
    "objectID": "schemes.html#sec-scheme-align",
    "href": "schemes.html#sec-scheme-align",
    "title": "14  Schemes",
    "section": "14.3 scheme_align()",
    "text": "14.3 scheme_align()\nThe scheme_align() function controls the align specifications for plots.\n\n14.3.1 guides\nBy default, ggheatmap() will collect all guide legends on the side from which they originate.\n\nheatmap_collect_all_guides &lt;- ggheatmap(small_mat, width = 2, height = 2L) +\n    # we set the legend to the left side\n    scale_fill_gradient2(\n        low = \"blue\", high = \"red\",\n        name = \"I'm from heatmap body\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    theme(axis.text.x = element_text(angle = -60, hjust = 0)) +\n    # we add a top annotation\n    anno_top() +\n    # in the top annotation, we add a dendrogram\n    align_dendro(aes(color = branch), k = 3L) +\n    # we set the legends of the dendrogram to the left side\n    scale_color_brewer(\n        name = \"I'm from top annotation\", palette = \"Dark2\",\n        guide = guide_legend(position = \"left\")\n    ) +\n    # we add a left annotation\n    anno_left() +\n    align_dendro(aes(color = branch), k = 3L) +\n    # we set the legends of the dendrogram to the top side\n    scale_color_brewer(\n        name = \"I'm from left annotation\", palette = \"Dark2\",\n        guide = guide_legend(position = \"top\", direction = \"vertical\")\n    ) &\n    # we remove all margins for all plots\n    theme(plot.margin = margin())\nheatmap_collect_all_guides\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nThe guides argument schemes which side of guide legends should be gathered. In the following example, we’ll collect the guide legends only on the top (t) sides:\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side\n    quad_scope(scheme_align(guides = \"t\"), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can also apply the scheme_align() function directly to specific plots:\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for the heatmap layout\n    # we only collect guides in the top side\n    quad_scope(scheme_align(guides = \"t\"), NULL) +\n    # `+` apply it to the active plot\n    # for the heatmap body, we collect guide in the left side\n    quad_scope(scheme_align(guides = \"l\"), NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNote: The legend on the left side of the heatmap body is collected and positioned on the left side at the layout level.\nIf you’re annoyed by the large space between the left annotation and the heatmap body, don’t worry! This issue will be addressed in Section 14.3.2.\nNow, Let’s dive deeper into the guide collection process.\nIn the last example, we set the guides argument for the heatmap body. But what happens when we set the guides for the dendrogram in the top annotation?\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side in the heatmap layout\n    quad_scope(scheme_align(guides = \"t\"), NULL) +\n    # `+` apply it to the active plot\n    # for the dendrogram in the top annotation, we collect guide in the left side\n    quad_scope(scheme_align(guides = \"l\"), \"t\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nNothing seems to have changed, right? This is because guide legends within annotation stacks are first collected by the annotation stack_layout() and only then passed to the top-level layout for further integration.\nBy default, the annotation stack inherits the guides arguments from the heatmap layout, followed by the inherited of individual plot in the annotation. So guides argument set at top-level (heatmap layout) will affect all guide collection behaviour.\nIn this example:\n\nThe legend on the left side of the dendrogram in the top annotation is collected first at the annotation level.\nSince the heatmap layout is not set to collect legends from the left side, it remains at the left side within the annotation stack.\nFor this specific case, the top annotation contains only one plot, so its annotation-level placement is identical to plot-level placement.\n\nTo override this, you can use the free_guides argument of the quad_anno()/anno_*() function. This differs from the guides argument in scheme_align(), which schemes the behavior for the plots in the layout. The free_guides argument specifies which guide legends from at the annotation stack layout level should be collected by the heatmap layout.\n\nheatmap_collect_all_guides -\n    # we set global `guides` argument for `the heatmap layout`\n    # we only collect guides in the top side in the heatmap layout\n    quad_scope(scheme_align(guides = \"t\"), NULL) +\n    # we also collect guides in the left side for the top annotation stack\n    # in the heatmap layout\n    anno_top(free_guides = \"l\") +\n    # `+` apply it to the active plot\n    # for the dendrogram in the top annotation, we collect guide in the left side\n    scheme_align(guides = \"l\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\nNote: The heatmap layout will only collect guide legends from the annotation stack if the stack layout collects its own guides first.\n\n\n\n14.3.2 free_spaces\nBy default, ggheatmap() will align all elements of the plot, which can sometimes lead to unwanted spacing. Consider the following example:\n\nggheatmap(small_mat) +\n    # add top annotation\n    anno_top(size = unit(30, \"mm\")) +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # here, we use long labels for visual example\n    scale_y_continuous(\n        expand = expansion(),\n        labels = ~ paste(\"very very long labels\", .x)\n    ) +\n    # add left annotation\n    anno_left(unit(20, \"mm\")) +\n    # add a dendrogram to the left annotation\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nIn this case, the left annotation stack is positioned far from the heatmap body due to the wide axis labels in the top annotation stack. This occurs because the top annotation stack is aligned with the heatmap body. To fix this, you can remove the left borders around the panel of the top annotation stack by setting free_spaces = \"l\".\n\nggheatmap(small_mat) +\n    # add top annotation\n    anno_top(size = unit(30, \"mm\")) -\n    # we remove the spaces of the left borders in the top annotation\n    scheme_align(free_spaces = \"l\") +\n    # add a dendrogram to the top annotation\n    align_dendro() +\n    # here, we use long labels for visual example\n    scale_y_continuous(\n        expand = expansion(),\n        labels = ~ paste(\"very very long labels\", .x)\n    ) +\n    # add left annotation\n    anno_left(unit(20, \"mm\")) +\n    # add a dendrogram to the left annotation\n    align_dendro()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nOne useful way to utilize free_spaces is to position the guide legends next to the annotations. (Note the guide legend from the bottom annotation):\n\nheatmap_collect_all_guides +\n    # reset the active context to the heatmap layout\n    quad_active() -\n    # we set global `guides` argument for the heatmap layout\n    # we only collect guides in the top side\n    scheme_align(guides = \"t\") +\n    # `+` apply it to the current active plot\n    # for the heatmap body, we collect guide in the left side\n    scheme_align(guides = \"l\") -\n    quad_scope(scheme_align(free_spaces = \"l\"), \"t\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nUsually you want to apply free_spaces with the whole layout, instead of individual plots.\nIn ggheatmap()/quad_layout(), the behavior of the free_spaces and free_labs arguments differs from guides arguments in scheme_align() when inheriting from the parent layout:\n\nFor top and bottom annotations, it inherits from the left (“l”) and right (“r”) axes.\nFor left and right annotations, it inherits from the top (“t”) and bottom (“b”) axes.\n\n\n\n14.3.3 free_labs\nBy default, we won’t align the axis titles.\n\nggheatmap(small_mat) +\n    ylab(\"Heatmap title\") +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    ylab(\"Annotation title\")\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nTo align axis titles, you can set free_labs = NULL. Alternatively, A single string containing one or more of axis positions (“t”, “l”, “b”, “r”) to indicate which axis titles should be free from alignment.\n\nggheatmap(small_mat) -\n    scheme_align(free_labs = NULL) +\n    ylab(\"Heatmap title\") +\n    anno_top(size = unit(30, \"mm\")) +\n    align_dendro() +\n    ylab(\"Annotation title\")\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Schemes</span>"
    ]
  },
  {
    "objectID": "annotate-observations.html",
    "href": "annotate-observations.html",
    "title": "15  Annotate Observations",
    "section": "",
    "text": "15.1 Links\nTo add an annotation plot for specific observations, we must first know how to select the observations to be linked.\nThe pair_links() function is used to define pairs of connected observations. In the formula, the left side (before the ~) represents hand1—the observations on the left (for a horizontal stack layout) or top (for a vertical stack layout). The right side (after the ~) represents hand2—the observations on the right (for horizontal stack) or bottom (for vertical stack).\nThese defined pairs will either be linked together, or each group in the pair will be linked separately within the same plot area.\nBoth sides of the formula can be specified using integer or character indices of the original data (before reordering).\npair_links(1:2 ~ c(\"c\", \"d\"), c(\"a\", \"b\") ~ 3:4)\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 2 pairs of link groups\n#&gt; \n#&gt;             hand1 ~ hand2      \n#&gt;   1:          1:2 ~ c(\"c\", \"d\")\n#&gt;   2:  c(\"a\", \"b\") ~ 3:4        \n#&gt; \n#&gt; A total of 4 link groups\nThe print method showed various informations:\nIf only the left-hand side of the formula exists, you can input it directly.\npair_links(1:2, c(\"a\", \"b\"))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 2 pairs of link groups\n#&gt; \n#&gt;             hand1 ~ hand2\n#&gt;   1:          1:2 ~      \n#&gt;   2:  c(\"a\", \"b\") ~      \n#&gt; \n#&gt; A total of 2 link groups\nTo specify links in the right only, you must use formula:\npair_links(~ 1:2, ~ c(\"a\", \"b\"))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 2 pairs of link groups\n#&gt; \n#&gt;       hand1 ~ hand2      \n#&gt;   1:        ~ 1:2        \n#&gt;   2:        ~ c(\"a\", \"b\")\n#&gt; \n#&gt; A total of 2 link groups\nFor integer indices, wrap them with I() to follow ordering from the layout.\npair_links(I(1:2))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 1 pair of link groups\n#&gt; \n#&gt;        hand1 ~ hand2\n#&gt;   1:  I(1:2) ~      \n#&gt; \n#&gt; A total of 1 link group\nYou can wrap the whole formula.\npair_links(I(1:2 ~ 3:4))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 1 pair of link groups\n#&gt; \n#&gt;        hand1 ~ hand2 \n#&gt;   1:  I(1:2) ~ I(3:4)\n#&gt; \n#&gt; A total of 2 link groups\nrange_link() function can be used to define a range of observations, which accepts two argument that specify the lower and upper bounds of the range. These bounds should be defined as a single integer or character.\npair_links(range_link(1, \"a\"))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 1 pair of link groups\n#&gt; \n#&gt;                    hand1 ~ hand2\n#&gt;   1:  range_link(1, \"a\") ~      \n#&gt; \n#&gt; A total of 1 link group\nIn this case, the left-hand is defined as the range between the 1st observation and the observation named \"a\".\nYou can also use waiver() to inherit values from the opposite group.\n1pair_links(range_link(1, \"a\") ~ waiver())\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 1 pair of link groups\n#&gt; \n#&gt;                    hand1 ~ hand2   \n#&gt;   1:  range_link(1, \"a\") ~ waiver()\n#&gt; \n#&gt; A total of 2 link groups\n\n\n1\n\ninherit values from the left hand\n1pair_links(waiver() ~ range_link(1, \"a\"))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 1 pair of link groups\n#&gt; \n#&gt;          hand1 ~ hand2             \n#&gt;   1:  waiver() ~ range_link(1, \"a\")\n#&gt; \n#&gt; A total of 2 link groups\n\n\n1\n\ninherit values from the right hand\nYou can combine any of these into a list.\npair_links(list(range_link(1, \"a\"), waiver()) ~ list(4:5, c(\"b\", \"c\")))\n#&gt; &lt;ggalign_pair_links&gt;\n#&gt; A total of 1 pair of link groups\n#&gt; \n#&gt;                                    hand1 ~ hand2                 \n#&gt;   1:  list(range_link(1, \"a\"), waiver()) ~ list(4:5, c(\"b\", \"c\"))\n#&gt; \n#&gt; A total of 2 link groups\nIn this example, the left side combines the range between the 1st observation and “a” with the observations 4 and 5, and the observations “b” and “c”.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotate Observations</span>"
    ]
  },
  {
    "objectID": "annotate-observations.html#links",
    "href": "annotate-observations.html#links",
    "title": "15  Annotate Observations",
    "section": "",
    "text": "The object class and the number of paired groups.\nThe specific groups in each pair.\nThe total number of groups (rather than the number of paired groups). For example, in this case, there are 4 groups in total since each pair consists of 2 groups.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotate Observations</span>"
    ]
  },
  {
    "objectID": "annotate-observations.html#ggmark",
    "href": "annotate-observations.html#ggmark",
    "title": "15  Annotate Observations",
    "section": "15.2 ggmark()",
    "text": "15.2 ggmark()\nggmark() can be used to add annotation plot for the selected observations. ggmark accepts mark argument, which should be a mark_draw() object to define how to draw the links. Currently, two internal functions mark_line(), mark_tetragon() can be used to quickly draw line and quadrilateral links used to connect the selected observations and the plot panel.\nBy default, when no manual observations were selected, ggmark() will select all observations and split them based on the groups defined in the layout.\nThe data underlying the ggplot object generated by ggmark() is similar to that of ggalign() (Section 9.1), but it differs in that it does not include the .x, .y, and .discrete_x/.discrete_y columns. Instead, a special column named .hand is added, which is a factor with levels c(\"left\", \"right\") for horizontal stack layouts or c(\"top\", \"bottom\") for vertical stack layouts. This column indicates the position of the linked observations.\n\nNote: Only data for selected observations are retained.\n\nYou can adjust the link size by using the plot.margin argument.\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_line()) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_tetragon()) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nIf you manually provide the linked observations, you can use the group1 and group2 arguments to control whether the layout panel groups and their ordering should be used to create the annotations.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_tetragon(1:3), group1 = TRUE) +\n    geom_boxplot(aes(.names, value)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nBy default, ggmark() uses facet_wrap to define the facet, and you can use it to control the facet apearance (just ignore the facets argument). We prefer facet_wrap() here because it offers flexibility in positioning the strip on any side of the panel, and typically, we only want to a single dimension to create the annotate the selected observations. However, you can still use facet_grid() to create a two-dimensional plot. Note that for horizontal stack layouts, the row facets, or for vertical stack layouts, the column facets will always be overwritten.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(mark_line()) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nYou can further customize the appearance of link lines and quadrilaterals using the element argument in mark_line()/mark_tetragon() function:\n\nLink lines can be customized using the element_line().\nLink ranges can be customized using the element_polygon().\n\nBy default, vectorized fields in element_line() and element_polygon() will be recycled to match the total number of groups.\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_line(4:6, 1:2, \n            .element =  element_line(color = c(\"red\", \"blue\"))\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_tetragon(4:6, 1:2, \n            .element =  element_polygon(fill = c(\"red\", \"blue\"), alpha = 0.5)\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n\n\nYou can wrap the element with I() to recycle it to match the drawing groups. The drawing groups typically correspond to the number of observations for element_line(), as each observation will be linked with the plot panel.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_line(4:6, 1:2, \n            .element =  I(element_line(color = c(\"red\", \"blue\")))\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFor element_polygon(), the drawing groups usually align with the defined groups. However, if the defined group of observations is separated and cannot be linked with a single quadrilateral, the number of drawing groups will be larger than the number of defined groups.\n\nset.seed(123)\nggheatmap(small_mat) +\n    theme(axis.text.x = element_text(hjust = 0, angle = -60)) +\n    anno_right() +\n    align_kmeans(3L) +\n    ggmark(\n        mark_tetragon(4:6, 1:2, \n            .element =  I(element_polygon(fill = c(\"red\", \"blue\"), alpha = 0.5))\n        )\n    ) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    facet_wrap(vars(), scales = \"free\", strip.position = \"right\") +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, unit = \"npc\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nFor stack_layout(), we usually don’t need to specify the observations for hand2, since it should match hand1. This is because all plots in stack_discrete() should maintain the same ordering index. However, specifying hand2 becomes useful in stack_cross(), where different orderings are involved.\n\nstack_discreteh(small_mat) +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_x_reverse(expand = expansion()) +\n    theme(plot.margin = margin()) +\n    ggmark(mark_line(4:6 ~ waiver(), 1:2 ~ waiver())) +\n    geom_boxplot(aes(.names, value, fill = .names)) +\n    theme(plot.margin = margin(l = 0.1, t = 0.1, r = 0.1, b = 0.1, unit = \"npc\")) +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_x_continuous(expand = expansion()) +\n    theme(plot.margin = margin())\n\n\n\n\n\n\n\n\nNow, let’s move on to the next chapter, where we will introduce quad_layout() in full. While we’ve already introduced ggheatmap()—a specialized version of quad_layout()—most of the operations discussed in Chapter 7 can also be applied to quad_layout(). In the next section, we’ll delve into quad_layout() and explore its full functionality.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotate Observations</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html",
    "href": "difference-with-ggplot2.html",
    "title": "16  Difference with ggplot2",
    "section": "",
    "text": "16.1 Position Scales\nggalign focuses on aligning axes across multiple plots. While it builds on the ggplot2 framework, there are key differences in how scales, facets, and coordinates are handled. This chapter highlights these syntax differences.\nTo better fit the alignment-based layout, ggalign introduces adjustments to breaks, labels, and expand arguments.\nFor discrete values, ggalign introduces special syntax and handling for these axes, differing from the default behavior in ggplot2. These adjustments ensure that observations are properly aligned and operations are user-friendly.\nThe following syntax applies to the axes used to align observations (discrete values).",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#position-scales",
    "href": "difference-with-ggplot2.html#position-scales",
    "title": "16  Difference with ggplot2",
    "section": "",
    "text": "16.1.1 Breaks\nbreaks and labels are typically handled similarly to discrete scales, as we focus on aligning observations (which should be regarded as discrete variables); no matter what you use is continuous scale or discrete scale.\nbreaks should be one of:\n\n\nNULL for no breaks\n\nwaiver() for the default breaks (the full data index or NULL if no data names and labels is waiver())\nA character vector of breaks (rownames / colunames of the matrix).\nA numeric vector of data index (must be an integer).\nA function that takes the data names or the data index as input and returns breaks as output. Also accepts rlang lambda function notation.\n\nDefault breaks without names:\n\nno_names &lt;- small_mat\ncolnames(no_names) &lt;- NULL\nggheatmap(no_names) + scale_x_continuous()\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nNo breaks:\n\nggheatmap(small_mat) + scale_x_continuous(breaks = NULL)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.discrete_x, .discrete_y, fill = value)) +\n    scale_x_discrete(breaks = NULL)\n\n\n\n\n\n\n\nCharacter-based breaks use data names (or indices if names are absent)\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(\"column3\", \"column5\")) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.discrete_x, .discrete_y, fill = value)) +\n    scale_x_discrete(breaks = c(\"column3\", \"column5\")) +\n    anno_top() +\n    align_dendro(k = 3L)\n\n\n\n\n\n\n\nInteger-based breaks are interpreted as data indices:\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(3, 5)) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\nggheatmap(small_mat, filling = FALSE) +\n    geom_tile(aes(.discrete_x, .discrete_y, fill = value)) +\n    scale_x_discrete(breaks = c(3, 5)) +\n    anno_top() +\n    align_dendro(k = 3L)\n\n\n\n\n\n\n\nFloating numbers are invalid for breaks:\n\nggheatmap(small_mat) + scale_x_continuous(breaks = c(3.5, 5))\n#&gt; → heatmap built with `geom_tile()`\n#&gt; Error in `scale_x_continuous()`:\n#&gt; ! Can't convert from `breaks` &lt;double&gt; to &lt;integer&gt; due to loss of precision.\n#&gt; • Locations: 1\n\nTo interpret integers as plot-specific coordinate indices, wrap them with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = I(3:4)) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\n\n16.1.2 Labels\nlabels should be one of:\n\n\nNULL for no labels\n\nwaiver() for the default labels (data names)\nA character vector giving labels (must be same length as breaks)\nAn expression vector (must be the same length as breaks). See ?plotmath for details.\nA function that takes the data names (or data index if data has no names) as input and returns labels as output. This can be also a rlang lambda function.\n\nThe default labels are the data names (or indices if names are absent):\n\nggheatmap(small_mat) + scale_x_continuous() + anno_top() + align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nNo labels:\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = NULL) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nCharacter labels will be reordered based on the data’s ordering:\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = letters[seq_len(ncol(small_mat))]) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nTo retain the original order of character labels, wrap them with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(labels = I(letters[seq_len(ncol(small_mat))])) +\n    anno_top() +\n    align_dendro(k = 3L)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nBy default, labels correspond to breaks:\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(5, 3), labels = c(\"a\", \"b\"))\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nTo override the default matching, wrap the labels vector with I():\n\nggheatmap(small_mat) +\n    scale_x_continuous(breaks = c(5, 3), labels = I(c(\"a\", \"b\")))\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#theme",
    "href": "difference-with-ggplot2.html#theme",
    "title": "16  Difference with ggplot2",
    "section": "\n16.2 Theme",
    "text": "16.2 Theme\nAlthough ggplot2 does not officially support vectorized input for theme elements, we can still utilize it. ggalign extends this feature, allowing theme elements to be vectorized and applied across panels.\n\nggheatmap(small_mat) +\n    theme(\n        axis.text.x = element_text(\n            colour = c(rep(\"red\", 4), rep(\"blue\", 5))\n        ),\n        axis.ticks.x = element_line(\n            colour = c(rep(\"red\", 4), rep(\"blue\", 5))\n        ),\n        axis.ticks.length.x = unit(rep(c(1, 4), times = c(4, 5)), \"mm\")\n    ) +\n    anno_top() +\n    align_dendro(aes(color = branch), k = 3L) +\n    scale_y_continuous(expand = expansion()) &\n    theme(plot.margin = margin())\n#&gt; Warning: Vectorized input to `element_text()` is not officially supported.\n#&gt; ℹ Results may be unexpected or may change in future versions of ggplot2.\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "difference-with-ggplot2.html#facets",
    "href": "difference-with-ggplot2.html#facets",
    "title": "16  Difference with ggplot2",
    "section": "\n16.3 Facets",
    "text": "16.3 Facets\nWhen working with facets, manual configuration of the panel using the facet_*() functions is not possible since the internal structure will use facet_grid() to set the row/column groups defined by align_*() functions. However, you can still use facet_grid() or facet_null() (if no panel) to control other arguments except aligned panels (rows in horizontal stack layout or cols in vertical stack layout, or both rows and cols in heatmap body).\nA common use case is to modify the panel strip text. The default theme (theme_ggalign()) will always remove the panel strip text, you can override this behaviour with theme(strip.text = element_text()) to add the panel title in the plot area.\n\nggheatmap(small_mat) +\n    facet_grid(\n        labeller = labeller(.column_panel = function(x) letters[as.integer(x)])\n    ) +\n    theme(strip.text = element_text()) +\n    anno_top() +\n    align_kmeans(centers = 3L)\n#&gt; → heatmap built with `geom_tile()`",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Difference with ggplot2</span>"
    ]
  },
  {
    "objectID": "oncoplot.html",
    "href": "oncoplot.html",
    "title": "17  ggoncoplot",
    "section": "",
    "text": "17.1 Input Data\nThe ggoncoplot() function generates oncoPrint visualizations that display genetic alterations in a matrix format. This function is especially useful for visualizing complex genomic data, such as mutations, copy number variations, and other genomic alterations in cancer research.\nThe input should be a character matrix which encodes the alterations, you can use string of \";\", \":\", \",\", and \"|\" to separate multiple alterations. Internally, ggoncoplot() will use fortify_matrix() to get such matrix.\nmat &lt;- read.table(\n    textConnection(\n        \"s1,s2,s3\n         g1,snv;indel,snv,indel\n         g2,,snv;indel,snv\n         g3,snv,,indel;snv\"\n    ),\n    row.names = 1, header = TRUE, sep = \",\", stringsAsFactors = FALSE\n)\nmat\n#&gt;                    s1        s2        s3\n#&gt;          g1 snv;indel       snv     indel\n#&gt;          g2           snv;indel       snv\n#&gt;          g3       snv           indel;snv\nA basic oncoprint can be generated as follows:\nggoncoplot(mat)",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#oncoprint-customization",
    "href": "oncoplot.html#oncoprint-customization",
    "title": "17  ggoncoplot",
    "section": "\n17.2 OncoPrint Customization",
    "text": "17.2 OncoPrint Customization\nBy default, all alterations are represented with tiles of equal width and height, which may lead to overlapping. You can control the width and height of the tiles using the map_width and map_height arguments (we will introduce another more effective ways to handle this in the Specialized Geoms section):\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9))\n\n\n\n\n\n\n\nBy default, all empty string will be converted to NA value and ggplot2 will translate the NA values and render it in the legend. To prevent this, you can turn off the translation using na.translate = FALSE:\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n\n\n\n\n\n\n\nThe function automatically reorders rows and columns based on alteration frequency. Disable this with reorder_row = FALSE and reorder_column = FALSE.\nYou can further customize layouts using methods from ?sec-layout-customize.\n\nggoncoplot(mat,\n    map_width = c(snv = 0.5), map_height = c(indel = 0.9),\n    reorder_row = FALSE, reorder_column = FALSE\n) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#advanced-data-handling",
    "href": "oncoplot.html#advanced-data-handling",
    "title": "17  ggoncoplot",
    "section": "\n17.3 Advanced Data Handling",
    "text": "17.3 Advanced Data Handling\nggoncoplot() is built on ggheatmap() with a default scheme_data() (see Chapter 14 for details), which splits alterations into separate entries for visualization. (See ggplot2 specification section in ggheatmap() for the input data of scheme_data()):\n\npdata &lt;- function(data) {\n    tidyr::separate_longer_delim(data,\n        cols = value,\n        delim = stringr::regex(\"\\\\s*[;:,|]\\\\s*\")\n    )\n}\n# Note: this figure will contain an empty string value.\n#\n# `ggoncoplot()` will automatically convert any empty strings to `NA`\n# before pass it to `ggheatmap`.\nggheatmap(mat) -\n    scheme_data(pdata) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n#&gt; → heatmap built with `geom_tile()`\n\n\n\n\n\n\n\nBy default, the scheme_data() is inherited from the parent layout if the data of the plot is inherited from the layout. You can apply the parent scheme_data() first and then apply another transformation by setting inherit = TRUE. This functionality is especially useful when working with ggoncoplot().\n\nggoncoplot(mat, map_width = c(snv = 0.5), map_height = c(indel = 0.9)) +\n    anno_top(size = 0.2) +\n    ggalign() +\n    # by setting `inherti = TRUE`, we apply the parent layout `scheme_data()`\n    # (from the `ggoncoplot()` layout) firstly, which will split the alteration\n    # string and unnested the columns.\n    # Here: We then remove `NA` value\n    scheme_data(~ subset(.x, !is.na(value)), inherit = TRUE) +\n    geom_bar(aes(.x, after_stat(count), fill = value)) +\n    # note: `ggoncoplot()` use `geom_tile()` to draw the oncoPrint,\n    # the guide is different from `geom_bar()`, though both looks\n    # like the same, we remove the guide of `geom_bar()` plot\n    guides(fill = \"none\") &\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#integration-with-maftools",
    "href": "oncoplot.html#integration-with-maftools",
    "title": "17  ggoncoplot",
    "section": "\n17.4 Integration with maftools\n",
    "text": "17.4 Integration with maftools\n\nThe ggoncoplot() function supports MAF objects from the maftools package using the fortify_matrix.MAF() method. It includes options to control data generation for ggoncoplot(), such as drawing the top n_top genes.\n\n# load data from `maftools`\nlaml.maf &lt;- system.file(\"extdata\", \"tcga_laml.maf.gz\", package = \"maftools\")\n# clinical information containing survival information and histology. This is optional\nlaml.clin &lt;- system.file(\"extdata\", \"tcga_laml_annot.tsv\", package = \"maftools\")\nlaml &lt;- maftools::read.maf(\n    maf = laml.maf,\n    clinicalData = laml.clin,\n    verbose = FALSE\n)\n# Visualizing the Top 20 Genes\nggoncoplot(laml, n_top = 20) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n\n\n\n\n\n\n\nBy default, samples without alterations in the selected genes are removed. To include all samples, set remove_empty_samples = FALSE:\n\nalign_plots(\n    ggoncoplot(laml, n_top = 20L, remove_empty_samples = FALSE) +\n        scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n        theme_no_axes(\"x\") +\n        ggtitle(\"Keep empty samples\"),\n    ggoncoplot(laml, n_top = 20L, remove_empty_samples = TRUE) +\n        scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n        theme_no_axes(\"x\") +\n        ggtitle(\"Remove empty samples\"),\n    ncol = 1L,\n    guides = \"tlbr\"\n)",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#specialized-geoms",
    "href": "oncoplot.html#specialized-geoms",
    "title": "17  ggoncoplot",
    "section": "\n17.5 Specialized Geoms",
    "text": "17.5 Specialized Geoms\n\n17.5.1 geom_subtile()\n\nWhen multiple alterations occur in the same sample and gene, they are combined into a single value, \"Multi_Hit\", by default. To visualize these alterations separately, you can set collapse_vars = FALSE. However, doing so can lead to overlapping alterations within the same cell, making the visualization cluttered and hard to interpret.\nIn such cases, disabling the default filling and defining a custom heatmap layer with geom_subtile() is more effective. This function subdivides each cell into smaller rectangles, allowing the distinct alterations to be clearly displayed.\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), ncol = 1L) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\nWe focus exclusively on cells with multiple alterations to highlight the differences, by filtering the data before applying geom_subtile():\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    scheme_data(function(data) {\n        dplyr::filter(data, dplyr::n() &gt; 1L, .by = c(\".x\", \".y\"))\n        # we apply the parent layout `scheme_data()` first (`inherit = TRUE`),\n        # which will split the alteration string and unnested the columns.\n    }, inherit = TRUE) +\n    geom_subtile(aes(fill = value), ncol = 1L) +\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\n\n17.5.2 geom_gshape()\ngeom_subtile() often suffices for most scenarios. However, if you require a strategy similar to that of ComplexHeatmap, consider using geom_gshape(), which offers greater flexibility for complex customizations.\nKey Features of geom_gshape():\n\nCustom Drawing Logic: Accepts a gshape aesthetic, allowing each cell to be rendered as a specific graphical object (grob).\nFlexible Aesthetic Mapping: You must provide the manual scaling scale_gshape_manual() to map gshape values to corresponding drawing functions. Functions mapped through scale_gshape_manual() can utilize any number of ggplot2 aesthetics and output custom graphical objects (grob).\n\nThe function provided in values argument of scale_gshape_manual() operates similarly to alter_fun in ComplexHeatmap. Currently, geom_subtile() performs well enough for most cases, making geom_gshape() somewhat cumbersome to use. Managing alteration types, especially in the case of overlapping alterations, requires meticulous design to ensure that the visual elements do not interfere with each other.",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#data-attributes",
    "href": "oncoplot.html#data-attributes",
    "title": "17  ggoncoplot",
    "section": "\n17.6 Data Attributes",
    "text": "17.6 Data Attributes\nExcept for the data used for the main plot, fortify_matrix.MAF() also attaches several useful attributes.\n\n\ngene_summary: A data frame of gene summary informations. See maftools::getGeneSummary() for details.\n\nsample_summary: A data frame of sample summary informations. See maftools::getSampleSummary() for details.\n\nsample_anno: A data frame of sample clinical informations. See maftools::getClinicalData() for details.\n\nvariant_weights: A data frame of variant weights. Each gene in a sample is assigned a total weight of 1. When multiple variants occur in the same gene-sample pair, the weight for each variant reflects its proportion of the total.\n\nn_genes: Total number of genes.\n\nn_samples: Total number of samples.\n\ntitv: A list of data frame with Transitions and Transversions summary. See maftools::titv() for details.\n\nYou can extract these attributes using the ggalign_attr() function. Below is an example of how to extract the sample summary data (e.g., TMB) using ggalign_attr() and add it to the top annotation of an oncoplot:\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), ncol = 1) +\n    theme_no_axes(\"x\") +\n    anno_top(size = 0.2) +\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"sample_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:(ncol(data) - 1L)])\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    ylab(\"TMB\") &\n    scale_fill_brewer(palette = \"Dark2\", na.translate = FALSE)\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n\n\n\n\n\n\n\nWe can draw the example from maftools vignette.\n\nggoncoplot(laml, n_top = 20, collapse_vars = FALSE, filling = FALSE) +\n    geom_subtile(aes(fill = value), ncol = 1) +\n    theme_no_axes(\"x\") +\n    # since legends from geom_tile (oncoPrint body) and `geom_bar`\n    # is different, though both looks like the same, the internal\n    # won't merge the legends. we remove the legends of oncoPrint body\n    guides(fill = \"none\") +\n    # add top annotation\n    anno_top(size = 0.2) +\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"sample_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:(ncol(data) - 1L)])\n    }) +\n    geom_bar(aes(.x, value, fill = .column_names),\n        stat = \"identity\"\n    ) +\n    ylab(\"TMB\") +\n    # add right annotation\n    anno_right(size = 0.2) -\n    # remove bottom spaces of the right annotation when aligning\n    scheme_align(free_spaces = \"b\") +\n    # add the text percent for the alterated samples in the right annotation\n    ggalign(data = function(data) {\n        # Atomic vector will be put in the `value` column of the data frame.\n        ggalign_attr(data, \"gene_summary\")$AlteredSamples /\n            ggalign_attr(data, \"n_samples\")\n    }) +\n    geom_text(aes(1, label = scales::label_percent()(value)), hjust = 1) +\n    scale_x_continuous(\n        expand = expansion(),\n        name = NULL, breaks = NULL,\n        limits = c(0, 1)\n    ) +\n    theme(plot.margin = margin()) +\n    # add the bar plot in the right annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"gene_summary\")\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:8])\n    }) +\n    geom_bar(aes(value, fill = .column_names),\n        stat = \"identity\",\n        orientation = \"y\"\n    ) +\n    xlab(\"No. of samples\") -\n    # we apply the scale mapping to the top and right annotation: `position = \"tr\"`\n    # and the main plot: `position = \"i\"`\n    quad_scope(\n        scale_fill_brewer(\"Mutations\",\n            palette = \"Dark2\", na.translate = FALSE\n        ),\n        position = \"tri\"\n    ) +\n    # add bottom annotation\n    anno_bottom(size = 0.2) +\n    # add bar plot in the bottom annotation\n    ggalign(data = function(data) {\n        data &lt;- ggalign_attr(data, \"titv\")$fraction.contribution\n        # matrix input will be automatically melted into a long foramted data\n        # frame in `ggalign()` function.\n        as.matrix(data[2:7])\n    }) +\n    geom_bar(aes(y = value, fill = .column_names), stat = \"identity\") +\n    ylab(\"Ti/Tv\") +\n    scale_fill_brewer(\"Ti/Tv\", palette = \"Set2\")\n#&gt; `geom_subtile()` subdivide tile into a maximal of 3 rectangles\n#&gt; Warning: Removed 24 rows containing missing values or values outside the scale range\n#&gt; (`geom_bar()`).",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  },
  {
    "objectID": "oncoplot.html#integration-with-gistic-results-from-maftools",
    "href": "oncoplot.html#integration-with-gistic-results-from-maftools",
    "title": "17  ggoncoplot",
    "section": "\n17.7 Integration with GISTIC Results from maftools\n",
    "text": "17.7 Integration with GISTIC Results from maftools\n\nThe package also includes a fortify_matrix.GISTIC() method designed to handle GISTIC objects from the maftools package. This allows you to seamlessly apply the same operations to visualize GISTIC results. The following ggalign attributes are generated as part of the analysis:\n\n\nsample_anno: sample clinical informations provided in sample_anno argument.\n\nsample_summary: sample copy number summary informations. See data@cnv.summary for details.\n\ncytoband_summary: cytoband summary informations. See data@cytoband.summary for details.\n\ngene_summary: gene summary informations. See data@gene.summary for details.\n\nsummary: A data frame of summary information. See data@summary for details.\n\n\n# Ensure the maftools package is installed and load the example GISTIC data\nall.lesions &lt;- system.file(\"extdata\", \"all_lesions.conf_99.txt\", package = \"maftools\")\namp.genes &lt;- system.file(\"extdata\", \"amp_genes.conf_99.txt\", package = \"maftools\")\ndel.genes &lt;- system.file(\"extdata\", \"del_genes.conf_99.txt\", package = \"maftools\")\nscores.gistic &lt;- system.file(\"extdata\", \"scores.gistic\", package = \"maftools\")\nlaml.gistic &lt;- maftools::readGistic(\n    gisticAllLesionsFile = all.lesions, gisticAmpGenesFile = amp.genes,\n    gisticDelGenesFile = del.genes, gisticScoresFile = scores.gistic\n)\n#&gt; -Processing Gistic files..\n#&gt; --Processing amp_genes.conf_99.txt\n#&gt; --Processing del_genes.conf_99.txt\n#&gt; --Processing scores.gistic\n#&gt; --Summarizing by samples\nggoncoplot(laml.gistic) +\n    scale_fill_brewer(\"CNV\", palette = \"Dark2\", na.translate = FALSE) +\n    theme_no_axes(\"x\")",
    "crumbs": [
      "Data-aware composition",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>ggoncoplot</span>"
    ]
  }
]